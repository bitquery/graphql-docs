schema {
  query: Query
  subscription: Subscription
}

"""Account"""
type Account {
  """Account ID"""
  id: String!
  """Account number, the equivalent of a human-friendly public key"""
  num: Int!
  """Realm number """
  realmId: Int!
  """Shard number"""
  shardId: Int!
}

"""Solana Action"""
type Action {
  name: String!
  type: String!
}

enum ActionEnum {
  """Transfer"""
  transfer
  """Burn"""
  burn
  """Mint"""
  create
  """Mint"""
  localMint
  """Add Quantity"""
  addQuantity
  """Transaction"""
  transaction
  """Fee"""
  fee
}

"""Select by action"""
input ActionSelector {
  """Action is"""
  is: ActionEnum
  """Action not"""
  not: ActionEnum
  """Action in the list"""
  in: [ActionEnum!]
  """Action not in the list"""
  notIn: [ActionEnum!]
}

enum ActiveAddress {
  """Address"""
  address
}

"""ActivePeriod"""
type ActivePeriod {
  """Billing day"""
  billingDay: Int!
  """Period ends at"""
  ends: UtilitiesDate!
  """Is blocked"""
  isBlocked: Boolean!
  """Is paid"""
  isPaid: Boolean!
  """Is points consumed"""
  isPointsConsumed: Boolean!
  """Is spent"""
  isSpent: Boolean!
  """Total available points"""
  points: BigInt!
  """Remaining points"""
  pointsRemaining: BigInt!
  """Period starts at"""
  starts: UtilitiesDate!
}

"""Blockchain address"""
type Address {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
}

"""Address selector"""
input AddressSelector {
  """Equal to Address"""
  is: String
  """Not Equal to Address"""
  not: String
  """In the list of Addresses"""
  in: [String!]
  """Not in the list of Addresses"""
  notIn: [String!]
}

"""Address selector"""
input AddressSelectorIn {
  """Equal to Address"""
  is: String
  """In the list of Addresses"""
  in: [String!]
}

"""Address with statistics"""
type AddressStatDimension {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Balance"""
  balance(in: BaseCurrencyEnum): Float
  """First active"""
  firstActive: DateTime
  """Inbound transactions"""
  inboundTransactions: Int
  """Inflows"""
  inflows: Float
  """Last active"""
  lastActive: DateTime
  """Outbound transactions"""
  outboundTransactions: Int
  """Outflows"""
  outflows: Float
  """Unique days with transfers"""
  uniqueDaysWithTransfers: Int
  """Unique receivers"""
  uniqueReceivers: Int
  """Unique senders"""
  uniqueSenders: Int
}

"""Blockchain account with address and type"""
type AddressWithAccount {
  """Account ID"""
  account: String!
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Account type"""
  type: String!
}

"""Algorand Blockchain"""
type Algorand {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [AlgorandAddressInfo!]!
  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AddressSelector!], caller: [AddressSelector!], reference: [AddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AddressSelector!], argindex: ArgumentIndexSelector, any: [AlgorandArgumentFilter!], options: QueryOptions): [AlgorandArguments!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector, any: [AlgorandBlockFilter!], options: QueryOptions): [AlgorandBlocks!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: [AlgorandCurrencySelector!], initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [AlgorandCoinpath!]
  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector, any: [AlgorandSmartContractCallFilter!], options: QueryOptions): [AlgorandSmartContractCalls!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector, group: GroupSelector, any: [AlgorandTransactionFilter!], options: QueryOptions): [AlgorandTransactions!]
  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector, any: [AlgorandTransferFilter!], options: QueryOptions): [AlgorandTransfers!]
}

"""Address detailed information for Algorand network"""
type AlgorandAddressInfo {
  """Address"""
  address: Address
  """Current address balance"""
  balance(in: BaseCurrencyEnum): Float
  """Current pending rewards"""
  pendingRewards(in: BaseCurrencyEnum): Float
  """Current rewards"""
  rewards(in: BaseCurrencyEnum): Float
  """Current round"""
  round: String
  """Smart Contract if exists on the address"""
  smartContract: AlgorandSmartContract
  """Current status"""
  status: String
}

input AlgorandArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txType: TxTypeSelector
  txFrom: [AddressSelector!]
  caller: [AddressSelector!]
  reference: [AddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  smartContractAddress: [AddressSelector!]
  argindex: ArgumentIndexSelector
}

"""Arguments of Smart Contract Calls"""
type AlgorandArguments {
  any(of: AlgorandArgumentsMeasureable!): String
  """Sequential index of value in array ( multi-dimensional)"""
  argindex: Int!
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AddressSelector!], caller: [AddressSelector!], reference: [AddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AddressSelector!], argindex: ArgumentIndexSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txType: TxTypeSelector, txFrom: [AddressSelector!], caller: [AddressSelector!], reference: [AddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], smartContractAddress: [AddressSelector!], argindex: ArgumentIndexSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  minimum(of: AlgorandArgumentsMeasureable!, get: AlgorandArgumentsMeasureable): String
  note: String
  poolerror: String
  """Smart contract being called"""
  smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract
  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [AddressSelector!]): TransactionHashIndex
  """Transaction sender"""
  txSender(txSender: [AddressSelector!]): Address
  """Transaction type in which the transfer happened"""
  txType(txType: [AlgorandTxType!]): AlgorandTxType
  """The Value of argument"""
  value(value: [ArgumentValueSelector!]): String
}

enum AlgorandArgumentsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction type"""
  tx_type
  """Transaction Sender"""
  tx_sender
  """Smart Contract"""
  smart_contract
  """Argument value"""
  argument_value
  """Argument index"""
  argument_index
}

input AlgorandBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: [AddressSelector!]
  blockReward: [AmountSelector!]
  nextProtocol: StringIdSelector
  currentProtocol: StringIdSelector
}

"""Blocks in Algorand blockchain"""
type AlgorandBlocks {
  any(of: AlgorandBlocksMeasureable!): String
  count(uniq: AlgorandBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Int
  countBigInt(uniq: AlgorandBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): BigInt
  currentProtocol: String
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  frac: BigInt!
  """Block hash"""
  hash(blockHash: [HashSelector!]): String!
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  minimum(of: AlgorandBlocksMeasureable!, get: AlgorandBlocksMeasureable): String
  nextProtocol: String
  nextProtocolApprovals: BigInt
  nextProtocolSwitchOn: BigInt
  nextProtocolVoteBefore: BigInt
  """Previous block hash"""
  previousBlockHash: String!
  """Block proposer"""
  proposer(proposer: [AddressSelector!]): Address
  rate(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: [AddressSelector!], blockReward: [AmountSelector!], nextProtocol: StringIdSelector, currentProtocol: StringIdSelector): Float
  seed: String
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  txnRoot: String!
  upgradeApprove: Int
  upgradePropose: String
}

enum AlgorandBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Block Reward"""
  block_reward
  """Block Proposer"""
  proposer
  """Next protocol approvals"""
  next_protocol_approvals
}

enum AlgorandBlocksUniq {
  """Unique proposer count"""
  proposers
  """Unique date count"""
  dates
}

enum AlgorandCallsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction type"""
  tx_type
  """Transaction Sender"""
  tx_sender
  """Smart Contract"""
  smart_contract
}

"""Coinpath"""
type AlgorandCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

"""
Currency selector in Algorand blockchain.
  Currency is selected by asset ID. To select ALGO use ID=0
"""
input AlgorandCurrencySelector {
  """Currency is"""
  is: Int
  """Currency not"""
  not: Int
  """Currency in the list"""
  in: [Int!]
  """Currency not in the list"""
  notIn: [Int!]
}

enum AlgorandNetwork {
  """Algorand Mainnet (ALGO)"""
  algorand
  """Algorand Testnet"""
  algorand_testnet
  """Algorand Betanet"""
  algorand_betanet
}

"""Algorand smart contract"""
type AlgorandSmartContract {
  """Smart Contract Address"""
  address: Address!
  """Smart Contract byte code"""
  bytecode: String
  """Smart Contract Deassembled source code"""
  source: String
}

input AlgorandSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  txSender: [AddressSelector!]
  smartContractAddress: [AddressSelector!]
  txType: TxTypeSelector
}

"""Smart Contract Calls"""
type AlgorandSmartContractCalls {
  any(of: AlgorandCallsMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Fee used in transaction call"""
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, txSender: [AddressSelector!], smartContractAddress: [AddressSelector!], txType: TxTypeSelector): Float
  firstRound: Int
  genesisHash64: String
  genesisId: String
  lastRound: Int
  maximum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  minimum(of: AlgorandCallsMeasureable!, get: AlgorandCallsMeasureable): String
  note: String
  poolerror: String
  """Smart contract being called"""
  smartContract(smartContractAddress: [AddressSelector!]): AlgorandSmartContract
  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [AddressSelector!]): TransactionHashIndex
  """Transaction sender"""
  txSender(txSender: [AddressSelector!]): Address
  """Transaction type in which the transfer happened"""
  txType(txType: [AlgorandTxType!]): AlgorandTxType
}

input AlgorandTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AddressSelector!]
  txIndex: TxIndexSelector
  txCurrency: [AlgorandCurrencySelector!]
  txType: TxTypeSelector
  txSubtype: TxSubtypeSelector
  group: GroupSelector
}

"""Transactions in Algorand blockchain"""
type AlgorandTransactions {
  any(of: AlgorandTransactionsMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: AlgorandTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector, group: GroupSelector): Int
  countBigInt(uniq: AlgorandTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector, group: GroupSelector): BigInt
  """Asset related to transaction"""
  currency(txCurrency: [AlgorandCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, txCurrency: [AlgorandCurrencySelector!], txType: TxTypeSelector, txSubtype: TxSubtypeSelector, group: GroupSelector): Float
  firstRound: Int
  genesisHash: String
  genesisId: String
  group: String
  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!
  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  lastRound: Int
  maximum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  minimum(of: AlgorandTransactionsMeasureable!, get: AlgorandTransactionsMeasureable): String
  note: String
  poolerror: String
  """Transaction sender"""
  sender(txSender: [AddressSelector!]): Address
  """Transaction sub type"""
  subtype(txType: TxSubtypeSelector): AlgorandTxSubType
  """Transaction type"""
  type(txType: TxTypeSelector): AlgorandTxType
}

enum AlgorandTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Fee value"""
  fee
  """Transaction hash"""
  tx_hash
  """Transaction Sender"""
  tx_sender
}

enum AlgorandTransactionsUniq {
  """Unique TX senders count"""
  senders
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique currencies"""
  currencies
}

"""Algorand transaction with attributes"""
type AlgorandTransactionWithAttributes {
  """Block of the Output Transaction for this input"""
  block: Int
  """Transaction fee"""
  fee: Float
  firstRound: Int
  """Transaction rewards ( from ) """
  fromrewards: Float
  group: String
  """Hash hex representation"""
  hash: String!
  """Transaction index in block, 0-based"""
  index: String!
  lastRound: Int
  lease: String
  note: String
  poolerror: String
  """Transfer transaction sender"""
  sender: Address
  """Transaction sub type"""
  subtype: AlgorandTxSubType
  """Transaction type in which the transfer happened"""
  type: AlgorandTxType
}

input AlgorandTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [AddressSelector!]
  txIndex: TxIndexSelector
  sender: [AddressSelector!]
  receiver: [AddressSelector!]
  currency: [AlgorandCurrencySelector!]
  amount: [AmountSelector!]
  txType: TxTypeSelector
  transferType: AlgorandTransferTypeSelector
}

"""Currency transfers from/to addresses in crypto currencies"""
type AlgorandTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Float
  any(of: AlgorandTransfersMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [AddressSelector!], txIndex: TxIndexSelector, sender: [AddressSelector!], receiver: [AddressSelector!], currency: [AlgorandCurrencySelector!], amount: [AmountSelector!], txType: TxTypeSelector, transferType: AlgorandTransferTypeSelector): BigInt
  """Currency of transfer"""
  currency(currency: [AlgorandCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  firstRound: Int
  lastRound: Int
  maximum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String
  memo: String
  minimum(of: AlgorandTransfersMeasureable!, get: AlgorandTransfersMeasureable): String
  """Transfer receiver"""
  receiver(receiver: [AddressSelector!]): Address
  """Transfer sender"""
  sender(sender: [AddressSelector!]): Address
  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!]): AlgorandTransactionWithAttributes
  """Transfer Type"""
  transferType(transferType: [AlgorandTransferType!]): AlgorandTransferType
}

enum AlgorandTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """TX Sender"""
  tx_sender
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency symbol"""
  currency_symbol
  """Currency Asset ID"""
  asset_id
  """Transaction type"""
  tx_type
  """Transfer type"""
  transfer_type
}

enum AlgorandTransferType {
  """Genesis Block"""
  genesis
  """Create Asset"""
  create
  """Send"""
  send
  """Close"""
  close
  """Reward"""
  reward
  """Asset Freeze"""
  freeze
  """Asset Unfreeze"""
  unfreeze
}

"""Select transfers by type"""
input AlgorandTransferTypeSelector {
  """Transfer Type is"""
  is: AlgorandTransferType
  """Transfer Type not"""
  not: AlgorandTransferType
  """Transfer Type in the list"""
  in: [AlgorandTransferType!]
  """Transfer Type not in the list"""
  notIn: [AlgorandTransferType!]
}

enum AlgorandTxSubType {
  """Send"""
  send
  """Close"""
  close
  """Create"""
  create
  """Asset Configuration"""
  configure
  """Asset Freeze"""
  freeze
  """Asset Unfreeze"""
  unfreeze
  """Key Reg"""
  keyreg
  """None"""
  none
}

enum AlgorandTxType {
  """Genesis Block"""
  genesis
  """Pay"""
  pay
  """Key Reg"""
  keyreg
  """Asset Configuration"""
  acfg
  """Asset Transfer"""
  axfer
  """Asset Freeze or Unfreeze"""
  afrz
  """Application Call"""
  appl
}

enum AmountAggregateFunction {
  """Maximum"""
  maximum
  """Minimum"""
  minimum
  """Sum (total)"""
  sum
  """Average"""
  average
  """Median"""
  median
  """Unique estimate fast"""
  unique
  """Unique exact"""
  uniqueExact
  """Any value"""
  any
  """Last value"""
  anyLast
}

"""Select by amount"""
input AmountSelector {
  """Amount is"""
  is: Float
  """Amount not"""
  not: Float
  """Amount in the list"""
  in: [Float!]
  """Amount not in the list"""
  notIn: [Float!]
  """Amount greater than"""
  gt: Float
  """Amount less than"""
  lt: Float
  """Amount less or equal than"""
  lteq: Float
  """Amount greater or equal than"""
  gteq: Float
  """Amount in range"""
  between: [Float!]
}

"""Selector of index of argument in call"""
input ArgumentIndexSelector {
  """Tx index is"""
  is: Int
  """Tx index not"""
  not: Int
  """Tx index in the list"""
  in: [Int!]
  """Tx index not in the list"""
  notIn: [Int!]
}

"""Argument of Smart contract method or event"""
type ArgumentName {
  """Name"""
  name: String!
  """Type"""
  type: String!
}

"""Argument name and value of smart contract call or event"""
type ArgumentNameValue {
  """Argument name"""
  argument: String!
  """Argument data type"""
  argumentType: String!
  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  """Value as String"""
  value: String!
}

"""Selector of argument for smart contract method or event"""
input ArgumentSelector {
  """Argument is"""
  is: String
  """Argument not"""
  not: String
  """Argument in the list"""
  in: [String!]
  """Argument not in the list"""
  notIn: [String!]
}

"""Selector of argument type for smart contract method or event"""
input ArgumentTypeSelector {
  """Argument type is"""
  is: String
  """Argument type not"""
  not: String
  """Argument type in the list"""
  in: [String!]
  """Argument type not in the list"""
  notIn: [String!]
}

"""Argument value of smart contract call or event"""
type ArgumentValue {
  """Value as Address"""
  address: EthereumAddressInfo
  """Value as String"""
  value: String!
}

"""Selector of value of argument for smart contract method or event"""
input ArgumentValueSelector {
  """Value is"""
  is: String
  """Value not"""
  not: String
  """Value in the list"""
  in: [String!]
  """Value not in the list"""
  notIn: [String!]
}

enum BaseCurrencyEnum {
  """Dollar"""
  USD
  """Binance Smart Chain"""
  BNB
  """Ethereum"""
  ETH
  """Tether USDT"""
  USDT
  """Bitcoin"""
  BTC
}

"""Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string."""
scalar BigInt

"""Select by big number"""
input BigIntegerSelector {
  """is"""
  is: BigInt
  """not"""
  not: BigInt
  """in the list"""
  in: [BigInt!]
  """not in the list"""
  notIn: [BigInt!]
  """greater than"""
  gt: BigInt
  """less than"""
  lt: BigInt
  """less or equal than"""
  lteq: BigInt
  """greater or equal than"""
  gteq: BigInt
  """in range"""
  between: [BigInt!]
}

"""Select by ID with BigInt datatype"""
input BigIntIdSelector {
  """ID is"""
  is: BigInt
  """ID not"""
  not: BigInt
  """ID in the list"""
  in: [BigInt!]
  """ID not in the list"""
  notIn: [BigInt!]
  """ID greater than"""
  gt: BigInt
  """ID less than"""
  lt: BigInt
  """ID less or equal than"""
  lteq: BigInt
  """ID greater or equal than"""
  gteq: BigInt
  """ID in range"""
  between: [BigInt!]
}

"""Binance DEX"""
type Binance {
  """Binance DEX Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector, any: [BinanceBlockFilter!], options: QueryOptions): [BinanceBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: BinanceAddressSelector, receiver: BinanceAddressSelector, currency: [BinanceCurrencySelector!], initialAddress: BinanceAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [BinanceCoinpath!]
  """Binance DEX Network Exchange Orders"""
  orders(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!], any: [BinanceOrderFilter!], options: QueryOptions): [BinanceOrders!]
  """Binance DEX Network Trades between currencies"""
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], any: [BinanceTradeFilter!], options: QueryOptions): [BinanceTrades!]
  """Binance DEX Network Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!], any: [BinanceTransactionFilter!], options: QueryOptions): [BinanceTransactions!]
  """Binance DEX Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!], any: [BinanceTransferFilter!], options: QueryOptions): [BinanceTransfers!]
}

"""Binance Address should start with bnb and contain 42 chars."""
input BinanceAddressSelector {
  """Equal to Address"""
  is: String
  """Not Equal to Address"""
  not: String
  """In the list of Addresses"""
  in: String
  """Not in the list of Addresses"""
  notIn: String
}

"""Block"""
type BinanceBlock {
  any(of: BinanceBlocksMeasureable!): String
  """Block ID"""
  blockId(blockId: StringIdSelector): String
  count(uniq: BinanceBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector): Int
  countBigInt(uniq: BinanceBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: StringIdSelector, validatorMoniker: StringIdSelector, validatorFeeAddr: BinanceAddressSelector, validatorOperatorAddress: BinanceAddressSelector, validatorOperahraddress: BinanceAddressSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String
  minimum(of: BinanceBlocksMeasureable!, get: BinanceBlocksMeasureable): String
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Validator consensus pubkey"""
  validatorConsensusPubkey(validatorConsensusPubkey: StringIdSelector): String
  """Validator fee address"""
  validatorFeeAddr(validatorFeeAddr: BinanceAddressSelector): Address
  """Validator moniker"""
  validatorMoniker(validatorMoniker: StringIdSelector): String
  """Validator operator HR address"""
  validatorOperaHrAddress(validatorOperaHrAddress: BinanceAddressSelector): Address
  """Validator operator address"""
  validatorOperatorAddress(validatorOperatorAddress: BinanceAddressSelector): Address
}

input BinanceBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: StringIdSelector
  validatorMoniker: StringIdSelector
  validatorFeeAddr: BinanceAddressSelector
  validatorOperatorAddress: BinanceAddressSelector
  validatorOperahraddress: BinanceAddressSelector
}

enum BinanceBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Validator moniker"""
  validator_moniker
}

enum BinanceBlockUniq {
  """Validator operators"""
  validator_operator_addresses
  """Validator fee addresses"""
  validator_fee_addresses
  """Unique date count"""
  dates
}

"""Coinpath"""
type BinanceCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: BinanceCoinpathAddress
  """Sender address"""
  sender: BinanceCoinpathAddress
  """Transaction of transfer happened"""
  transaction: TransactionHashValueTime
}

"""Address detailed information for Binance network"""
type BinanceCoinpathAddress {
  """Address"""
  address: String
  """"""
  amountIn: DecimalNumber
  """"""
  amountOut: DecimalNumber
  """Annotations ( tags ), if exists"""
  annotation: String
  """"""
  balance: DecimalNumber
  """Smart Contract if exists on the address"""
  firstTxAt: DateTime
  """Smart Contract if exists on the address"""
  lastTxAt: DateTime
  """"""
  receiversCount: Int
  """"""
  sendersCount: Int
  """Address type"""
  type: String
}

"""
Binance token selector by tokenId.
    Native binance token has BNB symbol.
    Note that most Binance symbols has two dash separated parts, for example: 'TROY-9B8_BNB'
"""
input BinanceCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

input BinanceOrderFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  orderOwner: [BinanceAddressSelector!]
  orderId: [OrderIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
  orderStatus: [OrderStatusSelector!]
  orderType: [OrderTypeSelector!]
  orderSide: [OrderSideSelector!]
  orderTimeInForce: [OrderTimeInForceSelector!]
}

"""Binance DEX Order"""
type BinanceOrders {
  any(of: BinanceOrdersMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency
  """Block where order transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceOrdersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Int
  countBigInt(uniq: BinanceOrdersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String
  minimum(of: BinanceOrdersMeasureable!, get: BinanceOrdersMeasureable): String
  """Order ID"""
  orderId(orderId: [OrderIdSelector!]): String
  """Order owner address"""
  orderOwner(owner: [BinanceAddressSelector!]): Address
  """Order Side"""
  orderSide(orderSide: [OrderSideSelector!]): BinanceOrderSide
  """Order Status"""
  orderStatus(orderStatus: [OrderStatusSelector!]): BinanceOrderStatus
  """Order Time In Force"""
  orderTimeInForce(orderTimeInForce: [OrderTimeInForceSelector!]): BinanceOrderTimeInForce
  """Order Type"""
  orderType(orderType: [OrderTypeSelector!]): BinanceOrderType
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, orderOwner: [BinanceAddressSelector!], orderId: [OrderIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!], orderStatus: [OrderStatusSelector!], orderType: [OrderTypeSelector!], orderSide: [OrderSideSelector!], orderTimeInForce: [OrderTimeInForceSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency
  """Transaction where order created"""
  transaction(txHash: [HashSelector!]): TransactionHash
}

enum BinanceOrderSide {
  """Sell Side"""
  sell
  """Buy Side"""
  buy
}

enum BinanceOrdersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Order owner"""
  order_owner
  """Order status"""
  order_status
  """Order ID"""
  order_id
  """Order side"""
  order_side
  """Base currency"""
  base_currency
  """Quote currency"""
  quote_currency
  """Quote Amount"""
  quote_amount
  """Base Amount"""
  base_amount
  """Price"""
  price
}

enum BinanceOrderStatus {
  """Ack"""
  Ack
  """Canceled"""
  Canceled
  """Fully Fill"""
  FullyFill
  """Partial Fill"""
  PartialFill
  """Expired"""
  Expired
  """Failed Blocking"""
  FailedBlocking
  """Ioc No Fill"""
  IocNoFill
  """Ioc Expire"""
  IocExpire
}

enum BinanceOrdersUniq {
  """Unique Transactions"""
  txs
  """Unique order owners"""
  owners
  """Unique base currencies"""
  base_currencies
  """Unique quote currencies"""
  quote_currencies
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique order ID count"""
  orders
}

enum BinanceOrderTimeInForce {
  """Good Till Expiry"""
  GTE
  """Immediate Or Cancel"""
  IOC
}

enum BinanceOrderType {
  """Limit Order"""
  LimitOrder
}

input BinanceTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: [BinanceAddressSelector!]
  seller: [BinanceAddressSelector!]
  sellOrderId: [OrderIdSelector!]
  buyOrderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  baseCurrency: [BinanceCurrencySelector!]
  quoteCurrency: [BinanceCurrencySelector!]
  quoteAmount: [AmountSelector!]
  baseAmount: [AmountSelector!]
  price: [AmountSelector!]
}

"""Binance DEX Trades"""
type BinanceTrades {
  any(of: BinanceTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  baseCurrency(baseCurrency: [BinanceCurrencySelector!]): Currency
  """Block where trade transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Buy Order ID"""
  buyOrderId(buyOrderId: [OrderIdSelector!]): String
  """Trade buyer address"""
  buyer(buyer: [BinanceAddressSelector!]): Address
  count(uniq: BinanceTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Int
  countBigInt(uniq: BinanceTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  minimum(of: BinanceTradesMeasureable!, get: BinanceTradesMeasureable): String
  price: Float
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: [BinanceAddressSelector!], seller: [BinanceAddressSelector!], sellOrderId: [OrderIdSelector!], buyOrderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], baseCurrency: [BinanceCurrencySelector!], quoteCurrency: [BinanceCurrencySelector!], quoteAmount: [AmountSelector!], baseAmount: [AmountSelector!], price: [AmountSelector!]): Float
  quoteCurrency(quoteCurrency: [BinanceCurrencySelector!]): Currency
  """Sell Order ID"""
  sellOrderId(sellOrderId: [OrderIdSelector!]): String
  """Trade seller address"""
  seller(seller: [BinanceAddressSelector!]): Address
  """Trade ID"""
  tradeId(tradeId: [TradeIdSelector!]): String
  """Transaction where trade happened"""
  transaction(txHash: [HashSelector!]): TransactionHashIndex
}

enum BinanceTradesMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Buyer"""
  buyer
  """Seller"""
  seller
  """Trade ID"""
  trade_id
  """Buy Order ID"""
  buy_order_id
  """Sell Order ID"""
  sell_order_id
  """Base currency"""
  base_currency
  """Quote currency"""
  quote_currency
  """Quote Amount"""
  quote_amount
  """Base Amount"""
  base_amount
  """Price"""
  price
}

enum BinanceTradesUniq {
  """Trades"""
  trades
  """Sell Orders"""
  sell_orders
  """Buy Orders"""
  buy_orders
  """Unique Transactions"""
  txs
  """Unique buyers count"""
  buyers
  """Unique sellers count"""
  sellers
  """Unique base currencies"""
  base_currencies
  """Unique quote currencies"""
  quote_currencies
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
}

input BinanceTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  transactionType: BinanceTransactionTypeSelector
  proposalId: StringIdSelector
  currency: [BinanceCurrencySelector!]
  transactionCode: IntIdSelector
  transactionSource: IntIdSelector
  deposit: [AmountSelector!]
}

"""Transaction"""
type BinanceTransactions {
  any(of: BinanceTransactionsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: BinanceTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!]): Int
  countBigInt(uniq: BinanceTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, transactionType: BinanceTransactionTypeSelector, proposalId: StringIdSelector, currency: [BinanceCurrencySelector!], transactionCode: IntIdSelector, transactionSource: IntIdSelector, deposit: [AmountSelector!]): BigInt
  """Currency issued in transaction"""
  currency(currency: [BinanceCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  """Deposit amount in transaction"""
  deposit(deposit: [AmountSelector!]): Float
  """Transaction Description"""
  description: String
  expression(get: String!): DecimalNumber
  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!
  """TX index in block, 0 based"""
  index: Int
  """Transaction Log"""
  log: String
  maximum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String
  """Transaction Memo"""
  memo: String
  minimum(of: BinanceTransactionsMeasureable!, get: BinanceTransactionsMeasureable): String
  """Proposal ID"""
  proposalId(proposalId: [IntIdSelector!]): Int
  """Transaction Type"""
  transactionCode(transactionCode: IntIdSelector): Int
  """Transaction Source"""
  transactionSource(transactionSource: IntIdSelector): TransactionSource
  """Transaction Type"""
  transactionType(transactionType: [BinanceTransactionTypeSelector!]): BinanceTransactionType
}

enum BinanceTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction Source Name"""
  transaction_source_name
  """Transaction Source Code"""
  transaction_source_code
  """Transaction Code"""
  transaction_code
  """Transaction Type"""
  transaction_type
  """Transaction Memo"""
  transaction_memo
  """Currency"""
  currency_symbol
}

enum BinanceTransactionsUniq {
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique transaction source count"""
  transaction_sources
}

enum BinanceTransactionType {
  """New Order"""
  NEW_ORDER
  """Cancel Order"""
  CANCEL_ORDER
  """Transfer"""
  TRANSFER
  """Vote"""
  VOTE
  """Unfreeze Token"""
  UNFREEZE_TOKEN
  """Burn"""
  BURN
  """Freeze Token"""
  FREEZE_TOKEN
  """Submit Proposal"""
  SUBMIT_PROPOSAL
  """Listing"""
  LISTING
  """Issue"""
  ISSUE
  """Deposit"""
  DEPOSIT
  """Mint"""
  MINT
  """Time Lock"""
  TimeLock
  """Time Unlock"""
  TimeUnlock
  """Time Relock"""
  TimeRelock
  """Set Account Flag"""
  SetAccountFlag
  """Hash Timer Locked Transfer"""
  HTL_TRANSFER
  """Hash Timer Locked Deposit"""
  DEPOSIT_HTL
  """Hash Timer Locked Claim"""
  CLAIM_HTL
  """Hash Timer Locked  Refund"""
  REFUND_HTL
  """Tiny Token Issue"""
  TINY_TOKEN_ISSUE
  """Mini Token Issue"""
  MINI_TOKEN_ISSUE
  """Tiny Token Listing"""
  TINY_TOKEN_LIST
  """Mini Token Listing"""
  MINI_TOKEN_LIST
  """Tiny Token Set URI"""
  TINY_TOKEN_SET_URI
  """Mini Token Set URI"""
  MINI_TOKEN_SET_URI
  """Create sidechain validator"""
  CREATE_SIDECHAIN_VALIDATOR
  """Edit sidechain validator"""
  EDIT_SIDECHAIN_VALIDATOR
  """Delegate for sidechain"""
  SIDECHAIN_DELEGATE
  """ReDelegate for sidechain"""
  SIDECHAIN_REDELEGATE
  """Unbond from sidechain"""
  SIDECHAIN_UNBOND
  """Unjail from sidechain"""
  SIDECHAIN_UNJAIL
  """Side chain submit poroposal"""
  SIDE_SUBMIT_PROPOSAL
  """Side chain deposit"""
  SIDE_DEPOSIT
  """Side chain vote"""
  SIDE_VOTE
  """Cross chain transfer"""
  TRANSFER_OUT
  """Submit evidence"""
  BSC_SUBMIT_EVIDENCE
  """Cross chain claim"""
  CLAIM
  """Bind"""
  BIND
  """UnBind"""
  UNBIND
}

"""Select by transaction type"""
input BinanceTransactionTypeSelector {
  """Transaction Type is"""
  is: BinanceTransactionType
  """Transaction Type not"""
  not: BinanceTransactionType
  """Transaction Type in the list"""
  in: [BinanceTransactionType!]
  """Transaction Type not in the list"""
  notIn: [BinanceTransactionType!]
}

input BinanceTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  sender: [BinanceAddressSelector!]
  receiver: [BinanceAddressSelector!]
  currency: [BinanceCurrencySelector!]
  transferType: [BinanceTransferTypeSelector!]
  orderId: [OrderIdSelector!]
  tradeId: [TradeIdSelector!]
  amount: [AmountSelector!]
  outputIndex: [OutputIndexSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type BinanceTransfers {
  """Transfer amount"""
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Float
  any(of: BinanceTransfersMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Transfer count"""
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): Int
  """Transfer count"""
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, sender: [BinanceAddressSelector!], receiver: [BinanceAddressSelector!], currency: [BinanceCurrencySelector!], transferType: [BinanceTransferTypeSelector!], orderId: [OrderIdSelector!], tradeId: [TradeIdSelector!], amount: [AmountSelector!], outputIndex: [OutputIndexSelector!]): BigInt
  """Currency of transfer"""
  currency(currency: [BinanceCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String
  minimum(of: BinanceTransfersMeasureable!, get: BinanceTransfersMeasureable): String
  """Order Id of trade where transfer happened"""
  orderId(orderId: [OrderIdSelector!]): String
  """Index of the output for the transfer, 0-based"""
  outputIndex(outputIndex: [OutputIndexSelector!]): Int
  """Transfer receiver"""
  receiver(receiver: [BinanceAddressSelector!]): Address
  """Transfer sender"""
  sender(sender: [BinanceAddressSelector!]): Address
  """Id of trade where transfer happened"""
  tradeId(tradeId: [TradeIdSelector!]): String
  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!]): TransactionHashIndex
  """Transfer type"""
  transferType(transferType: [BinanceTransferTypeSelector!]): BinanceTransferType
}

enum BinanceTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency symbol"""
  currency_symbol
}

enum BinanceTransferType {
  """Reward for block"""
  BLOCK_REWARD
  """Burning amount"""
  BURN
  """Claiming Hash Timer Locked Transfer"""
  CLAIM_HTL
  """Deposit for Hash Timer Locked Transfer"""
  DEPOSIT_HTL
  """Fee for DEX orders"""
  DEX_FEE
  """Genesis declaration"""
  GENESIS_DELEGATION
  """Genesis supply declaration"""
  GENESIS_SUPPLY
  """Tiny Token Issue"""
  TINY_TOKEN_ISSUE
  """Mini Token Issue"""
  MINI_TOKEN_ISSUE
  """Hash Timer Locked Transfer"""
  HTL_TRANSFER
  """Issue token"""
  ISSUE
  """Mint token"""
  MINT
  """Trade buy side"""
  TRADE_BUY
  """Trade sell side"""
  TRADE_SELL
  """Transfer"""
  TRANSFER
  """Transaction fee"""
  TX_FEE
  """Create sidechain validator"""
  CREATE_SIDECHAIN_VALIDATOR
  """Edit sidechain validator"""
  EDIT_SIDECHAIN_VALIDATOR
  """Delegate for sidechain"""
  SIDECHAIN_DELEGATE
  """ReDelegate for sidechain"""
  SIDECHAIN_REDELEGATE
  """Unbond from sidechain"""
  SIDECHAIN_UNBOND
  """Side chain submit poroposal"""
  SIDE_SUBMIT_PROPOSAL
  """Side chain deposit"""
  SIDE_DEPOSIT
  """Side chain vote"""
  SIDE_VOTE
  """Cross chain transfer"""
  TRANSFER_OUT
  """Submit evidence"""
  BSC_SUBMIT_EVIDENCE
  """Cross chain claim"""
  CLAIM
  """Bind"""
  BIND
  """UnBind"""
  UNBIND
}

"""Select transfer type(s)"""
input BinanceTransferTypeSelector {
  """Transfer type is"""
  is: BinanceTransferType
  """Transfer type not"""
  not: BinanceTransferType
  """Transfer type in the list"""
  in: [BinanceTransferType!]
  """Transfer type not in the list"""
  notIn: [BinanceTransferType!]
}

"""Bitcoin and other UTXO type blockchains"""
type Bitcoin {
  """Blockchain Address Statistics"""
  addressStats(address: AddressSelector!, options: QueryOptions): [BitcoinAddressStats!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, transactionCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector, any: [BitcoinBlockFilter!], options: QueryOptions): [BitcoinBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: BitcoinCoinpathOptions): [BitcoinCoinpath!]
  """Blockchain Transaction Inputs"""
  inputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: StringSelector, inputValue: FloatSelector, any: [BitcoinInputFilter!], options: QueryOptions): [BitcoinTransactionInput!]
  """Blockchain Transaction OmniTransactions"""
  omniTransactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector, any: [BitcoinOmniTransactionsFilter!], options: QueryOptions): [BitcoinOmniTransactiosn!]
  """Blockchain Transaction OmniTransfers"""
  omniTransfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector, any: [BitcoinOmniTransfersFilter!], options: QueryOptions): [BitcoinOmniTransfers!]
  """Blockchain Transaction Outputs"""
  outputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: StringSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector, any: [BitcoinOutputFilter!], options: QueryOptions): [BitcoinTransactionOutput!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn, any: [BitcoinTransactionFilter!], options: QueryOptions): [BitcoinTransaction!]
}

"""AddressStat"""
type BitcoinAddressStats {
  """Address With Statistics"""
  address: AddressStatDimension
}

"""Block"""
type BitcoinBlock {
  any(of: BitcoinBlocksMeasureable!): String
  """Block Hash"""
  blockHash(blockHash: StringIdSelector): String
  """Block size"""
  blockSize(blockSize: IntegerSelector): Int
  """Block size"""
  blockSizeBigInt: BigInt
  """Block stripped size"""
  blockStrippedSize(blockStrippedSize: IntegerSelector): Int
  """Block version"""
  blockVersion(blockVersion: IntegerSelector): Int
  """Block weight"""
  blockWeight(blockWeight: IntegerSelector): Int
  """Block chainwork"""
  chainwork: String
  count(uniq: BitcoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): Int
  countBigInt(uniq: BitcoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  """Difficulty"""
  difficulty(difficulty: FloatSelector): Float
  expression(get: String!): DecimalNumber
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String
  """Block median timestamp"""
  medianTime: DateTime
  minimum(of: BitcoinBlocksMeasureable!, get: BitcoinBlocksMeasureable): String
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Transaction count in block"""
  transactionCount(transactionCount: IntegerSelector): Int
}

input BitcoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockWeight: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  blockStrippedSize: IntegerSelector
  difficulty: FloatSelector
}

enum BitcoinBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Tx Count"""
  transaction_count
}

enum BitcoinBlockUniq {
  """Unique date count"""
  dates
}

"""Coinpath"""
type BitcoinCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: BitcoinCoinpathAddress
  """Sender address"""
  sender: BitcoinCoinpathAddress
  """Transaction of transfer happened"""
  transaction: BitcoinTransactionHashIndexValues
  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""Address detailed information for Bitcoin network"""
type BitcoinCoinpathAddress {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Smart Contract if exists on the address"""
  firstTxAt: DateTime
  """Smart Contract if exists on the address"""
  lastTxAt: DateTime
  """"""
  receiversCount: Int
  """"""
  sendersCount: Int
  """Address type"""
  type: String
}

enum BitcoinCoinpathMethod {
  """Tracking money flow by amounts, ignoring coins (default)"""
  moneyflow
  """Tracking coins by UTXO transactions"""
  utxo
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input BitcoinCoinpathOptions {
  """Limit number of results"""
  limit: Int
  """Limit number of results by specific field"""
  limitBy: LimitByOption
  """Offset of results, starting from 0"""
  offset: Int
  """Ordering field(s) for ascending"""
  asc: [String!]
  """Ordering field(s) for descending"""
  desc: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for descending"""
  descByInteger: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for ascending"""
  ascByInteger: [String!]
  """Flow direction"""
  direction: FlowDirection
  """Do not include transactions below this amount"""
  minimumTxAmount: Float
  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int
  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int
  """Raise error if complexity ( currently measured in transaction count ) is higher than this option"""
  complexityLimit: Int
  """Invalidating cache seed"""
  seed: Int
  """Method to use coinpath"""
  coinpathMethod: BitcoinCoinpathMethod
}

input BitcoinInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputScriptType: StringSelector
  inputValue: FloatSelector
}

enum BitcoinInputsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction index"""
  tx_index
  """Amount"""
  amount
  """Address"""
  address
  """Input index"""
  input_index
}

enum BitcoinInputUniq {
  """Unique transactions count"""
  transactions
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
  """Unique addresses count"""
  addresses
}

enum BitcoinNetwork {
  """Bitcoin ( BTC )"""
  bitcoin
  """Bitcoin Cash ( BCH )"""
  bitcash
  """Bitcoin SV ( BSV )"""
  bitcoinsv
  """Litecoin ( LTC )"""
  litecoin
  """Dash ( DASH )"""
  dash
  """Dogecoin ( DOGE )"""
  dogecoin
  """ZCash ( ZCASH )"""
  zcash
}

input BitcoinOmniTransactionsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransactionsMeasureablse {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transactions hash"""
  tx_hash
  """Transactions index"""
  tx_index
  """Fee Value"""
  fee_value
}

enum BitcoinOmniTransactionsUniq {
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
  """Unique transaction sender"""
  tx_sender
}

"""OmniTransactions"""
type BitcoinOmniTransactiosn {
  any(of: BitcoinOmniTransactionsMeasureablse!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Hash of the block"""
  blockHash(blockHash: HashSelector): String!
  """OmniTransaction s count"""
  count(uniq: BitcoinOmniTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Int
  """OmniTransaction s count"""
  countBigInt(uniq: BitcoinOmniTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Transactions total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Float
  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!
  """OmniTransactions index in block, 0-based"""
  index(txIndex: IntegerSelector): String!
  """Invalid Reason"""
  invalidReason(invalidReason: StringSelector): String!
  """Invalid Reason"""
  json(json: StringSelector): String!
  maximum(of: BitcoinOmniTransactionsMeasureablse!, get: BitcoinOmniTransactionsMeasureablse): String
  minimum(of: BitcoinOmniTransactionsMeasureablse!, get: BitcoinOmniTransactionsMeasureablse): String
  """Transaction Sender"""
  txSender(txSender: HashSelector): String!
  """Type"""
  type(type: StringSelector): String!
  """Type Int"""
  typeInt(typeInt: IntegerSelector): Int!
  """Version"""
  valid(valid: IntegerSelector): Int!
  """Version"""
  version(version: IntegerSelector): Int!
}

"""OmniTransfers"""
type BitcoinOmniTransfers {
  any(of: BitcoinOmniTransfersMeasureablse!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Hash of the block"""
  blockHash(blockHash: HashSelector): String!
  """Transaction s count"""
  count(uniq: BitcoinOmniTransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Int
  """Transaction s count"""
  countBigInt(uniq: BitcoinOmniTransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): BigInt
  """Currency of transfer"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Direction"""
  direction(direction: StringSelector): String
  """Divisible"""
  divisible(divisible: IntegerSelector): Int
  expression(get: String!): DecimalNumber
  """Transactions total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, version: IntegerSelector, valid: IntegerSelector, invalidReason: StringSelector, type: StringSelector, typeId: IntegerSelector, txSender: HashSelector, feeValue: FloatSelector): Float
  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!
  """Transactions index in block, 0-based"""
  index(txIndex: IntegerSelector): String!
  """Ismine"""
  ismine(ismine: IntegerSelector): Int
  maximum(of: BitcoinOmniTransfersMeasureablse!, get: BitcoinOmniTransfersMeasureablse): String
  minimum(of: BitcoinOmniTransfersMeasureablse!, get: BitcoinOmniTransfersMeasureablse): String
  """Transfer From"""
  transferFrom(transferFrom: HashSelector): String!
  """Transfer From"""
  transferTo(transferTo: HashSelector): String!
  """Transaction Sender"""
  txSender(txSender: HashSelector): String!
  """Type"""
  type(type: StringSelector): String!
  """Type Int"""
  typeInt(typeInt: IntegerSelector): Int!
  """value"""
  value(value: FloatSelector): Float
}

input BitcoinOmniTransfersFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  version: IntegerSelector
  valid: IntegerSelector
  invalidReason: StringSelector
  type: StringSelector
  typeId: IntegerSelector
  txSender: HashSelector
  feeValue: FloatSelector
}

enum BitcoinOmniTransfersMeasureablse {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transactions hash"""
  tx_hash
  """Transactions index"""
  tx_index
  """Fee Value"""
  fee_value
}

enum BitcoinOmniTransfersUniq {
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
  """Unique transaction sender"""
  tx_sender
}

enum BitcoinOutputDirection {
  """Not defined"""
  unknown
  """Not a change return"""
  not_change
  """Change return"""
  change
  """Likely Not a change return"""
  likely_not_change
  """Likely Change return"""
  likely_change
  """Mining"""
  mining
  """Fee"""
  fee
  """Minting"""
  minting
  """Genesis"""
  genesis
}

"""A guessed direction of output"""
input BitcoinOutputDirectionSelector {
  """Equal to direction"""
  is: BitcoinOutputDirection
  """Not Equal to direction"""
  not: BitcoinOutputDirection
  """In the list of direction"""
  in: [BitcoinOutputDirection!]
  """Not in the list of direction"""
  notIn: [BitcoinOutputDirection!]
}

input BitcoinOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputScriptType: StringSelector
  outputDirection: BitcoinOutputDirectionSelector
  outputValue: FloatSelector
}

enum BitcoinOutputsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction index"""
  tx_index
  """Amount"""
  amount
  """Address"""
  address
  """Output index"""
  output_index
}

enum BitcoinOutputUniq {
  """Unique transactions count"""
  transactions
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
  """Unique input addresses count"""
  addresses
}

"""Transaction"""
type BitcoinTransaction {
  any(of: BitcoinTransactionsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Transaction  count"""
  count(uniq: BitcoinTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction  count"""
  countBigInt(uniq: BitcoinTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Transaction total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total fee value"""
  feeValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber
  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!
  """Transaction index in block, 0-based"""
  index(txIndex: IntegerSelector): String!
  """Transaction total input count"""
  inputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction total input count"""
  inputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Transaction total input value"""
  inputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total input value as decimal"""
  inputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber
  maximum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String
  """Transaction total mined value"""
  minedValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total mined value"""
  minedValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber
  minimum(of: BitcoinTransactionsMeasureable!, get: BitcoinTransactionsMeasureable): String
  """Transaction total output count"""
  outputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction total output count"""
  outputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Transaction total output value"""
  outputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total output value"""
  outputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, txVsize: IntegerSelector, txWeight: IntegerSelector, txVersion: IntegerSelector, txCoinbase: Boolean, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, minedValue: FloatSelector, txLocktime: IntegerSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumber
  """Transaction is coinbase"""
  txCoinbase(txCoinbase: Boolean): Boolean
  """Transaction locktime"""
  txLocktime(txLocktime: IntegerSelector): BigInt
  """Transaction size"""
  txSize(txSize: IntegerSelector): Int
  """Transaction version"""
  txVersion(txVersion: IntegerSelector): Int
  """Transaction vsize"""
  txVsize(txVsize: IntegerSelector): Int
  """Transaction weight"""
  txWeight(txWeight: IntegerSelector): Int
}

input BitcoinTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  txVsize: IntegerSelector
  txWeight: IntegerSelector
  txVersion: IntegerSelector
  txCoinbase: Boolean
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  minedValue: FloatSelector
  txLocktime: IntegerSelector
  outputAddress: AddressSelectorIn
  inputAddress: AddressSelectorIn
}

"""Blockchain transaction"""
type BitcoinTransactionHashIndexValues {
  """Hash hex representation"""
  hash: String!
  """Transaction index in block, 0-based"""
  index: String!
  """Transaction value in input"""
  valueIn: Float!
  """Transaction value in input"""
  valueInDecimal: DecimalNumber!
  """Transaction value in output"""
  valueOut: Float!
  """Transaction value in output"""
  valueOutDecimal: DecimalNumber!
}

"""Transaction Input"""
type BitcoinTransactionInput {
  any(of: BitcoinInputsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Input count"""
  count(uniq: BitcoinInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: StringSelector, inputValue: FloatSelector): Int
  """Input count"""
  countBigInt(uniq: BitcoinInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: StringSelector, inputValue: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Input address"""
  inputAddress(inputAddress: AddressSelector): Address
  """Input index"""
  inputIndex(inputIndex: IntegerSelector): Int
  """Input script"""
  inputScript: String
  """Input script type and attributes"""
  inputScriptType(inputScriptType: StringSelector): InputScript
  maximum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String
  minimum(of: BitcoinInputsMeasureable!, get: BitcoinInputsMeasureable): String
  """Output Transaction for this input"""
  outputTransaction(inOutputTxId: StringIdSelector, inOutputIndex: IntegerSelector): TransactionHashIndex
  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
  """Input value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: StringSelector, inputValue: FloatSelector): Float
  """Input value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: StringSelector, inputValue: FloatSelector): DecimalNumber
}

"""Transaction Output"""
type BitcoinTransactionOutput {
  any(of: BitcoinOutputsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Output count"""
  count(uniq: BitcoinOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: StringSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Int
  """Output count"""
  countBigInt(uniq: BitcoinOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: StringSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String
  minimum(of: BitcoinOutputsMeasureable!, get: BitcoinOutputsMeasureable): String
  """Output address"""
  outputAddress(outputAddress: AddressSelector): Address
  """Output guessed direction"""
  outputDirection(outputDirection: BitcoinOutputDirectionSelector): BitcoinOutputDirection
  """Output index"""
  outputIndex(outputIndex: IntegerSelector): Int
  """Output script"""
  outputScript: String
  """Output script type and attributes"""
  outputScriptType(inputScriptType: StringSelector): OutputScript
  reqSigs: Int
  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
  """Output value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputScriptType: StringSelector, outputDirection: BitcoinOutputDirectionSelector, outputValue: FloatSelector): Float
  """Output value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputScriptType: StringSelector, inputValue: FloatSelector): DecimalNumber
}

enum BitcoinTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction index"""
  tx_index
  """Input count"""
  input_count
  """Output count"""
  output_count
  """Transaction size"""
  tx_size
  """Transaction input value"""
  input_value
  """Transaction output value"""
  output_value
  """Fee Value"""
  fee_value
}

enum BitcoinTransactionUniq {
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
}

"""Block"""
type Block {
  """Block number (height) in blockchain"""
  height: Int!
  """Block timestamp"""
  timestamp: DateTime
}

"""Blockchain network"""
type BlockchainNetwork {
  """Network name"""
  network: Network!
  """Network protocol type"""
  protocol: Protocol!
}

"""BlockExtended"""
type BlockExtended {
  """Hash hex representation"""
  hash: String!
  """Block number (height) in blockchain"""
  height: Int!
  """Block timestamp"""
  timestamp: DateTime
}

"""ConfluxBlock"""
type BlockInfo {
  """Block hash"""
  hash: String
  """Block number (height) in blockchain"""
  height: Int!
  """Block timestamp"""
  timestamp: DateTime
}

"""Select block by height ( sequence number)"""
input BlockSelector {
  """Block height is"""
  is: Int
  """Block height not"""
  not: Int
  """Block height in the list"""
  in: [Int!]
  """Block height not in the list"""
  notIn: [Int!]
  """Block height greater than"""
  gt: Int
  """Block height less than"""
  lt: Int
  """Block height less or equal than"""
  lteq: Int
  """Block height greater or equal than"""
  gteq: Int
  """Block height in range"""
  between: [Int!]
}

"""Select block by height ( sequence number)"""
input BlockSelectorRange {
  """Block height eq"""
  is: Int
  """Block height less than"""
  lt: Int
  """Block height less or equal than"""
  lteq: Int
  """Block height greater than"""
  gt: Int
  """Block height greater or equal than"""
  gteq: Int
  """Block height in range"""
  between: [Int!]
}

"""Select by boolean (sequence number)"""
input BooleanSelector {
  """Is"""
  is: Boolean
  """Is not"""
  not: Boolean
}

"""Cardano"""
type Cardano {
  """Information about address"""
  address(address: [AddressSelectorIn!]!): [CardanoAddressInfo!]!
  """Blockchain Address Statistics"""
  addressStats(address: AddressSelector!, options: QueryOptions): [CardanoAddressStats!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockVersion: IntegerSelector, transactionCount: IntegerSelector, epoch: IntegerSelector, slot: IntegerSelector, slotInEpoch: IntegerSelector, opCert: StringSelector, slotLeaderHash: StringSelector, vrfKey: StringSelector, version: StringSelector, any: [CardanoBlockFilter!], options: QueryOptions): [CardanoBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, currency: [CardanoCurrencySelector!], options: CardanoCoinpathOptions): [CardanoCoinpath!]
  """Blockchain Transaction Inputs"""
  inputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!], inputSource: CardanoInputSourcenSelector, any: [CardanoInputFilter!], options: QueryOptions): [CardanoTransactionInput!]
  """Blockchain Tokens Mints"""
  mints(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!], any: [CardanoMintFilter!], options: QueryOptions): [CardanoTransactionMint!]
  """Blockchain Transaction Outputs"""
  outputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!], any: [CardanoOutputFilter!], options: QueryOptions): [CardanoTransactionOutput!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn, any: [CardanoTransactionFilter!], options: QueryOptions): [CardanoTransaction!]
}

"""Address balance information for Cardano network"""
type CardanoAddressBalance {
  """Currency"""
  currency: Currency
  """Currency value"""
  value: Float
}

"""Address detailed information for Cardano network"""
type CardanoAddressInfo {
  """Address"""
  address: Address
  """Current address balances"""
  balance: [CardanoAddressBalance!]
  """Current staking addressese info"""
  staking: [CardanoStakingAddress!]
}

"""AddressStat"""
type CardanoAddressStats {
  """Address With Statistics"""
  address: AddressStatDimension
}

"""Block"""
type CardanoBlock {
  any(of: CardanoBlocksMeasureable!): String
  """Block Hash"""
  blockHash(blockHash: StringIdSelector): String
  """Block size"""
  blockSize(blockSize: IntegerSelector): Int
  """Block version"""
  blockVersion(blockVersion: IntegerSelector): Int
  count(uniq: CardanoBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): Int
  countBigInt(uniq: CardanoBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: StringIdSelector, blockSize: IntegerSelector, blockWeight: IntegerSelector, blockVersion: IntegerSelector, txCount: IntegerSelector, blockStrippedSize: IntegerSelector, difficulty: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  """Epoch number"""
  epoch: Int
  expression(get: String!): DecimalNumber
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: CardanoBlocksMeasureable!, get: CardanoBlocksMeasureable): String
  minimum(of: CardanoBlocksMeasureable!, get: CardanoBlocksMeasureable): String
  """Op cert"""
  opCert: String
  """Slot number"""
  slot: Int
  """Slot in epoch number"""
  slotInEpoch: Int
  """Slot leader description"""
  slotLeaderDescription: String
  """Slot leader hash"""
  slotLeaderHash: String
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Transaction count in block"""
  transactionCount(transactionCount: IntegerSelector): Int
  """VRF Key"""
  vrfKey: String
}

input CardanoBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: StringIdSelector
  blockSize: IntegerSelector
  blockVersion: IntegerSelector
  transactionCount: IntegerSelector
  epoch: IntegerSelector
  slot: IntegerSelector
  slotInEpoch: IntegerSelector
  opCert: StringSelector
  slotLeaderHash: StringSelector
  vrfKey: StringSelector
  version: StringSelector
}

enum CardanoBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Tx Count"""
  transaction_count
}

enum CardanoBlockUniq {
  """Unique date count"""
  dates
  """Unique epoch"""
  epoch
  """Unique slot"""
  slot
  """Unique slot leader"""
  slot_leader
  """Unique version"""
  version
}

"""Coinpath"""
type CardanoCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: CardanoCoinpathAddress
  """Sender address"""
  sender: CardanoCoinpathAddress
  """Transaction of transfer happened"""
  transaction: CardanoTransactionHashIndexValues
  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""Address detailed information for Cardano network"""
type CardanoCoinpathAddress {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Smart Contract if exists on the address"""
  firstTxAt: DateTime
  """Smart Contract if exists on the address"""
  lastTxAt: DateTime
  """"""
  receiversCount: Int
  """"""
  sendersCount: Int
  """Address type"""
  type: String
}

enum CardanoCoinpathMethod {
  """Tracking money flow by amounts, ignoring coins (default)"""
  moneyflow
  """Tracking coins by UTXO transactions"""
  utxo
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input CardanoCoinpathOptions {
  """Limit number of results"""
  limit: Int
  """Limit number of results by specific field"""
  limitBy: LimitByOption
  """Offset of results, starting from 0"""
  offset: Int
  """Ordering field(s) for ascending"""
  asc: [String!]
  """Ordering field(s) for descending"""
  desc: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for descending"""
  descByInteger: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for ascending"""
  ascByInteger: [String!]
  """Flow direction"""
  direction: FlowDirection
  """Do not include transactions below this amount"""
  minimumTxAmount: Float
  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int
  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int
  """Raise error if complexity ( currently measured in transaction count ) is higher than this option"""
  complexityLimit: Int
  """Invalidating cache seed"""
  seed: Int
  """Method to use coinpath"""
  coinpathMethod: CardanoCoinpathMethod
  """Option to get info for staking addresses"""
  stakingAddress: Boolean
}

"""
Cardano token selector by tokenId.
    Native binance token has ADA symbol, pass it as argument.
    Otherwise pass asset fingerprint, starting from asset...
"""
input CardanoCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

input CardanoInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  inputIndex: IntegerSelector
  inputAddress: AddressSelector
  inOutputTxId: HashSelector
  inOutputIndex: IntegerSelector
  inputValue: FloatSelector
  currency: [CardanoCurrencySelector!]
  inputSource: CardanoInputSourcenSelector
}

enum CardanoInputsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction index"""
  tx_index
  """Amount"""
  amount
  """Address"""
  address
  """Input index"""
  input_index
  """Input source"""
  source
}

enum CardanoInputSource {
  """Input"""
  input
  """Withdrawal"""
  withdrawal
  """Stake Deregistration"""
  stake_deregistration
}

"""A source input"""
input CardanoInputSourcenSelector {
  """Equal to source"""
  is: CardanoInputSource
  """Not Equal to source"""
  not: CardanoInputSource
  """In the list of source"""
  in: [CardanoInputSource!]
  """Not in the list of source"""
  notIn: [CardanoInputSource!]
}

enum CardanoInputUniq {
  """Unique transactions count"""
  transactions
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
  """Unique addresses count"""
  addresses
  """Unique currencies count"""
  currencies
  """Unique source count"""
  sources
}

input CardanoMintFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  value: FloatSelector
  currency: [CardanoCurrencySelector!]
}

enum CardanoMintsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction index"""
  tx_index
  """Amount"""
  amount
}

enum CardanoMintUniq {
  """Unique transactions count"""
  transactions
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
  """Unique currencies count"""
  currencies
}

enum CardanoNetwork {
  """Cardano ( ADA )"""
  cardano
}

enum CardanoOutputDirection {
  """Not defined"""
  unknown
  """Not a change return"""
  not_change
  """Change return"""
  change
  """Genesis"""
  genesis
  """Stake Registration"""
  stake_registration
  """Stake Registration"""
  deposit
}

"""A guessed direction of output"""
input CardanoOutputDirectionSelector {
  """Equal to direction"""
  is: CardanoOutputDirection
  """Not Equal to direction"""
  not: CardanoOutputDirection
  """In the list of direction"""
  in: [CardanoOutputDirection!]
  """Not in the list of direction"""
  notIn: [CardanoOutputDirection!]
}

input CardanoOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  outputIndex: IntegerSelector
  outputAddress: AddressSelector
  outputDirection: CardanoOutputDirectionSelector
  outputValue: FloatSelector
  currency: [CardanoCurrencySelector!]
}

enum CardanoOutputsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction index"""
  tx_index
  """Amount"""
  amount
  """Address"""
  address
  """Output index"""
  output_index
  """Output direction"""
  direction
}

enum CardanoOutputUniq {
  """Unique transactions count"""
  transactions
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
  """Unique input addresses count"""
  addresses
  """Unique currencies count"""
  currencies
  """Unique direction count"""
  directions
}

"""Address staking information for Cardano network"""
type CardanoStakingAddress {
  """Staking Address"""
  address: Address
  """Controlled total stake"""
  controlledTotalStake: Float
  """Rewards value"""
  rewardsAmount: Float
  """Rewards available"""
  rewardsAvailable: Float
  """Staked value"""
  stakedAmount: Float
  """Staked value including rewards"""
  stakedAmountWithRewards: Float
  """Withdrawn value"""
  withdrawnAmount: Float
}

"""Transaction"""
type CardanoTransaction {
  any(of: CardanoTransactionsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Transaction  count"""
  count(uniq: CardanoTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction  count"""
  countBigInt(uniq: CardanoTransactionUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Calendar date"""
  date: Date
  """Transaction total deposit value"""
  depositValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total fee value"""
  depositValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv
  expression(get: String!): DecimalNumber
  """Transaction total fee value"""
  feeValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total fee value"""
  feeValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv
  """Hash hex representation"""
  hash(txHash: StringIdSelector): String!
  """Included at timestamp"""
  includedAt: DateTime
  """Transaction index in block, 0-based"""
  index(txIndex: IntegerSelector): String!
  """Transaction total input count"""
  inputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction total input count"""
  inputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Transaction total input value"""
  inputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total input value as decimal"""
  inputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv
  """Invalid before"""
  invalidBefore: String
  """Invalid hereafter"""
  invalidHereafter: String
  maximum(of: CardanoTransactionsMeasureable!, get: CardanoTransactionsMeasureable): String
  """Metadata"""
  metadata: String
  minimum(of: CardanoTransactionsMeasureable!, get: CardanoTransactionsMeasureable): String
  """Transaction total mint count"""
  mintCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction total mint count"""
  mintCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Transaction total output count"""
  outputCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction total output count"""
  outputCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Transaction total output value"""
  outputValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total output value"""
  outputValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv
  """Transaction size"""
  txSize(txSize: IntegerSelector): Int
  """Transaction total withdrawal count"""
  withdrawalCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Int
  """Transaction total withdrawal count"""
  withdrawalCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): BigInt
  """Transaction total withdrawal value"""
  withdrawalValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): Float
  """Transaction total fee value"""
  withdrawalValueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, txSize: IntegerSelector, inputCount: IntegerSelector, outputCount: IntegerSelector, inputValue: FloatSelector, outputValue: FloatSelector, feeValue: FloatSelector, withdrawalCount: IntegerSelector, mintCount: IntegerSelector, withdrawalValue: FloatSelector, depositValue: FloatSelector, outputAddress: AddressSelectorIn, inputAddress: AddressSelectorIn): DecimalNumberAsDiv
}

input CardanoTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txSize: IntegerSelector
  inputCount: IntegerSelector
  outputCount: IntegerSelector
  inputValue: FloatSelector
  outputValue: FloatSelector
  feeValue: FloatSelector
  withdrawalCount: IntegerSelector
  mintCount: IntegerSelector
  withdrawalValue: FloatSelector
  depositValue: FloatSelector
  outputAddress: AddressSelectorIn
  inputAddress: AddressSelectorIn
}

"""Blockchain transaction"""
type CardanoTransactionHashIndexValues {
  depositValue: Float!
  """Transaction deposit value as decimal"""
  depositValueDecimal: DecimalNumberAsDiv!
  feeValue: Float!
  """Transaction fee value as decimal"""
  feeValueDecimal: DecimalNumberAsDiv!
  """Hash hex representation"""
  hash: String!
  includedAt: DateTime!
  """Transaction index in block, 0-based"""
  index: String!
  invalidBefore: String!
  invalidHereafter: String!
  metadata: String!
  txSize: Int!
  """Transaction value in input"""
  valueIn: Float!
  """Transaction value in input as decimal"""
  valueInDecimal: DecimalNumberAsDiv!
  """Transaction value in output"""
  valueOut: Float!
  """Transaction value in output as decimal"""
  valueOutDecimal: DecimalNumberAsDiv!
  withdrawalValue: Float!
  """Transaction withdraw value as decimal"""
  withdrawalValueDecimal: DecimalNumberAsDiv!
}

"""Transaction Input"""
type CardanoTransactionInput {
  any(of: CardanoInputsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Input count"""
  count(uniq: CardanoInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!], inputSource: CardanoInputSourcenSelector): Int
  """Input count"""
  countBigInt(uniq: CardanoInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!], inputSource: CardanoInputSourcenSelector): BigInt
  """Currency of the input"""
  currency: Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Input address"""
  inputAddress(inputAddress: AddressSelector): Address
  """Input index"""
  inputIndex(inputIndex: IntegerSelector): Int
  maximum(of: CardanoInputsMeasureable!, get: CardanoInputsMeasureable): String
  minimum(of: CardanoInputsMeasureable!, get: CardanoInputsMeasureable): String
  """Output Transaction for this input"""
  outputTransaction(inOutputTxId: StringIdSelector, inOutputIndex: IntegerSelector): TransactionHashIndex
  """Source of the input"""
  source: CardanoInputSource
  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
  """Input value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!], inputSource: CardanoInputSourcenSelector): Float
  """Input value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!], inputSource: CardanoInputSourcenSelector): DecimalNumberAsDiv
}

"""Transaction Mint"""
type CardanoTransactionMint {
  any(of: CardanoMintsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Mint count"""
  count(uniq: CardanoMintUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!]): Int
  """Mint count"""
  countBigInt(uniq: CardanoMintUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!]): BigInt
  """Currency of the mint"""
  currency: Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: CardanoMintsMeasureable!, get: CardanoMintsMeasureable): String
  minimum(of: CardanoMintsMeasureable!, get: CardanoMintsMeasureable): String
  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
  """Mint value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, value: FloatSelector, currency: [CardanoCurrencySelector!]): Float
}

"""Transaction Output"""
type CardanoTransactionOutput {
  any(of: CardanoOutputsMeasureable!): String
  """Block where transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Output count"""
  count(uniq: CardanoOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!]): Int
  """Output count"""
  countBigInt(uniq: CardanoOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!]): BigInt
  """Currency of the output"""
  currency: Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: CardanoOutputsMeasureable!, get: CardanoOutputsMeasureable): String
  minimum(of: CardanoOutputsMeasureable!, get: CardanoOutputsMeasureable): String
  """Output address"""
  outputAddress(outputAddress: AddressSelector): Address
  """Output guessed direction"""
  outputDirection(outputDirection: CardanoOutputDirectionSelector): CardanoOutputDirection
  """Output index"""
  outputIndex(outputIndex: IntegerSelector): Int
  """Transaction ID Hash"""
  transaction(txId: StringIdSelector, txIndex: IntegerSelector): TransactionHashIndex
  """Output value"""
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, outputIndex: IntegerSelector, outputAddress: AddressSelector, outputDirection: CardanoOutputDirectionSelector, outputValue: FloatSelector, currency: [CardanoCurrencySelector!]): Float
  """Input value as decimal"""
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: IntegerSelector, inputIndex: IntegerSelector, inputAddress: AddressSelector, inOutputTxId: HashSelector, inOutputIndex: IntegerSelector, inputValue: FloatSelector, currency: [CardanoCurrencySelector!], inputSource: CardanoInputSourcenSelector): DecimalNumberAsDiv
}

enum CardanoTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction index"""
  tx_index
  """Input count"""
  input_count
  """Output count"""
  output_count
  """Transaction size"""
  tx_size
  """Transaction input value"""
  input_value
  """Transaction output value"""
  output_value
  """Transaction withdrawal value"""
  withdrawal_value
  """Transaction deposit value"""
  deposit_value
  """Transaction withdrawal count"""
  withdrawal_count
  """Transaction mint count"""
  mint_count
}

enum CardanoTransactionUniq {
  """Unique block count"""
  blocks
  """Unique date count"""
  dates
}

"""Transaction attributes in coinpath"""
type CoinpathEntry {
  """Amount involved in the flow"""
  amount: Float!
  """Block of transaction"""
  height: Int!
  """Time of transaction in ISO 8601 format"""
  timestamp: ISO8601DateTime!
  """Hash of transaction"""
  txHash: String!
  """Amount transfered in transaction"""
  txValue: Float!
}

enum CoinpathMeasureable {
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Depth"""
  depth
}

"""Limits, Ordering, Constraints, Coinpath Options"""
input CoinpathOptions {
  """Limit number of results"""
  limit: Int
  """Limit number of results by specific field"""
  limitBy: LimitByOption
  """Offset of results, starting from 0"""
  offset: Int
  """Ordering field(s) for ascending"""
  asc: [String!]
  """Ordering field(s) for descending"""
  desc: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for descending"""
  descByInteger: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for ascending"""
  ascByInteger: [String!]
  """Flow direction"""
  direction: FlowDirection
  """Do not include transactions below this amount"""
  minimumTxAmount: Float
  """Do not expand addresses having count transactions more than this"""
  maximumAddressTxCount: Int
  """Maximum total transaction count returned"""
  maximumTotalTxCount: Int
  """Raise error if complexity ( currently measured in transaction count ) is higher than this option"""
  complexityLimit: Int
  """Invalidating cache seed"""
  seed: Int
}

"""Conflux Chain"""
type Conflux {
  """Ethereum Active Addresses"""
  activeAddresses(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!], options: QueryOptions): [EthereumActiveAddress!]
  """Basic information about address ( or smart contract )"""
  address(address: [ConfluxAddressSelectorIn!]!): [ConfluxAddressInfoWithBalance!]!
  """Blockchain Address Statistics"""
  addressStats(address: EthereumAddressSelector!, options: QueryOptions): [EthereumAddressStats!]
  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], reference: [ConfluxAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector, any: [ConfluxArgumentFilter!], options: QueryOptions): [ConfluxArguments!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [ConfluxBlockFilter!], options: QueryOptions): [ConfluxBlocks!]
  """Money flow using Coinpath technology"""
  coinpath(sender: ConfluxAddressSelector, receiver: ConfluxAddressSelector, currency: [ConfluxCurrencySelector!], initialAddress: ConfluxAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [ConfluxCoinpath!]
  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]
  """References of Smart Contract Calls and Events"""
  references(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector, any: [EthereumReferencesFilter!], options: QueryOptions): [EthereumReferencess!]
  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractType: ConfluxSmartContractTypeSelector, external: Boolean, success: [Boolean!], callDepth: StringSelector, any: [ConfluxSmartContractCallFilter!], options: QueryOptions): [ConfluxSmartContractCalls!]
  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], smartContractType: ConfluxSmartContractTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractEvent: EventSelector, any: [ConfluxSmartContractEventFilter!], options: QueryOptions): [ConfluxSmartContractEvent!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [ConfluxAddressSelector!], txTo: [ConfluxAddressSelector!], txCreates: [ConfluxAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector, any: [ConfluxTransactionFilter!], options: QueryOptions): [ConfluxTransactions!]
  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], entityId: EntitySelector, sender: [ConfluxAddressSelector!], receiver: [ConfluxAddressSelector!], currency: [ConfluxCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!], any: [ConfluxTransferFilter!], options: QueryOptions): [ConfluxTransfers!]
}

"""Address detailed information for Conflux network"""
type ConfluxAddressInfo {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Smart Contract if exists on the address"""
  smartContract: ConfluxSmartContractInfo
}

"""Blockchain address"""
type ConfluxAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """DEPRECATED Current address balance"""
  balance(in: BaseCurrencyEnum): Float
  """DEPRECATED Balances by currencies for the address"""
  balances(date: DateSelector, time: DateTimeSelector, currency: ConfluxCurrencySelector, height: BlockSelectorRange): [ConfluxBalance!]
  """Smart Contract if exists on the address"""
  smartContract: ConfluxSmartContractInfoWithAttributes
}

"""
Address should start from cfx: and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input ConfluxAddressSelector {
  """Equal to Address"""
  is: String
  """Not Equal to Address"""
  not: String
  """In the list of Addresses"""
  in: [String!]
  """Not in the list of Addresses"""
  notIn: [String!]
}

"""
Address should start from cfx: and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input ConfluxAddressSelectorIn {
  """Equal to Address"""
  is: String
  """In the list of Addresses"""
  in: [String!]
}

input ConfluxArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  caller: [ConfluxAddressSelector!]
  reference: [ConfluxAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [ConfluxAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
  callDepth: StringSelector
}

"""Argument name and value of smart contract call or event"""
type ConfluxArgumentNameValue {
  """Argument name"""
  argument: String!
  """Argument data type"""
  argumentType: String!
  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  """Value as String"""
  value: String!
}

"""Arguments of Smart Contract Calls and Events"""
type ConfluxArguments {
  any(of: ConfluxArgumentsMeasureable!, as: ConfluxArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], reference: [ConfluxAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  """Method or event argument"""
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Caller of the method invocation ( tx sender or another smart contract )"""
  caller(caller: [ConfluxAddressSelector!]): ConfluxAddressInfo
  """Counts and other metrics"""
  count(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], reference: [ConfluxAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], reference: [ConfluxAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """External call executed explicitly by tx sender. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  maximum(of: ConfluxArgumentsMeasureable!, get: ConfluxArgumentsMeasureable, as: ConfluxArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], reference: [ConfluxAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  minimum(of: ConfluxArgumentsMeasureable!, get: ConfluxArgumentsMeasureable, as: ConfluxArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], reference: [ConfluxAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  number(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], reference: [ConfluxAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Float
  """Address value of method or event argument"""
  reference(reference: [ConfluxAddressSelector!]): ConfluxAddressInfo
  """Smart contract being called"""
  smartContract(smartContractAddress: [ConfluxAddressSelector!]): ConfluxSmartContract
  """Contract method or event"""
  smartContractSignature(smartContractMethod: MethodSelector, smartContractEvent: EventSelector, signatureType: SignatureTypeSelector): Signature
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [ConfluxAddressSelector!]): ConfluxTransactionInfo
  """The Value of method or event argument"""
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum ConfluxArgumentsConvertable {
  """Token symbol"""
  token_symbol
  """Token name"""
  token_name
}

enum ConfluxArgumentsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Caller"""
  caller
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature"""
  signature_type
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
  """Argument"""
  argument
  """Argument type"""
  argument_type
  """Argument value"""
  argument_value
  """Argument index"""
  argument_index
}

"""Balance in a currency"""
type ConfluxBalance {
  """Currency of transfer"""
  currency: Currency
  """History of balance changes by currencies for the address"""
  history: [ConfluxBalanceChange!]
  value(in: BaseCurrencyEnum): Float
}

"""Change of balance in a currency"""
type ConfluxBalanceChange {
  """Block number (height) in blockchain"""
  block: Int!
  """Block timestamp"""
  timestamp: ISO8601DateTime
  """Transfer amount ( positive inbound, negative outbound)"""
  transferAmount: Float
  value: Float
}

input ConfluxBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  epoch: BlockSelector
  pivot: Boolean
  blockHash: HashSelector
  referenceBlockHash: HashSelector
  miner: [ConfluxAddressSelector!]
  refereeCount: [IntegerSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""Blocks in Conflux blockchain"""
type ConfluxBlocks {
  """Block is adaptive"""
  adaptive: Boolean!
  any(of: ConfluxBlocksMeasureable!): String
  """Blame"""
  blame: Int!
  """Block index in epoch"""
  blockPosition: Int!
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  countBigInt(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Epoch in blockchain"""
  epoch(height: BlockSelector): Int!
  expression(get: String!): DecimalNumber
  """Block hash"""
  hash(blockHash: [HashSelector!]): String!
  """Block height in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String
  """Block miner"""
  miner(miner: [ConfluxAddressSelector!]): EthereumAddressInfo
  minimum(of: ConfluxBlocksMeasureable!, get: ConfluxBlocksMeasureable): String
  """Block nonce"""
  nonce: Int!
  """Parent block hash"""
  parentHash: String!
  """Block is pivot"""
  pivot: Boolean!
  """Power Quality"""
  powerQuality: BigInt!
  refereeCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  refereeCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
  """Reference Block hash"""
  referenceBlockHash(referenceBlockHash: [HashSelector!]): String!
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  transactionCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
  """Hash of Transaction included in block"""
  txHash(txHash: [HashSelector!]): String!
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  uncleCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, epoch: BlockSelector, pivot: Boolean, blockHash: HashSelector, referenceBlockHash: HashSelector, miner: [ConfluxAddressSelector!], refereeCount: [IntegerSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
}

enum ConfluxBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Block Miner"""
  miner
  """Block Referee Count"""
  referee_count
  """Block TX Count"""
  transaction_count
}

enum ConfluxCallsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Caller"""
  caller
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
}

"""Coinpath"""
type ConfluxCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: ConfluxCoinpathAddress
  """Sender address"""
  sender: ConfluxCoinpathAddress
  """Transaction of transfer happened"""
  transaction: TransactionHashValueTime
  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""Address detailed information for Conflux network"""
type ConfluxCoinpathAddress {
  """Address"""
  address: String
  """"""
  amountIn: DecimalNumber
  """"""
  amountOut: DecimalNumber
  """Annotations ( tags ), if exists"""
  annotation: String
  """"""
  balance: DecimalNumber
  """Smart Contract if exists on the address"""
  firstTxAt: DateTime
  """Smart Contract if exists on the address"""
  lastTxAt: DateTime
  """"""
  receiversCount: Int
  """"""
  sendersCount: Int
  """Smart Contract if exists on the address"""
  smartContract: ConfluxSmartContractInfo
  """Address type"""
  type: String
}

"""
Currency selector in Conflux blockchain.
  Currencies supported are native ( CFX ), ERC20, ERC721 tokens.
  You can specify currency symbol or smart contract address. Symbols CFX are reserved for native currencies in Conflux mainnet and classic.
  Conflux Smart contract address should start from cfx: and contain 42 symbols.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input ConfluxCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

enum ConfluxEventsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Smart Contract"""
  smart_contract
  """Smart Contract Event Name"""
  signature_name
  """Smart Contract Event Signature"""
  signature
  """Smart Contract Event Signature Hash"""
  signature_hash
}

enum ConfluxNetwork {
  """Conflux Hydra"""
  conflux_hydra
  """Conflux Oceanus"""
  conflux_oceanus
  """Conflux Tethys"""
  conflux_tethys
}

"""Conflux smart contract"""
type ConfluxSmartContract {
  """Smart Contract Address"""
  address: Address!
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

input ConfluxSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  caller: [ConfluxAddressSelector!]
  smartContractAddress: [ConfluxAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractType: ConfluxSmartContractTypeSelector
  external: Boolean
  success: [Boolean!]
  callDepth: StringSelector
}

"""Smart Contract Calls"""
type ConfluxSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractType: ConfluxSmartContractTypeSelector, external: Boolean, success: [Boolean!], callDepth: StringSelector): Float
  any(of: ConfluxCallsMeasureable!): String
  """Call arguments"""
  arguments: [ConfluxArgumentNameValue!]
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Caller of the method invocation ( tx sender or another smart contract )"""
  caller(caller: [ConfluxAddressSelector!]): ConfluxAddressInfo
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractType: ConfluxSmartContractTypeSelector, external: Boolean, success: [Boolean!], callDepth: StringSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractType: ConfluxSmartContractTypeSelector, external: Boolean, success: [Boolean!], callDepth: StringSelector): BigInt
  """Calendar date"""
  date: Date
  """External call executed explicitly by tx sender. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  """Gas used for transaction in external call, or by methd in internal call"""
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], caller: [ConfluxAddressSelector!], smartContractAddress: [ConfluxAddressSelector!], smartContractMethod: MethodSelector, smartContractType: ConfluxSmartContractTypeSelector, external: Boolean, success: [Boolean!], callDepth: StringSelector): Float
  maximum(of: ConfluxCallsMeasureable!, get: ConfluxCallsMeasureable): String
  minimum(of: ConfluxCallsMeasureable!, get: ConfluxCallsMeasureable): String
  """Smart contract being called"""
  smartContract(smartContractAddress: [ConfluxAddressSelector!]): ConfluxSmartContract
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [ConfluxAddressSelector!]): ConfluxTransactionInfo
}

"""Smart Contract Events"""
type ConfluxSmartContractEvent {
  any(of: ConfluxEventsMeasureable!): String
  """Event arguments"""
  arguments: [ConfluxArgumentNameValue!]
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], smartContractType: ConfluxSmartContractTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractEvent: EventSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], smartContractType: ConfluxSmartContractTypeSelector, smartContractAddress: [ConfluxAddressSelector!], smartContractEvent: EventSelector): BigInt
  """Calendar date"""
  date: Date
  maximum(of: ConfluxEventsMeasureable!, get: ConfluxEventsMeasureable): String
  minimum(of: ConfluxEventsMeasureable!, get: ConfluxEventsMeasureable): String
  """Smart contract being called"""
  smartContract(smartContractAddress: [ConfluxAddressSelector!]): ConfluxSmartContract
  """Contract event logged"""
  smartContractEvent(smartContractEvent: EventSelector): Event
  """Transaction where event happened"""
  transaction(txHash: [HashSelector!], txFrom: [ConfluxAddressSelector!]): ConfluxTransactionInfo
}

input ConfluxSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  smartContractType: ConfluxSmartContractTypeSelector
  smartContractAddress: [ConfluxAddressSelector!]
  smartContractEvent: EventSelector
}

"""Blockchain smart contract"""
type ConfluxSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

type ConfluxSmartContractInfoWithAttribute {
  """Value as address if applicable"""
  address: ConfluxAddressInfo
  """Method name"""
  name: String!
  """Method return type"""
  type: String!
  """Method return value"""
  value: String!
}

"""Blockchain smart contract"""
type ConfluxSmartContractInfoWithAttributes {
  """Attributes from readonly methods"""
  attributes: [ConfluxSmartContractInfoWithAttribute!]
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

"""Selector of smart contract type"""
input ConfluxSmartContractTypeSelector {
  """Smart Contract type is"""
  is: SmartContractType
  """Smart Contract type not"""
  not: SmartContractType
  """Smart Contract type in the list"""
  in: [SmartContractType!]
  """Smart Contract type not in the list"""
  notIn: [SmartContractType!]
}

input ConfluxTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [ConfluxAddressSelector!]
  txTo: [ConfluxAddressSelector!]
  txCreates: [ConfluxAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  blockHash: HashSelector
}

"""Blockchain transaction info"""
type ConfluxTransactionInfo {
  """Gas consumed"""
  gas: Int!
  """Gas price in Gwei"""
  gasPrice: Float!
  """Gas value cost"""
  gasValue: Float!
  """Hash hex representation"""
  hash: String!
  """Transaction from address"""
  txFrom: ConfluxAddressInfo!
}

"""Transactions in Conflux blockchain"""
type ConfluxTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [ConfluxAddressSelector!], txTo: [ConfluxAddressSelector!], txCreates: [ConfluxAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float
  any(of: ConfluxTransactionsMeasureable!): String
  """Block where transfer transaction is included"""
  block(blockHash: HashSelector, height: BlockSelector, time: DateTimeSelector): BlockInfo
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [ConfluxAddressSelector!], txTo: [ConfluxAddressSelector!], txCreates: [ConfluxAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int
  countBigInt(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [ConfluxAddressSelector!], txTo: [ConfluxAddressSelector!], txCreates: [ConfluxAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): BigInt
  """Created smart contract"""
  creates(txCreates: [ConfluxAddressSelector!]): EthereumAddressInfo
  """Currency of amount"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Error message if any"""
  error: String
  expression(get: String!): DecimalNumber
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [ConfluxAddressSelector!], txTo: [ConfluxAddressSelector!], txCreates: [ConfluxAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Int
  """Currency of gas"""
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency
  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [ConfluxAddressSelector!], txTo: [ConfluxAddressSelector!], txCreates: [ConfluxAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [ConfluxAddressSelector!], txTo: [ConfluxAddressSelector!], txCreates: [ConfluxAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], blockHash: HashSelector): Float
  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!
  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String
  minimum(of: ConfluxTransactionsMeasureable!, get: ConfluxTransactionsMeasureable): String
  """Transaction nonce"""
  nonce: Int
  """Transaction sender"""
  sender(txSender: [ConfluxAddressSelector!]): EthereumAddressInfo
  """Success"""
  success(success: Boolean): Boolean
  """Transaction receiver"""
  to(txTo: [ConfluxAddressSelector!]): EthereumAddressInfo
}

enum ConfluxTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """Transaction Sender"""
  tx_sender
  """Gas value"""
  gas_value
  """Gas price"""
  gas_price
  """Gas used"""
  gas
}

input ConfluxTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [ConfluxAddressSelector!]
  entityId: EntitySelector
  sender: [ConfluxAddressSelector!]
  receiver: [ConfluxAddressSelector!]
  currency: [ConfluxCurrencySelector!]
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type ConfluxTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], entityId: EntitySelector, sender: [ConfluxAddressSelector!], receiver: [ConfluxAddressSelector!], currency: [ConfluxCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: ConfluxTransfersMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], entityId: EntitySelector, sender: [ConfluxAddressSelector!], receiver: [ConfluxAddressSelector!], currency: [ConfluxCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], entityId: EntitySelector, sender: [ConfluxAddressSelector!], receiver: [ConfluxAddressSelector!], currency: [ConfluxCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt
  """Currency of transfer"""
  currency(currency: [ConfluxCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String
  """External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts."""
  external(external: Boolean): Boolean
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [ConfluxAddressSelector!], entityId: EntitySelector, sender: [ConfluxAddressSelector!], receiver: [ConfluxAddressSelector!], currency: [ConfluxCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: ConfluxTransfersMeasureable!, get: ConfluxTransfersMeasureable): String
  minimum(of: ConfluxTransfersMeasureable!, get: ConfluxTransfersMeasureable): String
  """Transfer receiver"""
  receiver(receiver: [ConfluxAddressSelector!]): ConfluxAddressInfo
  """Transfer sender"""
  sender(sender: [ConfluxAddressSelector!]): ConfluxAddressInfo
  """Success flag"""
  success(success: Boolean): Boolean
  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!], txFrom: [ConfluxAddressSelector!]): ConfluxTransactionInfo
}

enum ConfluxTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency symbol"""
  currency_symbol
  """Token address"""
  currency_address
  """Entity ID"""
  entity_id
}

"""Cosmos Blockchain"""
type Cosmos {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [CosmosAddressInfo!]!
  """Cosmos Attributes"""
  attributes(date: DateSelector, time: DateTimeSelector, blockHeight: BlockSelector, blockHash: HashSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSigner: StringSelector, messageType: StringSelector, messageIndex: IntegerSelector, success: BooleanSelector, senders: StringSelector, eventType: StringSelector, attribute: StringSelector, value: StringSelector, valueIndex: IntegerSelector, any: [CosmosAttributeFilter!], options: QueryOptions): [CosmosAttribute!]
  """Cosmos Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, proposer: AddressSelector, any: [CosmosBlocksFilter!], options: QueryOptions): [CosmosBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: [CosmosCurrencySelector!], initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [CosmosCoinpath!]
  """Cosmos Messages"""
  messages(date: DateSelector, blockHeight: BlockSelector, blockHash: HashSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSigner: AddressSelector, type: StringSelector, index: IntegerSelector, success: BooleanSelector, senders: StringSelector, any: [CosmosMessageFilter!], options: QueryOptions): [CosmosMessage!]
  """Cosmos Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, hash: HashSelector, type: StringSelector, index: IntegerSelector, gasUsed: IntegerSelector, gasWanted: IntegerSelector, signer: AddressSelector, memo: StringSelector, fee: AmountSelector, code: IntegerSelector, success: BooleanSelector, any: [CosmosTransactionFilter!], options: QueryOptions): [CosmosTransaction!]
  """Cosmos Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, block: BlockSelector, blockHash: HashSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSigner: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: CosmosCurrencySelector, value: AmountSelector, type: StringSelector, index: IntegerSelector, senders: AddressSelector, typeTransfer: BooleanSelector, any: [CosmosTransferFilter!], options: QueryOptions): [CosmosTransfers!]
}

"""Address detailed information for Cosmos network"""
type CosmosAddressInfo {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Native currency balance"""
  balance(in: BaseCurrencyEnum): Float
  """Tokens Info"""
  tokensInfo: [CosmosTokensInfo!]
}

"""Attribute in Cosmos blockchain"""
type CosmosAttribute {
  any(of: CosmosAttributesMeasurable!): String
  """Attribute"""
  attribute: String
  """Block info where transaction included"""
  block: CosmosBlockDimension
  count(uniq: CosmosAttributeUniq, date: DateSelector, time: DateTimeSelector, blockHeight: BlockSelector, blockHash: HashSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSigner: StringSelector, messageType: StringSelector, messageIndex: IntegerSelector, success: BooleanSelector, senders: StringSelector, eventType: StringSelector, attribute: StringSelector, value: StringSelector, valueIndex: IntegerSelector): Int
  countBigInt(uniq: CosmosAttributeUniq, date: DateSelector, time: DateTimeSelector, blockHeight: BlockSelector, blockHash: HashSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSigner: StringSelector, messageType: StringSelector, messageIndex: IntegerSelector, success: BooleanSelector, senders: StringSelector, eventType: StringSelector, attribute: StringSelector, value: StringSelector, valueIndex: IntegerSelector): BigInt
  """The date this transaction was created"""
  date: Date
  """Type of the attribute"""
  eventType: String
  expression(get: String!): DecimalNumber
  maximum(of: CosmosAttributesMeasurable!, get: CosmosAttributesMeasurable): String
  """Message info"""
  message: CosmosMessageDimension
  minimum(of: CosmosAttributesMeasurable!, get: CosmosAttributesMeasurable): String
  """Transaction info where message included"""
  transaction: CosmosTransactionDimension
  """Attribute value"""
  value: String
  """Index of attribute"""
  valueIndex: Int!
}

input CosmosAttributeFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHeight: BlockSelector
  blockHash: HashSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSigner: StringSelector
  messageType: StringSelector
  messageIndex: IntegerSelector
  success: BooleanSelector
  senders: StringSelector
  eventType: StringSelector
  attribute: StringSelector
  value: StringSelector
  valueIndex: IntegerSelector
}

enum CosmosAttributesMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  block
  """Hash of the block"""
  blockHash
  """Index of the transaction in block"""
  transactionIndex
  """Hash of the transaction"""
  transactionHash
  """Transaction Signer"""
  transactionSigner
  """Type of message"""
  messageType
  """Message index in transaction"""
  messageIndex
  """Message success"""
  messageSuccess
  """Message senders"""
  messageSenders
  """Type of attr"""
  eventType
  """ attribute """
  attribute
  """attributeValue"""
  value
  """valueIndex"""
  valueIndex
}

enum CosmosAttributeUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique blocks"""
  blocks
  """Unique block hashes"""
  blockHashes
  """Unique transaction indices"""
  transactionIndices
  """Unique transaction signers"""
  transactionSigners
  """Unique transaction hashes"""
  transactionHashes
  """Unique message types"""
  messageTypes
  """Unique message indices"""
  messageIndices
  """Unique message senders"""
  messageSenders
  """Unique event types"""
  eventTypes
  """Unique attributes"""
  attributes
  """Unique values"""
  values
  """Unique value indices"""
  valueIndices
}

"""Block"""
type CosmosBlock {
  any(of: CosmosBlockMeasurable!): String
  count(uniq: CosmosBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, proposer: AddressSelector): Int
  countBigInt(uniq: CosmosBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, proposer: AddressSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Block Hash"""
  hash: String
  """Block Header"""
  header: String
  """Block number (height) in blockchain"""
  height: Int!
  maximum(of: CosmosBlockMeasurable!, get: CosmosBlockMeasurable): String
  """Block Metadata"""
  metadata: String
  minimum(of: CosmosBlockMeasurable!, get: CosmosBlockMeasurable): String
  """Proposer Address"""
  proposer: Address
  """Block timestamp"""
  timestamp: DateTime
}

"""Information about block"""
type CosmosBlockDimension {
  """Block Hash"""
  hash: String
  """Block number (height) in blockchain"""
  height: Int!
  """Block timestamp"""
  timestamp: DateTime
}

enum CosmosBlockMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  height
  """Proposer"""
  proposer
  """Block hash"""
  hash
}

input CosmosBlocksFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  proposer: AddressSelector
}

enum CosmosBlockUniq {
  """Unique date count"""
  dates
  """Unique timestamps count"""
  times
  """Number of block in the blockchains"""
  blocks
  """Block proposer"""
  proposers
  """Block Hash"""
  hashes
}

"""Coinpath"""
type CosmosCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CosmosCoinpathMeasurable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CosmosCoinpathMeasurable!, get: CosmosCoinpathMeasurable): String
  minimum(of: CosmosCoinpathMeasurable!, get: CosmosCoinpathMeasurable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Message of transfer happened"""
  transaction: TransactionHashValue
}

enum CosmosCoinpathMeasurable {
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  transaction_hash
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Depth"""
  depth
}

"""Currency selector in Cosmos blockchain"""
input CosmosCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

"""Message in Cosmos blockchain"""
type CosmosMessage {
  any(of: CosmosMessageMeasurable!): String
  """Block info where transaction included"""
  block: CosmosBlockDimension
  count(uniq: CosmosMessageUniq, date: DateSelector, blockHeight: BlockSelector, blockHash: HashSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSigner: AddressSelector, type: StringSelector, index: IntegerSelector, success: BooleanSelector, senders: StringSelector): Int
  countBigInt(uniq: CosmosMessageUniq, date: DateSelector, blockHeight: BlockSelector, blockHash: HashSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSigner: AddressSelector, type: StringSelector, index: IntegerSelector, success: BooleanSelector, senders: StringSelector): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Index in tx"""
  index: Int!
  """Body of message """
  json: String
  maximum(of: CosmosMessageMeasurable!, get: CosmosMessageMeasurable): String
  minimum(of: CosmosMessageMeasurable!, get: CosmosMessageMeasurable): String
  """Message sender(s)"""
  senders: String
  """Succeeded or failed"""
  success: Boolean
  """Transaction info where message included"""
  transaction: CosmosTransactionDimension
  """Type of the message"""
  type: String
}

"""Information about message"""
type CosmosMessageDimension {
  """Index in tx"""
  index: Int!
  """Message sender(s)"""
  senders: String
  """Succeeded or failed"""
  success: Boolean
  """Type of the message"""
  type: String
}

input CosmosMessageFilter {
  date: DateSelector
  blockHeight: BlockSelector
  blockHash: HashSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSigner: AddressSelector
  type: StringSelector
  index: IntegerSelector
  success: BooleanSelector
  senders: StringSelector
}

enum CosmosMessageMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the block"""
  blockHash
  """Number of block in the blockhains"""
  blockHeight
  """Index of the transaction"""
  transactionIndex
  """Hash of the transaction"""
  transactionHash
  """Transaction Signer"""
  transactionSigner
  """Type of message"""
  type
  """Message index in transaction"""
  index
  """Message success"""
  success
  """Message senders"""
  senders
  """Message json"""
  json
}

enum CosmosMessageUniq {
  """Uniq date"""
  dates
  """Uniq blocks"""
  blocks
  """Uniq transaction signers"""
  transactionSigners
  """Uniq transaction hashes"""
  transactionHashes
  """Uniq transaction indices"""
  transactionIndices
  """Uniq types"""
  types
  """Uniq senders"""
  senders
}

enum CosmosNetwork {
  """Cosmos Hub Network"""
  cosmoshub
  """Heimdall (Matic Verification Network)"""
  heimdall
  """Crypto.org Mainnet"""
  crypto_mainnet
  """Crypto.org Croeseid Testnet"""
  crypto_testnet
  """Terra Mainnet"""
  terra
}

"""Tokens Info"""
type CosmosTokensInfo {
  """Token Balance"""
  balance: Float
  """Denom"""
  denom: String
}

"""Transaction in Cosmos blockchain"""
type CosmosTransaction {
  any(of: CosmosTransactionMeasurable!): String
  """Block info where transaction included"""
  block: CosmosBlockDimension
  """code"""
  code: Int
  count(uniq: CosmosTransactionUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, hash: HashSelector, type: StringSelector, index: IntegerSelector, gasUsed: IntegerSelector, gasWanted: IntegerSelector, signer: AddressSelector, memo: StringSelector, fee: AmountSelector, code: IntegerSelector, success: BooleanSelector): Int
  countBigInt(uniq: CosmosTransactionUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, hash: HashSelector, type: StringSelector, index: IntegerSelector, gasUsed: IntegerSelector, gasWanted: IntegerSelector, signer: AddressSelector, memo: StringSelector, fee: AmountSelector, code: IntegerSelector, success: BooleanSelector): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, hash: HashSelector, type: StringSelector, index: IntegerSelector, gasUsed: IntegerSelector, gasWanted: IntegerSelector, signer: AddressSelector, memo: StringSelector, fee: AmountSelector, code: IntegerSelector, success: BooleanSelector): Float
  """Currency of transfer"""
  feeCurrency: Currency
  feeDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, hash: HashSelector, type: StringSelector, index: IntegerSelector, gasUsed: IntegerSelector, gasWanted: IntegerSelector, signer: AddressSelector, memo: StringSelector, fee: AmountSelector, code: IntegerSelector, success: BooleanSelector): DecimalNumberAsDiv
  """Gas Used"""
  gasUsed(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, hash: HashSelector, type: StringSelector, index: IntegerSelector, gasUsed: IntegerSelector, gasWanted: IntegerSelector, signer: AddressSelector, memo: StringSelector, fee: AmountSelector, code: IntegerSelector, success: BooleanSelector): BigInt!
  """Gas Wanted"""
  gasWanted(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, hash: HashSelector, type: StringSelector, index: IntegerSelector, gasUsed: IntegerSelector, gasWanted: IntegerSelector, signer: AddressSelector, memo: StringSelector, fee: AmountSelector, code: IntegerSelector, success: BooleanSelector): BigInt!
  """Hash of the transactions"""
  hash: String
  """Index of the transaction in block"""
  index: Int
  maximum(of: CosmosTransactionMeasurable!, get: CosmosTransactionMeasurable): String
  """Memo"""
  memo: String
  minimum(of: CosmosTransactionMeasurable!, get: CosmosTransactionMeasurable): String
  """Raw Tx"""
  rawTx: String
  """Transaction Signer"""
  signer: Address
  """Succeeded or failed"""
  success: Boolean
  """Type of the transactions"""
  type: String
}

"""Information about transaction"""
type CosmosTransactionDimension {
  """Hash of the transactions"""
  hash: String
  """Index of the transaction in block"""
  index: Int
  """Transaction Signer"""
  signer: Address
}

input CosmosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  hash: HashSelector
  type: StringSelector
  index: IntegerSelector
  gasUsed: IntegerSelector
  gasWanted: IntegerSelector
  signer: AddressSelector
  memo: StringSelector
  fee: AmountSelector
  code: IntegerSelector
  success: BooleanSelector
}

enum CosmosTransactionMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the block"""
  block_hash
  """Number of block in the blockhains"""
  block_height
  """Hash of the transaction"""
  hash
  """Type of the transaction"""
  type
  """Transaction Signer"""
  signer
  """Transaction Fee"""
  fee
  """Transaction Code"""
  code
  """Transaction Memo"""
  memo
  """Transaction Index"""
  index
  """Raw Transaction"""
  rawTx
}

enum CosmosTransactionUniq {
  """Unique date count"""
  dates
  """Unique time"""
  times
  """Unique blocks"""
  blocks
  """Unique signers"""
  signers
  """Unique hashes"""
  hashes
  """Unique timecodes"""
  codes
  """Unique types"""
  types
  """Unique memos"""
  memos
  """Unique indices"""
  indices
}

input CosmosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  blockHash: HashSelector
  transactionHash: HashSelector
  transactionIndex: IntegerSelector
  transactionSigner: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: CosmosCurrencySelector
  value: AmountSelector
  type: StringSelector
  index: IntegerSelector
  senders: AddressSelector
  typeTransfer: BooleanSelector
}

"""Transfers in Cosmos  blockchain"""
type CosmosTransfers {
  any(of: CosmosTransfersMeasurable!): String
  """Block info where transaction included"""
  block: CosmosBlockDimension
  count(uniq: CosmosTransferUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, blockHash: HashSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSigner: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: CosmosCurrencySelector, value: AmountSelector, type: StringSelector, index: IntegerSelector, senders: AddressSelector, typeTransfer: BooleanSelector): Int
  countBigInt(uniq: CosmosTransferUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, blockHash: HashSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSigner: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: CosmosCurrencySelector, value: AmountSelector, type: StringSelector, index: IntegerSelector, senders: AddressSelector, typeTransfer: BooleanSelector): BigInt
  """Currency of the transfer"""
  currency: Currency
  """The date this transaction was created"""
  date: Date
  """Is delegated"""
  delegated: Boolean
  expression(get: String!): DecimalNumber
  maximum(of: CosmosTransfersMeasurable!, get: CosmosTransfersMeasurable): String
  """Index in tx"""
  messageIndex: Int!
  """Type of the message"""
  messageType: String
  minimum(of: CosmosTransfersMeasurable!, get: CosmosTransfersMeasurable): String
  """Transfer receiver"""
  receiver: Address
  """Transfer sender"""
  sender: Address
  """Message sender(s)"""
  senders: String
  """Transaction info where message included"""
  transaction: CosmosTransactionDimension
  """Type of the Transfer"""
  type: String
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, blockHash: HashSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSigner: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: CosmosCurrencySelector, value: AmountSelector, type: StringSelector, index: IntegerSelector, senders: AddressSelector, typeTransfer: BooleanSelector): Float
  valueDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, block: BlockSelector, blockHash: HashSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSigner: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: CosmosCurrencySelector, value: AmountSelector, type: StringSelector, index: IntegerSelector, senders: AddressSelector, typeTransfer: BooleanSelector): DecimalNumberAsDiv
}

enum CosmosTransfersMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the block"""
  blockHash
  """Index of the transaction"""
  transactionIndex
  """Hash of the transaction"""
  transactionHash
  """Transaction Signer"""
  transactionSigner
  """Transfer From"""
  sender
  """Transfer To"""
  receiver
  """Transfer value"""
  value
  """Type of transfer"""
  type
  """Message index in transaction"""
  messageIndex
  """Type of message"""
  messageType
  """Message senders"""
  senders
  """Currency Symbol"""
  currency_symbol
  """Currency Address"""
  currency_address
  """Token Type"""
  token_type
  """Token ID"""
  token_id
}

enum CosmosTransferUniq {
  """Unique times"""
  times
  """Unique dates"""
  dates
  """Unique blocks"""
  blocks
  """Unique block hashes"""
  blockHashes
  """Unique transaction indices"""
  transactionIndices
  """Unique transaction hashes"""
  transactionHashes
  """Unique transaction signers"""
  transactionSigners
  """Unique senders (field sender)"""
  sender
  """Unique time"""
  receiver
  """Unique currencies"""
  currencies
  """Unique transfer types"""
  types
  """Unique message indices"""
  messageIndices
  """Unique message types"""
  messageTypes
  """Unique senders (field senders)"""
  senders
}

"""Crypto currency ( token, coin, currency )"""
type Currency {
  """Token Smart Contract Address"""
  address: String
  """Decimals"""
  decimals: Int!
  """Currency name"""
  name: String
  """Currency symbol"""
  symbol: String!
  """Token ID"""
  tokenId: String
  """Token Type"""
  tokenType: String
}

"""Currency selector"""
input CurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

"""Instruction Data"""
type Data {
  base58: String!
  hex: String!
}

"""Date"""
type Date {
  """String date representation with default format as YYYY-MM-DD"""
  date(format: String): String!
  """Day of month (1-31)"""
  dayOfMonth: Int!
  """Day of week  (Monday is 1, and Sunday is 7)"""
  dayOfWeek: Int!
  """Month number (1-12)"""
  month: Int!
  """
  Returns start of date interval ,
      date representation with default format as YYYY-MM-DD. Example is start of interval for 3 weeks each,
    starting on wednesdays will read as: 'startOfInterval(unit: week, interval: 3, offset: 2)'
  """
  startOfInterval(format: String, interval: Int, offset: Int, unit: DateInterval!): String!
  """Year number"""
  year: Int!
}

enum DateInterval {
  """Year"""
  year
  """Month"""
  month
  """Week"""
  week
  """Day"""
  day
}

"""Selecting the date in a range, list or just date"""
input DateSelector {
  """Since date"""
  since: ISO8601DateTime
  """Till date"""
  till: ISO8601DateTime
  """Range of dates"""
  between: [ISO8601DateTime!]
  """Before date"""
  before: ISO8601DateTime
  """After date"""
  after: ISO8601DateTime
  """In dates"""
  in: [ISO8601DateTime!]
  """Not in dates"""
  notIn: [ISO8601DateTime!]
  """Date equals"""
  is: ISO8601DateTime
  """Date not equals"""
  not: ISO8601DateTime
}

"""Date and Time"""
type DateTime {
  """Day of month (1-31)"""
  dayOfMonth: Int!
  """Day of week  (Monday is 1, and Sunday is 7)"""
  dayOfWeek: Int!
  """Hour (0-23)"""
  hour: Int!
  """ISO8601 date time such as '2020-03-02T13:30:41+00:00'"""
  iso8601: ISO8601DateTime!
  """Minute (0-59)"""
  minute: Int!
  """Month number (1-12)"""
  month: Int!
  """Second (0-59)"""
  second: Int!
  """String date representation with default format as YYYY-MM-DD"""
  time(format: String): String!
  """Unix timestamp"""
  unixtime: Int!
  """Year number"""
  year: Int!
}

"""Selecting the time in a range, list or just time"""
input DateTimeSelector {
  """Since time"""
  since: ISO8601DateTime
  """Till time"""
  till: ISO8601DateTime
  """Range of time"""
  between: [ISO8601DateTime!]
  """Before time"""
  before: ISO8601DateTime
  """After time"""
  after: ISO8601DateTime
  """In times"""
  in: [ISO8601DateTime!]
  """Not in times"""
  notIn: [ISO8601DateTime!]
  """Time equals"""
  is: ISO8601DateTime
  """Time not equals"""
  not: ISO8601DateTime
}

"""
Represents fractional signed whole numeric values.
Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar DecimalNumber

"""
Represents fractional signed whole numeric values.
Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar DecimalNumberAsDiv

enum DiemNetwork {
  """Diem Testnet"""
  diem_testnet
  """Libra Testnet"""
  libra_testnet
}

"""Elrond Chain"""
type Elrond {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [ElrondAddressInfoWithBalance!]!
  """Information about validators of the block"""
  blockValidators(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, validator: HashSelector, any: [ElrondBlockValidatorFilter!], options: QueryOptions): [ElrondBlockValidator!]
  """Information about blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, hash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, nonce: IntegerSelector, round: IntegerSelector, publicKeyBitmap: StringSelector, size: IntegerSelector, sizeTxs: IntegerSelector, stateRootHash: IntegerSelector, transactionCount: IntegerSelector, any: [ElrondBlockFilter!], options: QueryOptions): [ElrondBlock!]
  """Information about calls"""
  callResults(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, callResultIndex: IntegerSelector, callResultType: StringSelector, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultHash: HashSelector, callResultNonce: IntegerSelector, previousTxHash: HashSelector, callResultReceiver: HashSelector, callResultSender: HashSelector, returnMessage: StringSelector, relayed: StringSelector, callResultValue: FloatSelector, callResultRelayedValue: FloatSelector, callResultGasPrice: FloatSelector, callResultGasLimit: FloatSelector, any: [ElrondCallResultFilter!], options: QueryOptions): [ElrondCallResult!]
  """Information about Event"""
  events(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, txFunction: StringSelector, eventIndex: IntegerSelector, callResultPath: StringSelector, eventType: EventTypeSelector, address: AddressSelector, identifier: StringSelector, any: [ElrondEventFilter!], options: QueryOptions): [ElrondEvent!]
  """Information about miniblocks"""
  miniblocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, receiverBlockHash: HashSelector, receiverShard: BigIntIdSelector, type: StringSelector, any: [ElrondMiniblockFilter!], options: QueryOptions): [ElrondMiniblock!]
  """Information about notarized block"""
  notarizedBlock(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, notarizedBlockHash: HashSelector, any: [ElrondNotarizedBlockFilter!], options: QueryOptions): [ElrondNotarizedBlock!]
  """Information about Token Operations"""
  operations(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, txFunction: StringSelector, operationIndex: IntegerSelector, operationAction: StringSelector, operationType: StringSelector, operationSender: AddressSelector, operationReceiver: AddressSelector, operationData: StringSelector, any: [ElrondOperationFilter!], options: QueryOptions): [ElrondOperation!]
  """Information about transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, fee: FloatSelector, gasUsed: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, txValue: FloatSelector, function: StringSelector, actionName: StringSelector, actionCategory: StringSelector, actionDescription: StringSelector, any: [ElrondTransactionFilter!], options: QueryOptions): [ElrondTransaction!]
  """Information about transactions"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, currency: CurrencySelector, transferSender: AddressSelector, transferReceiver: AddressSelector, entityId: EntitySelector, action: ActionSelector, transferType: StringSelector, esdtType: StringSelector, any: [ElrondTransferFilter!], options: QueryOptions): [ElrondTransfer!]
}

"""Blockchain address hash"""
type ElrondAddressHash {
  """String hex address representation"""
  hex: String!
}

"""Address detailed information for Elrond network"""
type ElrondAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Native currency balance"""
  balance(in: BaseCurrencyEnum): Float
  """Extra information abount address from node"""
  extraInfo: ElrondExtraInfo
  """Staked EGLD"""
  staking(in: BaseCurrencyEnum): Float
  """Tokens Info"""
  tokensInfo: [ElrondTokensInfo!]
}

"""Blocks in Elrond  blockchain"""
type ElrondBlock {
  any(of: ElrondBlocksMeasureable!): String
  count(uniq: ElrondBlockUniq): Int
  countBigInt(uniq: ElrondBlockUniq): BigInt
  """The date this transaction was created"""
  date: Date
  """Epoch"""
  epoch: Int
  expression(get: String!): DecimalNumber
  """Hash of the the block"""
  hash: String
  """Number of block in the blockchains"""
  height: BigInt
  maximum(of: ElrondBlocksMeasureable!, get: ElrondBlocksMeasureable): String
  minimum(of: ElrondBlocksMeasureable!, get: ElrondBlocksMeasureable): String
  """Block Height"""
  nonce: BigInt
  """The block hash of this block`s parent"""
  previousBlockHash: String
  """Proposer block hash"""
  proposer: ElrondAddressHash
  """Public Key Bitmap"""
  publicKeyBitmap: String
  """Round"""
  round: BigInt
  """Shard number of block"""
  shard: String
  """Size"""
  size: Int
  """Size Tx"""
  sizeTxs: Int
  """State root hash"""
  stateRootHash: String
  """The time this transaction was created"""
  time: DateTime
  """Count of transactions in this block"""
  transactionCount: BigInt
}

"""Information about block"""
type ElrondBlockDimension {
  """Epoch"""
  epoch: Int
  """Hash of the block"""
  hash: String
  """Number of block in the blockchains"""
  height: BigInt
  """Block Height"""
  nonce: BigInt
  """The block hash of this block`s parent"""
  previousBlockHash: String
  """Proposer block hash"""
  proposer: ElrondAddressHash
  """Public Key Bitmap"""
  publicKeyBitmap: String
  """Round"""
  round: BigInt
  """Shard number of block"""
  shard: String
  """Size"""
  size: Int
  """Size Tx"""
  sizeTxs: Int
  """State root hash"""
  stateRootHash: String
  """Count of transactions in this block"""
  transactionCount: BigInt
}

input ElrondBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  hash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  nonce: IntegerSelector
  round: IntegerSelector
  publicKeyBitmap: StringSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  stateRootHash: IntegerSelector
  transactionCount: IntegerSelector
}

enum ElrondBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Shard number of block"""
  shard
  """Block proposer"""
  proposer
  """Block epoch"""
  epoch
  """Block nonce"""
  nonce
  """Block round"""
  round
  """Block public key bitmap"""
  public_key_bitmap
  """Block size"""
  size
  """Block size txs"""
  size_txs
  """State root hash"""
  state_root_hash
  """Count of transactions in this block"""
  transaction_count
}

enum ElrondBlockUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
}

"""BlockValidators in Elrond  blockchain"""
type ElrondBlockValidator {
  any(of: ElrondBlockValidatorsMeasureable!): String
  """Information about blocks notarized block"""
  block(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
  count(uniq: ElrondBlockValidatorUniq): Int
  countBigInt(uniq: ElrondBlockValidatorUniq): BigInt
  """The date this transaction was created"""
  date: Date
  maximum(of: ElrondBlockValidatorsMeasureable!, get: ElrondBlockValidatorsMeasureable): String
  minimum(of: ElrondBlockValidatorsMeasureable!, get: ElrondBlockValidatorsMeasureable): String
  """The time this transaction was created"""
  time: DateTime
  """Hash of validator"""
  validator: ElrondAddressHash
}

input ElrondBlockValidatorFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  validator: HashSelector
}

enum ElrondBlockValidatorsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Shard number of block"""
  shard
  """Block proposer"""
  proposer
  """Block epoch"""
  epoch
  """Block nonce"""
  nonce
  """Block round"""
  round
  """Block public key bitmap"""
  public_key_bitmap
  """Block size"""
  size
  """Block size txs"""
  size_txs
  """State root hash"""
  state_root_hash
  """Count of transactions in this block"""
  transaction_count
  """Hash of the validator"""
  validator
}

enum ElrondBlockValidatorUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique number of validators"""
  validators
}

"""CallResults in Elrond blockchain"""
type ElrondCallResult {
  any(of: ElrondCallResultsMeasureable!): String
  count(uniq: ElrondCallResultUniq): Int
  countBigInt(uniq: ElrondCallResultUniq): BigInt
  """Call result data"""
  data(callResultData: StringSelector): String
  """Call result data operation"""
  dataOperation(callResultDataOperation: StringSelector): String
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Call result gas limit"""
  gasLimit(callResultGasLimit: IntegerSelector): BigInt
  """Call result gas price"""
  gasPrice(callResultGasPrice: IntegerSelector): BigInt
  """Hash of the call result"""
  hash(callResultHash: HashSelector): String
  """Call result index"""
  index(callResultIndex: IntegerSelector): Int
  maximum(of: ElrondCallResultsMeasureable!, get: ElrondCallResultsMeasureable): String
  """Information about calls miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondCallResultsMeasureable!, get: ElrondCallResultsMeasureable): String
  """Nonce of the call result"""
  nonce(callResultNonce: IntegerSelector): BigInt
  """Hash of the previous transaction"""
  previousTxHash(previousTxHash: HashSelector): String
  """Call result receiver"""
  receiver(callResultReceiver: HashSelector): Address
  """Call result relayed"""
  relayed(relayed: StringSelector): String
  relayedValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, callResultIndex: IntegerSelector, callResultType: StringSelector, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultHash: HashSelector, callResultNonce: IntegerSelector, previousTxHash: HashSelector, callResultReceiver: HashSelector, callResultSender: HashSelector, returnMessage: StringSelector, relayed: StringSelector, callResultValue: FloatSelector, callResultRelayedValue: FloatSelector, callResultGasPrice: FloatSelector, callResultGasLimit: FloatSelector): Float
  """Call result return message"""
  returnMessage(returnMessage: StringSelector): String
  """Call result sender"""
  sender(callResultSender: HashSelector): Address
  """Information about calls block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
  """The time this transaction was created"""
  time: DateTime
  """Information about calls transaction"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, txFunction: StringSelector): TransactionElrond
  """Call result type"""
  type(callResultType: StringSelector): String
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, callResultIndex: IntegerSelector, callResultType: StringSelector, callResultData: StringSelector, callResultDataOperation: StringSelector, callResultHash: HashSelector, callResultNonce: IntegerSelector, previousTxHash: HashSelector, callResultReceiver: HashSelector, callResultSender: HashSelector, returnMessage: StringSelector, relayed: StringSelector, callResultValue: FloatSelector, callResultRelayedValue: FloatSelector, callResultGasPrice: FloatSelector, callResultGasLimit: FloatSelector): Float
}

input ElrondCallResultFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  callResultIndex: IntegerSelector
  callResultType: StringSelector
  callResultData: StringSelector
  callResultDataOperation: StringSelector
  callResultHash: HashSelector
  callResultNonce: IntegerSelector
  previousTxHash: HashSelector
  callResultReceiver: HashSelector
  callResultSender: HashSelector
  returnMessage: StringSelector
  relayed: StringSelector
  callResultValue: FloatSelector
  callResultRelayedValue: FloatSelector
  callResultGasPrice: FloatSelector
  callResultGasLimit: FloatSelector
}

enum ElrondCallResultsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """The block hash of this block`s parent"""
  transaction_count
  """Hash of the miniblock"""
  miniblock_hash
  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash
  """Miniblock receiver shard"""
  miniblock_receiver_shard
  """Type of miniblock"""
  type
  """Transaction hash"""
  tx_hash
  """Receiver hash"""
  tx_receiver
  """Shard number of the receiver"""
  tx_receiver_shard
  """Sender hash"""
  tx_sender
  """Shard number of the sender"""
  tx_sender_shard
  """Data"""
  data
  """Gas Limit"""
  gas_limit
  """Gas Price"""
  gas_price
  """Gas Used"""
  gas_used
  """Value"""
  tx_value
  """Index of the call result"""
  call_result_index
  """Data of the call result"""
  call_result_data
  """Hash of the call result"""
  call_result_hash
  """Previous transaction hash of the call result"""
  previous_tx_hash
  """Receiver of the call result"""
  call_result_receiver
  """Sender of the call result"""
  call_result_sender
}

enum ElrondCallResultUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of call results"""
  index
}

"""Events in Elrond blockchain"""
type ElrondEvent {
  """Address"""
  address: Address
  any(of: ElrondEventsMeasureable!): String
  """Call Result Path"""
  callResultPath: String
  count(uniq: ElrondEventUniq): Int
  countBigInt(uniq: ElrondEventUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Identifier"""
  identifier: String
  """Index"""
  index: Int
  maximum(of: ElrondEventsMeasureable!, get: ElrondEventsMeasureable): String
  """Information about miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondEventsMeasureable!, get: ElrondEventsMeasureable): String
  """Information about calls block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
  """The time this transaction was created"""
  time: DateTime
  """Data"""
  topics: [String!]
  """Information about transactions"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, txFunction: StringSelector): TransactionElrond
  """Type"""
  type: String
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, previousBlockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, txFunction: StringSelector, eventIndex: IntegerSelector, callResultPath: StringSelector, eventType: EventTypeSelector, address: AddressSelector, identifier: StringSelector): Float
}

input ElrondEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  txFunction: StringSelector
  eventIndex: IntegerSelector
  callResultPath: StringSelector
  eventType: EventTypeSelector
  address: AddressSelector
  identifier: StringSelector
}

enum ElrondEventsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """The block hash of this block`s parent"""
  transaction_count
  """Hash of the miniblock"""
  miniblock_hash
  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash
  """Miniblock receiver shard"""
  miniblock_receiver_shard
  """Type of miniblock"""
  type
  """Transaction hash"""
  tx_hash
  """Receiver hash"""
  tx_receiver
  """Shard number of the receiver"""
  tx_receiver_shard
  """Sender hash"""
  tx_sender
  """Shard number of the sender"""
  tx_sender_shard
  """Data"""
  data
  """Gas Limit"""
  gas_limit
  """Gas Price"""
  gas_price
  """Gas Used"""
  gas_used
  """Value"""
  tx_value
  """Event Index"""
  event_index
  """Call Result Path"""
  call_result_path
  """Event Type"""
  event_type
  """Address"""
  address
  """Identifier"""
  identifier
}

enum ElrondEventUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique count of block in the blockchains"""
  height
}

type ElrondExtraInfo {
  """Root Hash"""
  rootHash: String
  """Shard"""
  shard: BigInt
  """Transactions Count"""
  txCount: BigInt
}

"""Miniblocks in Elrond  blockchain"""
type ElrondMiniblock {
  any(of: ElrondMiniblocksMeasureable!): String
  count(uniq: ElrondMiniblockUniq): Int
  countBigInt(uniq: ElrondMiniblockUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Miniblock hash"""
  hash: String
  maximum(of: ElrondMiniblocksMeasureable!, get: ElrondMiniblocksMeasureable): String
  minimum(of: ElrondMiniblocksMeasureable!, get: ElrondMiniblocksMeasureable): String
  """Hash of the receiver block"""
  receiverBlockHash: String
  """Number of the receiver shard"""
  receiverShard: String
  """Information about miniblocks block"""
  senderBlock: ElrondBlockDimension
  """The time this transaction was created"""
  time: DateTime
  """Miniblock type"""
  type: String
}

input ElrondMiniblockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  receiverBlockHash: HashSelector
  receiverShard: BigIntIdSelector
  type: StringSelector
}

enum ElrondMiniblocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Count of transactions"""
  transaction_count
  """Hash of the miniblock"""
  hash
  """Hash of the miniblocks receiver block"""
  receiver_block_hash
  """Miniblock receiver shard"""
  receiver_shard
  """Type of miniblock"""
  type
}

enum ElrondMiniblockUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
}

enum ElrondNetwork {
  """Elrond mainnet"""
  elrond
}

"""NotarizedBlocks in Elrond blockchain"""
type ElrondNotarizedBlock {
  any(of: ElrondNotarizedBlocksMeasureable!): String
  """Information about blocks notarized block"""
  block: ElrondBlockDimension
  count(uniq: ElrondNotarizedBlockUniq): Int
  countBigInt(uniq: ElrondNotarizedBlockUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: ElrondNotarizedBlocksMeasureable!, get: ElrondNotarizedBlocksMeasureable): String
  minimum(of: ElrondNotarizedBlocksMeasureable!, get: ElrondNotarizedBlocksMeasureable): String
  """Hash of the notarized block"""
  notarizedBlockHash: String
  """The time this transaction was created"""
  time: DateTime
}

input ElrondNotarizedBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  notarizedBlockHash: HashSelector
}

enum ElrondNotarizedBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Shard number of block"""
  shard
  """Block proposer"""
  proposer
  """Block epoch"""
  epoch
  """Block nonce"""
  nonce
  """Block round"""
  round
  """Block public key bitmap"""
  public_key_bitmap
  """Block size"""
  size
  """Block size txs"""
  size_txs
  """State root hash"""
  state_root_hash
  """Count of transactions in this block"""
  transaction_count
  """Notarized block hash"""
  notarized_block_hash
}

enum ElrondNotarizedBlockUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique hash of notarized block"""
  notarized_block_hash
}

"""Operations in Elrond blockchain"""
type ElrondOperation {
  """Action"""
  action: String
  any(of: ElrondOperationsMeasureable!): String
  count(uniq: ElrondOperationUniq): Int
  countBigInt(uniq: ElrondOperationUniq): BigInt
  """Data"""
  data: String
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Index"""
  index: Int
  maximum(of: ElrondOperationsMeasureable!, get: ElrondOperationsMeasureable): String
  """Message"""
  message: String
  """Information about calls miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondOperationsMeasureable!, get: ElrondOperationsMeasureable): String
  """Receiver"""
  receiver: Address
  """Sender"""
  sender: Address
  """Information about calls block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
  """The time this transaction was created"""
  time: DateTime
  """Information about calls transaction"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, txFunction: StringSelector): TransactionElrond
  """Type"""
  type: String
}

input ElrondOperationFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  previousBlockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  txFunction: StringSelector
  operationIndex: IntegerSelector
  operationAction: StringSelector
  operationType: StringSelector
  operationSender: AddressSelector
  operationReceiver: AddressSelector
  operationData: StringSelector
}

enum ElrondOperationsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """The block hash of this block`s parent"""
  transaction_count
  """Hash of the miniblock"""
  miniblock_hash
  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash
  """Miniblock receiver shard"""
  miniblock_receiver_shard
  """Type of miniblock"""
  type
  """Transaction hash"""
  tx_hash
  """Receiver hash"""
  tx_receiver
  """Shard number of the receiver"""
  tx_receiver_shard
  """Sender hash"""
  tx_sender
  """Shard number of the sender"""
  tx_sender_shard
  """Data"""
  data
  """Gas Limit"""
  gas_limit
  """Gas Price"""
  gas_price
  """Gas Used"""
  gas_used
  """Value"""
  tx_value
  """Operation Index"""
  operation_index
  """Operation Action"""
  operation_action
  """Operation type"""
  operation_type
  """Operation sender"""
  operation_sender
  """Operation receiver"""
  operation_receiver
  """Operation data"""
  operation_data
  """Operation message"""
  operation_message
}

enum ElrondOperationUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique count of block in the blockchains"""
  height
  """Unique count of operations"""
  operations
}

"""Tokens Info"""
type ElrondTokensInfo {
  """Token Balance"""
  balance: Float
  """Currency Info"""
  currency: Currency
}

"""Transactions in Elrond blockchain"""
type ElrondTransaction {
  """Transaction Action"""
  action: ElrondTransactionAction
  any(of: ElrondTransactionsMeasureable!): String
  count(uniq: ElrondTransactionUniq): Int
  countBigInt(uniq: ElrondTransactionUniq): BigInt
  """Data"""
  data: String
  """Data operation"""
  dataOperation: String
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, fee: FloatSelector, gasUsed: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, txValue: FloatSelector, function: StringSelector, actionName: StringSelector, actionCategory: StringSelector, actionDescription: StringSelector): Float
  """Tx function"""
  function: String
  """Number of gas limit"""
  gasLimit: BigInt
  """Number of gas price"""
  gasPrice: BigInt
  """Number of gas used"""
  gasUsed: BigInt
  """Transaction hash"""
  hash: String
  """Transaction index"""
  index: Int
  maximum(of: ElrondTransactionsMeasureable!, get: ElrondTransactionsMeasureable): String
  """Information about transactions miniblock"""
  miniblock: MiniblockElrond
  minimum(of: ElrondTransactionsMeasureable!, get: ElrondTransactionsMeasureable): String
  """Transaction nonce"""
  nonce: Int
  """TX  receiver"""
  receiver: Address
  """Shard number of receiver"""
  receiverShard: BigInt
  """Hash of the sender"""
  sender: Address
  """Information about transactions block"""
  senderBlock: ElrondBlockDimension
  """Shard number of sender"""
  senderShard: BigInt
  """Signature"""
  signature: String
  """Tx Status"""
  status: String
  """The time this transaction was created"""
  time: DateTime
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, txIndex: IntegerSelector, txNonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, fee: FloatSelector, gasUsed: FloatSelector, gasLimit: FloatSelector, gasPrice: FloatSelector, txValue: FloatSelector, function: StringSelector, actionName: StringSelector, actionCategory: StringSelector, actionDescription: StringSelector): Float
}

"""Action of transction information"""
type ElrondTransactionAction {
  """Category"""
  category: String
  """Description"""
  description: String
  """Name"""
  name: String
}

input ElrondTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  txIndex: IntegerSelector
  txNonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  fee: FloatSelector
  gasUsed: FloatSelector
  gasLimit: FloatSelector
  gasPrice: FloatSelector
  txValue: FloatSelector
  function: StringSelector
  actionName: StringSelector
  actionCategory: StringSelector
  actionDescription: StringSelector
}

enum ElrondTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """The block hash of this block`s parent"""
  transaction_count
  """Hash of the miniblock"""
  miniblock_hash
  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash
  """Miniblock receiver shard"""
  miniblock_receiver_shard
  """Type of miniblock"""
  type
  """Transaction hash"""
  hash
  """Receiver hash"""
  tx_receiver
  """Shard number of the receiver"""
  tx_receiver_shard
  """Sender hash"""
  tx_sender
  """Shard number of the sender"""
  tx_sender_shard
  """Data"""
  data
  """Gas Limit"""
  gas_limit
  """Gas Price"""
  gas_price
  """Gas Used"""
  gas_used
  """Value"""
  value
  """Action Function"""
  function
  """Action Name"""
  action_name
  """Action Category"""
  action_category
  """Action Description"""
  action_description
}

enum ElrondTransactionUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
}

"""Transfers of Smart Contract Calls and Events"""
type ElrondTransfer {
  """Action"""
  action: String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, currency: CurrencySelector, transferSender: AddressSelector, transferReceiver: AddressSelector, entityId: EntitySelector, action: ActionSelector, transferType: StringSelector, esdtType: StringSelector): Float
  any(of: ElrondTransfersMeasureable!): String
  count(uniq: ElrondTransferUniq): Int
  countBigInt(uniq: ElrondTransferUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector, miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector, txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, currency: CurrencySelector, transferSender: AddressSelector, transferReceiver: AddressSelector, entityId: EntitySelector, action: ActionSelector, transferType: StringSelector, esdtType: StringSelector): BigInt
  """Currency of transfer"""
  currency(currency: CurrencySelector): Currency
  """The date this transaction was created"""
  date: Date
  """Entity ID"""
  entityId: BigInt
  """Esdt Type"""
  esdtType: String
  expression(get: String!): DecimalNumber
  maximum(of: ElrondTransfersMeasureable!, get: ElrondTransfersMeasureable): String
  """Information about arguments miniblock"""
  miniblock(miniblockHash: HashSelector, miniblockReceiverBlockHash: HashSelector, miniblockReceiverShard: BigIntIdSelector, type: StringSelector): MiniblockElrond
  minimum(of: ElrondTransfersMeasureable!, get: ElrondTransfersMeasureable): String
  """Receiver account address"""
  receiver: Address
  """Sender account address"""
  sender: Address
  """Information about arguments block"""
  senderBlock(height: BlockSelector, previousBlockHash: HashSelector, blockHash: HashSelector, shard: BigIntIdSelector, proposer: HashSelector, epoch: IntegerSelector, blockNonce: IntegerSelector, round: IntegerSelector, size: IntegerSelector, sizeTxs: IntegerSelector, publicKeyBitmap: StringSelector, stateRootHash: HashSelector, transactionCount: IntegerSelector): ElrondBlockDimension
  """The time this transaction was created"""
  time: DateTime
  """Information about arguments transaction"""
  transaction(txHash: HashSelector, index: IntegerSelector, nonce: IntegerSelector, txReceiver: HashSelector, txReceiverShard: BigIntIdSelector, txSender: HashSelector, txSenderShard: BigIntIdSelector, signature: HashSelector, status: StringSelector, data: StringSelector, dataOperation: StringSelector, txFunction: StringSelector): TransactionElrond
  """Type"""
  type: String
}

input ElrondTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  blockHash: HashSelector
  shard: BigIntIdSelector
  proposer: HashSelector
  epoch: IntegerSelector
  blockNonce: IntegerSelector
  round: IntegerSelector
  size: IntegerSelector
  sizeTxs: IntegerSelector
  publicKeyBitmap: StringSelector
  stateRootHash: HashSelector
  transactionCount: IntegerSelector
  miniblockHash: HashSelector
  miniblockReceiverBlockHash: HashSelector
  miniblockReceiverShard: BigIntIdSelector
  type: StringSelector
  txHash: HashSelector
  index: IntegerSelector
  nonce: IntegerSelector
  txReceiver: HashSelector
  txReceiverShard: BigIntIdSelector
  txSender: HashSelector
  txSenderShard: BigIntIdSelector
  signature: HashSelector
  status: StringSelector
  data: StringSelector
  dataOperation: StringSelector
  currency: CurrencySelector
  transferSender: AddressSelector
  transferReceiver: AddressSelector
  entityId: EntitySelector
  action: ActionSelector
  transferType: StringSelector
  esdtType: StringSelector
}

enum ElrondTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """The block hash of this block`s parent"""
  transaction_count
  """Hash of the miniblock"""
  miniblock_hash
  """Hash of the miniblocks receiver block"""
  miniblock_receiver_block_hash
  """Miniblock receiver shard"""
  miniblock_receiver_shard
  """Type of miniblock"""
  type
  """Transaction hash"""
  tx_hash
  """Receiver hash"""
  tx_receiver
  """Shard number of the receiver"""
  tx_receiver_shard
  """Sender hash"""
  tx_sender
  """Shard number of the sender"""
  tx_sender_shard
  """Data"""
  data
  """Gas Limit"""
  gas_limit
  """Gas Price"""
  gas_price
  """Gas Used"""
  gas_used
  """Value"""
  tx_value
  """Transfer Amount"""
  amount
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Entity ID"""
  entity_id
  """Action"""
  action
  """Transfer Type"""
  transferType
  """ESDT Type"""
  esdtType
  """Currency symbol"""
  currency_symbol
  """Token address"""
  currency_address
  """Token ID"""
  token_id
  """Token type"""
  token_type
}

enum ElrondTransferUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  block_height
  """Unique Transaction Hash"""
  signature
  """Unique count of transfers type"""
  transferType
}

"""Entity"""
type Entity {
  """Entity ID"""
  id(entityId: String): String!
  """Entity number"""
  num: Int!
  """Entity realm ID"""
  realmId: Int!
  """Entity shard ID"""
  shardId: Int!
  """Entity Type"""
  type: String!
}

"""Selector of entity ID for NFT  tokens"""
input EntitySelector {
  """EntityID is"""
  is: String
  """EntityID not"""
  not: String
  """EntityID in the list"""
  in: [String!]
  """EntityID not in the list"""
  notIn: [String!]
}

enum EntityTypeEnum {
  """account"""
  account
  """contract"""
  contract
  """file"""
  file
  """topic"""
  topic
  """token"""
  token
  """schedule"""
  schedule
}

"""Select by entity type"""
input EntityTypeSelector {
  """Type is"""
  is: EntityTypeEnum
  """Type not"""
  not: EntityTypeEnum
  """Type in the list"""
  in: [EntityTypeEnum!]
  """Type not in the list"""
  notIn: [EntityTypeEnum!]
}

"""EOS Chain"""
type Eos {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [EosAddressInfo!]!
  """Blockchain Address Statistics"""
  addressStats(address: AddressSelector!, options: QueryOptions): [EosAddressStats!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector, any: [EosBlockFilter!], options: QueryOptions): [EosBlocks!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EosCoinpath!]
  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean, any: [EosSmartContractCallFilter!], options: QueryOptions): [EosSmartContractCalls!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean, any: [EosTransactionFilter!], options: QueryOptions): [EosTransactions!]
  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [EosTransferFilter!], options: QueryOptions): [EosTransfers!]
}

"""Address detailed information for EOS network"""
type EosAddressInfo {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Smart Contract if exists on the address"""
  smartContract: EosSmartContractInfo
}

"""Address with statistics"""
type EosAddressStat {
  """Address"""
  address: Address
  """Balance"""
  balance: BigInt
  """Call Tx Count"""
  callTxCount: BigInt
  """Called Tx Count"""
  calledTxCount: BigInt
  """Days with received"""
  daysWithReceived: BigInt
  """Days with sent"""
  daysWithSent: BigInt
  """Days with transactions"""
  daysWithTransactions: BigInt
  """Days with transfers"""
  daysWithTransfers: BigInt
  """First transfer at"""
  firstTransferAt: DateTime
  """First tx at"""
  firstTxAt: DateTime
  """Last transfer at"""
  lastTransferAt: DateTime
  """Last tx at"""
  lastTxAt: DateTime
  """Other Tx Count"""
  otherTxCount: BigInt
  """Receive Amount"""
  receiveAmount: BigInt
  """Receive from Count"""
  receiveFromCount: BigInt
  """Receive from currencies"""
  receiveFromCurrencies: BigInt
  """Receive tx Count"""
  receiveTxCount: BigInt
  """Send Amount"""
  sendAmount: BigInt
  """Send to count"""
  sendToCount: BigInt
  """Send to currencies"""
  sendToCurrencies: BigInt
  """Send tx count"""
  sendTxCount: BigInt
}

"""AddressStat"""
type EosAddressStats {
  """Address With Statistics"""
  address: EosAddressStat
}

input EosBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  proposer: AddressSelector
}

"""Blocks in EOS blockchain"""
type EosBlocks {
  any(of: EosBlocksMeasureable!): String
  count(uniq: EosBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector): Int
  countBigInt(uniq: EosBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, proposer: AddressSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Block hash"""
  hash(blockHash: [HashSelector!]): String!
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String
  minimum(of: EosBlocksMeasureable!, get: EosBlocksMeasureable): String
  """Block producer"""
  producer(producer: AddressSelector): Address
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
}

enum EosBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Block Proposer"""
  proposer
}

enum EosBlocksUniq {
  """Unique proposer count"""
  proposers
  """Unique date count"""
  dates
}

enum EosCallsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Sender"""
  tx_sender
  """Action From"""
  tx_from
  """Action To"""
  tx_to
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
}

"""Coinpath"""
type EosCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: EosCoinpathAddress
  """Sender address"""
  sender: EosCoinpathAddress
  """Transaction of transfer happened"""
  transaction: TransactionHashValueTime
}

"""Address detailed information for Eos network"""
type EosCoinpathAddress {
  """Address"""
  address: String
  """"""
  amountIn: DecimalNumber
  """"""
  amountOut: DecimalNumber
  """Annotations ( tags ), if exists"""
  annotation: String
  """"""
  balance: DecimalNumber
  """Smart Contract if exists on the address"""
  firstTxAt: DateTime
  """Smart Contract if exists on the address"""
  lastTxAt: DateTime
  """"""
  receiversCount: Int
  """"""
  sendersCount: Int
  """Smart Contract if exists on the address"""
  smartContract: EosSmartContractInfo
  """Address type"""
  type: String
}

"""
Currency selector in EOS blockchain.
Token identified by address of contract ( eosio.token for main EOS token ) 
"""
input EosCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

enum EosNetwork {
  """EOS mainnet"""
  eos
}

"""Eos smart contract"""
type EosSmartContract {
  """Smart Contract Address"""
  address: Address!
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

input EosSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
  scheduled: Boolean
}

"""Smart Contract Calls"""
type EosSmartContractCalls {
  """Actors"""
  actors: String
  any(of: EosCallsMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Console"""
  console: String
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, scheduled: Boolean): BigInt
  """Calendar date"""
  date: Date
  """Error Code"""
  errorCode(errorCode: IntIdSelector): Int
  expression(get: String!): DecimalNumber
  """External call executed explicitly by tx sender. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  maximum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String
  minimum(of: EosCallsMeasureable!, get: EosCallsMeasureable): String
  """Permissions"""
  permissions: String
  """Receivers"""
  receivers: String
  """True if call scheduled"""
  scheduled(scheduled: [Boolean!]): Boolean
  """Smart contract being called"""
  smartContract(smartContractAddress: AddressSelector): EosSmartContract
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Action from address"""
  txFrom(txFrom: AddressSelector): Address
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

"""Blockchain smart contract"""
type EosSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

input EosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  scheduled: Boolean
}

"""Transactions in EOS blockchain"""
type EosTransactions {
  any(of: EosTransactionsMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EosTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int
  countBigInt(uniq: EosTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): BigInt
  cpuUsageUs(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!
  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  minimum(of: EosTransactionsMeasureable!, get: EosTransactionsMeasureable): String
  netUsageWords(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, scheduled: Boolean): Int
  """Success"""
  scheduled(scheduled: Boolean): Boolean
  """Success"""
  success(success: Boolean): Boolean
}

enum EosTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """CPU Usage"""
  cpu_usage_us
  """Net Usage"""
  net_usage_words
}

enum EosTransactionsUniq {
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
}

input EosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: EosCurrencySelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type EosTransfers {
  """Actors"""
  actors: String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: EosTransfersMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: EosCurrencySelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt
  """Currency of transfer"""
  currency(currency: EosCurrencySelector): Currency
  """Calendar date"""
  date: Date
  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String
  expression(get: String!): DecimalNumber
  """External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts."""
  external(external: Boolean): Boolean
  maximum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String
  """Memo"""
  memo: String
  minimum(of: EosTransfersMeasureable!, get: EosTransfersMeasureable): String
  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address
  """Transfer sender"""
  sender(sender: AddressSelector): Address
  """Transfer succeeded"""
  success(success: Boolean): Boolean
  """Action from address"""
  txFrom(txFrom: AddressSelector): Address
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

enum EosTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency symbol"""
  currency_symbol
  """Token address"""
  currency_address
}

"""Ethereum Chain"""
type Ethereum {
  """Ethereum Active Addresses"""
  activeAddresses(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!], options: QueryOptions): [EthereumActiveAddress!]
  """Basic information about address ( or smart contract )"""
  address(address: [EthereumAddressSelectorIn!]!): [EthereumAddressInfoWithBalance!]!
  """Blockchain Address Statistics"""
  addressStats(address: EthereumAddressSelector!, options: QueryOptions): [EthereumAddressStats!]
  """Arguments of Smart Contract Calls and Events"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector, any: [EthereumArgumentFilter!], options: QueryOptions): [EthereumArguments!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!], any: [EthereumBlockFilter!], options: QueryOptions): [EthereumBlocks!]
  """Money flow using Coinpath technology"""
  coinpath(sender: EthereumAddressSelector, receiver: EthereumAddressSelector, currency: [EthereumCurrencySelector!], initialAddress: EthereumAddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EthereumCoinpath!]
  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [EthereumDexTradeFilter!], options: QueryOptions): [EthereumDexTrades!]
  """References of Smart Contract Calls and Events"""
  references(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector, any: [EthereumReferencesFilter!], options: QueryOptions): [EthereumReferencess!]
  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: Boolean, callDepth: StringSelector, any: [EthereumSmartContractCallFilter!], options: QueryOptions): [EthereumSmartContractCalls!]
  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector, any: [EthereumSmartContractEventFilter!], options: QueryOptions): [EthereumSmartContractEvent!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], txType: [StringSelector!], feePayer: [StringSelector!], feeRatio: TxIndexSelector, any: [EthereumTransactionFilter!], options: QueryOptions): [EthereumTransactions!]
  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!], any: [EthereumTransferFilter!], options: QueryOptions): [EthereumTransfers!]
}

"""Ethereum v 2.0 Baecon Chain"""
type Ethereum2 {
  """Attestations in block"""
  attestations(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Attestation!]
  """Attester Slashings"""
  attesterSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2AttesterSlashing!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Blocks!]
  """Attestations of blocks"""
  deposits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2Deposit!]
  """Proposer Slashings"""
  proposerSlashings(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2ProposerSlashing!]
  """Validator Updates"""
  validatorUpdates(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], epoch: [StringSelector!], blockProposerPubkey: [HashSelector!], stateRootHash: [HashSelector!], validatorIndex: [IntegerSelector!], validatorStatus: [StringSelector!], validatorPubkey: [HashSelector!], eth1DepositRootHash: [HashSelector!], eth1DepositCount: [IntegerSelector!], eth1BlockHash: [HashSelector!], validatorWithdrawalCredentials: [HashSelector!], validatorSlashed: [BooleanSelector!], validatorBalance: [AmountSelector!], validatorBalanceChange: [AmountSelector!], validatorEffectiveBalance: [AmountSelector!], validatorActivationEpoch: [StringSelector!], validatorExitEpoch: [StringSelector!], validatorWithdrawableEpoch: [StringSelector!], any: [Ethereum2ValidatorUpdatesFilter!], options: QueryOptions): [Ethereum2ValidatorUpdates!]
  """Voluntary Exits"""
  voluntaryExits(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!], any: [Ethereum2Filter!], options: QueryOptions): [Ethereum2VoluntaryExit!]
}

"""Attestations in Ethereum v2.0 blockchain"""
type Ethereum2Attestation {
  aggregationBits: String!
  any(of: Ethereum2AttestationsMeasureable!): String
  attestation: Ethereum2AttestationInfo!
  """Attestation Index (0 based ) in block"""
  attestationIndex: Int!
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  """Committee index for attestation"""
  committeeIndex: Int!
  count(uniq: Ethereum2AttestationsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2AttestationsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], committeeIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String
  minimum(of: Ethereum2AttestationsMeasureable!, get: Ethereum2AttestationsMeasureable): String
  """Block parent hash"""
  parentRoot: String!
  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  """Block state root hash"""
  stateRoot: String!
  """Validator"""
  validator: Ethereum2ValidatorInfo!
  """Sequential index of validator in committee ( 0-based)"""
  validatorInCommitteeIndex: Int!
}

"""AttestationFieldInfo for Ethereum v 2.0 network"""
type Ethereum2AttestationFieldInfo {
  epoch: Int!
  """Root Hash"""
  root: String!
}

"""AttestationInfo for Ethereum v 2.0 network"""
type Ethereum2AttestationInfo {
  beaconBlockRoot: String!
  epoch: Int!
  signature: String!
  slot: Int!
  source: Ethereum2AttestationFieldInfo!
  target: Ethereum2AttestationFieldInfo!
}

enum Ethereum2AttestationsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_root_hash
  """Block Proposer"""
  block_proposer
  """Committee Index"""
  committee
  """Validator index"""
  validator
}

enum Ethereum2AttestationsUniq {
  """Unique blocks"""
  blocks
  """Unique block proposers"""
  block_proposers
  """Unique date count"""
  dates
  """Unique commitees"""
  committees
  """Unique validators"""
  validators
  """Unique attestations"""
  attestations
  """Unique attestation slots"""
  attestation_slots
  """Unique attestation epochs"""
  attestation_epochs
}

"""Attester Slashing in Ethereum v2.0 blockchain"""
type Ethereum2AttesterSlashing {
  any(of: Ethereum2AttesterSlashingMeasureable!): String
  attestation: Ethereum2AttestationInfo!
  """Attestation slashing sequential number"""
  attestationOrder: Int!
  """Attester Slashing Index (0 based ) in block"""
  attesterSlashingIndex: Int!
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2AttesterSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2AttesterSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], attestationSlot: [IntegerSelector!], attestationEpoch: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  maximum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String
  minimum(of: Ethereum2AttesterSlashingMeasureable!, get: Ethereum2AttesterSlashingMeasureable): String
  """Block parent hash"""
  parentRoot: String!
  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  """Block state root hash"""
  stateRoot: String!
  """Validator"""
  validator: Ethereum2ValidatorInfo!
  """Validator index in slashing sequential numbern"""
  validatorInAttestationIndex: Int!
}

enum Ethereum2AttesterSlashingMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_root_hash
  """Block Proposer"""
  block_proposer
  """Validator index"""
  validator
}

enum Ethereum2AttesterSlashingsUniq {
  """Unique blocks"""
  blocks
  """Unique block proposers"""
  block_proposers
  """Unique date count"""
  dates
  """Unique validators"""
  validators
  """Unique slashing slots"""
  attestation_slots
  """Unique slashing epochs"""
  attestation_epochs
}

"""Blocks in Ethereum v2.0 blockchain"""
type Ethereum2Blocks {
  any(of: Ethereum2BlocksMeasureable!): String
  attestationsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  attestationsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
  attesterSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  attesterSlashingsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2BlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2BlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  depositsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  depositsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
  """Epoch in blockchain"""
  epoch: Int!
  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  """Graffiti"""
  graffiti: String!
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String
  minimum(of: Ethereum2BlocksMeasureable!, get: Ethereum2BlocksMeasureable): String
  """Block parent hash"""
  parentRoot: String!
  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  proposerSlashingsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  proposerSlashingsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
  """Randao Reveal"""
  randaoReveal: String!
  """Block signature"""
  signature: String!
  """Block state root hash"""
  stateRoot: String!
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  voluntaryExitsCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  voluntaryExitsCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
}

enum Ethereum2BlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_root_hash
  """Block Miner"""
  block_proposer
}

enum Ethereum2BlocksUniq {
  """Unique proposers"""
  block_proposers
  """Unique date count"""
  dates
}

"""Deposit in Ethereum v2.0 blockchain"""
type Ethereum2Deposit {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!]): Float
  any(of: Ethereum2DepositsMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2DepositsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2DepositsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Deposit Index (0 based ) in block"""
  depositIndex: Int!
  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String
  minimum(of: Ethereum2DepositsMeasureable!, get: Ethereum2DepositsMeasureable): String
  """Block parent hash"""
  parentRoot: String!
  proof: String!
  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  signature: String!
  """Block state root hash"""
  stateRoot: String!
  """Validator"""
  validator: Ethereum2ValidatorInfo!
}

enum Ethereum2DepositsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_root_hash
  """Block Proposer"""
  block_proposer
  """Validator index"""
  validator
}

enum Ethereum2DepositsUniq {
  """Unique blocks"""
  blocks
  """Unique block proposers"""
  block_proposers
  """Unique date count"""
  dates
  """Unique validators"""
  validators
}

"""Eth1 attributes for Ethereum v 2.0 network"""
type Ethereum2Eth1Info {
  """Block Eth1 block hash"""
  blockHash: String!
  """Block Eth1 deposit count"""
  depositCount: Int!
  """Block Eth1 deposit root hash"""
  depositRootHash: String!
}

input Ethereum2Filter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockRootHash: HashSelector
  blockProposerIndex: [IntegerSelector!]
}

enum Ethereum2Network {
  """Beacon Chain Ethereum 2.0"""
  eth2
  """Medalla Ethereum 2.0 Beacon Testnet"""
  medalla
}

"""Proposer attributes for Ethereum v 2.0 network"""
type Ethereum2ProposerInfo {
  """Proposer Index as Integer"""
  index: Int!
  """Proposer Pub Key"""
  pubkey: String!
}

"""Proposer Slashing in Ethereum v2.0 blockchain"""
type Ethereum2ProposerSlashing {
  any(of: Ethereum2ProposerSlashingMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2ProposerSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2ProposerSlashingsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], slashingProposerIndex: [IntegerSelector!], slashingSlot: [IntegerSelector!], slashingEpoch: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  """Header slashing sequential numbern"""
  headerOrder: Int!
  maximum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String
  minimum(of: Ethereum2ProposerSlashingMeasureable!, get: Ethereum2ProposerSlashingMeasureable): String
  """Block parent hash"""
  parentRoot: String!
  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  """Proposer Slashing Index (0 based ) in block"""
  proposerSlashingIndex: Int!
  slashing: Ethereum2SlashingInfo!
  """Block state root hash"""
  stateRoot: String!
}

enum Ethereum2ProposerSlashingMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_root_hash
  """Block Proposer"""
  block_proposer
  """Slashed Proposer"""
  proposer
}

enum Ethereum2ProposerSlashingsUniq {
  """Unique blocks"""
  blocks
  """Unique block proposers"""
  block_proposers
  """Unique date count"""
  dates
  """Unique slashing slots"""
  slashing_slots
  """Unique slashing epochs"""
  slashing_epochs
  """Unique slashing proposers"""
  slashing_proposers
}

"""SlashingInfo for Ethereum v 2.0 network"""
type Ethereum2SlashingInfo {
  """Block body hash"""
  bodyRoot: String!
  epoch: Int!
  """Block parent hash"""
  parentRoot: String!
  """Block proposer"""
  proposer: Ethereum2ValidatorInfo
  signature: String!
  slot: Int!
  """Block state root hash"""
  stateRoot: String!
}

"""Validator attributes for Ethereum v 2.0 network"""
type Ethereum2ValidatorInfo {
  """Validator Index as Integer"""
  index: Int!
  """Validator Pub Key"""
  pubkey: String!
}

"""Validator Updates in Ethereum v2.0 blockchain"""
type Ethereum2ValidatorUpdates {
  any(of: Ethereum2ValidatorUpdatesMeasureable!): String
  """Block in the blockchain"""
  block: Block
  """Block root hash"""
  blockRootHash: String!
  count(uniq: Ethereum2ValidatorUpdatesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], epoch: [StringSelector!], blockProposerPubkey: [HashSelector!], stateRootHash: [HashSelector!], validatorIndex: [IntegerSelector!], validatorStatus: [StringSelector!], validatorPubkey: [HashSelector!], eth1DepositRootHash: [HashSelector!], eth1DepositCount: [IntegerSelector!], eth1BlockHash: [HashSelector!], validatorWithdrawalCredentials: [HashSelector!], validatorSlashed: [BooleanSelector!], validatorBalance: [AmountSelector!], validatorBalanceChange: [AmountSelector!], validatorEffectiveBalance: [AmountSelector!], validatorActivationEpoch: [StringSelector!], validatorExitEpoch: [StringSelector!], validatorWithdrawableEpoch: [StringSelector!]): Int
  countBigInt(uniq: Ethereum2ValidatorUpdatesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], epoch: [StringSelector!], blockProposerPubkey: [HashSelector!], stateRootHash: [HashSelector!], validatorIndex: [IntegerSelector!], validatorStatus: [StringSelector!], validatorPubkey: [HashSelector!], eth1DepositRootHash: [HashSelector!], eth1DepositCount: [IntegerSelector!], eth1BlockHash: [HashSelector!], validatorWithdrawalCredentials: [HashSelector!], validatorSlashed: [BooleanSelector!], validatorBalance: [AmountSelector!], validatorBalanceChange: [AmountSelector!], validatorEffectiveBalance: [AmountSelector!], validatorActivationEpoch: [StringSelector!], validatorExitEpoch: [StringSelector!], validatorWithdrawableEpoch: [StringSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Epoch"""
  epoch: BigInt!
  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(of: Ethereum2ValidatorUpdatesMeasureable!, get: Ethereum2ValidatorUpdatesMeasureable): String
  minimum(of: Ethereum2ValidatorUpdatesMeasureable!, get: Ethereum2ValidatorUpdatesMeasureable): String
  """Block parent hash"""
  parentRootHash: String!
  """Block proposer"""
  proposer: Ethereum2ProposerInfo
  """Block state root hash"""
  stateRootHash: String!
  """Time date"""
  time: DateTime
  """Block validator"""
  validator: Ethereum2ValidatorInfo
  """Validator activation epoch"""
  validatorActivationEpoch: BigInt!
  """Validator balance"""
  validatorBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], epoch: [StringSelector!], blockProposerPubkey: [HashSelector!], stateRootHash: [HashSelector!], validatorIndex: [IntegerSelector!], validatorStatus: [StringSelector!], validatorPubkey: [HashSelector!], eth1DepositRootHash: [HashSelector!], eth1DepositCount: [IntegerSelector!], eth1BlockHash: [HashSelector!], validatorWithdrawalCredentials: [HashSelector!], validatorSlashed: [BooleanSelector!], validatorBalance: [AmountSelector!], validatorBalanceChange: [AmountSelector!], validatorEffectiveBalance: [AmountSelector!], validatorActivationEpoch: [StringSelector!], validatorExitEpoch: [StringSelector!], validatorWithdrawableEpoch: [StringSelector!]): Float
  """Validator balance change"""
  validatorBalanceChange(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], epoch: [StringSelector!], blockProposerPubkey: [HashSelector!], stateRootHash: [HashSelector!], validatorIndex: [IntegerSelector!], validatorStatus: [StringSelector!], validatorPubkey: [HashSelector!], eth1DepositRootHash: [HashSelector!], eth1DepositCount: [IntegerSelector!], eth1BlockHash: [HashSelector!], validatorWithdrawalCredentials: [HashSelector!], validatorSlashed: [BooleanSelector!], validatorBalance: [AmountSelector!], validatorBalanceChange: [AmountSelector!], validatorEffectiveBalance: [AmountSelector!], validatorActivationEpoch: [StringSelector!], validatorExitEpoch: [StringSelector!], validatorWithdrawableEpoch: [StringSelector!]): Float!
  """Validator effective balance"""
  validatorEffectiveBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], epoch: [StringSelector!], blockProposerPubkey: [HashSelector!], stateRootHash: [HashSelector!], validatorIndex: [IntegerSelector!], validatorStatus: [StringSelector!], validatorPubkey: [HashSelector!], eth1DepositRootHash: [HashSelector!], eth1DepositCount: [IntegerSelector!], eth1BlockHash: [HashSelector!], validatorWithdrawalCredentials: [HashSelector!], validatorSlashed: [BooleanSelector!], validatorBalance: [AmountSelector!], validatorBalanceChange: [AmountSelector!], validatorEffectiveBalance: [AmountSelector!], validatorActivationEpoch: [StringSelector!], validatorExitEpoch: [StringSelector!], validatorWithdrawableEpoch: [StringSelector!]): Float!
  """Validator exit epoch"""
  validatorExitEpoch: BigInt!
  """Validator Slashed"""
  validatorSlashed: Boolean!
  """Validator Status"""
  validatorStatus: String!
  """Validator withdrawable epoch"""
  validatorWithdrawableEpoch: BigInt!
  """Validator Withdrawal Credentials"""
  validatorWithdrawalCredentials: String!
}

input Ethereum2ValidatorUpdatesFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockRootHash: HashSelector
  blockProposerIndex: [IntegerSelector!]
  epoch: [StringSelector!]
  blockProposerPubkey: [HashSelector!]
  stateRootHash: [HashSelector!]
  validatorIndex: [IntegerSelector!]
  validatorStatus: [StringSelector!]
  validatorPubkey: [HashSelector!]
  eth1DepositRootHash: [HashSelector!]
  eth1DepositCount: [IntegerSelector!]
  eth1BlockHash: [HashSelector!]
  validatorWithdrawalCredentials: [HashSelector!]
  validatorSlashed: [BooleanSelector!]
  validatorBalance: [AmountSelector!]
  validatorBalanceChange: [AmountSelector!]
  validatorEffectiveBalance: [AmountSelector!]
  validatorActivationEpoch: [StringSelector!]
  validatorExitEpoch: [StringSelector!]
  validatorWithdrawableEpoch: [StringSelector!]
}

enum Ethereum2ValidatorUpdatesMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Epoch"""
  epoch
  """Block hash"""
  block_root_hash
  """Parent root hash"""
  parent_root_hash
  """State root hash"""
  state_root_hash
  """Eth1 deposit root hash"""
  eth1_deposit_root_hash
  """Eth1 deposit count"""
  eth1_deposit_count
  """Eth1 block hash"""
  eth1_block_hash
  """Proposer index"""
  proposer_index
  """Proposer pubkey hash"""
  proposer_pubkey_hash
  """Validator index"""
  validator_index
  """Validator pubkey hash"""
  validator_pubkey_hash
  """Validator slashed"""
  validator_slashed
  """Validator balance"""
  validator_balance
  """Validator effective balance"""
  validator_effective_balance
  """Validator balance change"""
  validator_balance_change
  """Validator activation epoch"""
  validator_activation_epoch
  """Validator exit epoch"""
  validator_exit_epoch
  """Validator withdrawable epoch"""
  validator_withdrawable_epoch
}

enum Ethereum2ValidatorUpdatesUniq {
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique proposers"""
  proposers
  """Unique validators"""
  validators
  """Unique epochs"""
  epochs
}

"""Voluntary Exit in Ethereum v2.0 blockchain"""
type Ethereum2VoluntaryExit {
  any(of: Ethereum2VoluntaryExitsMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Block root hash"""
  blockRoot(blockRootHash: [HashSelector!]): String!
  count(uniq: Ethereum2VoluntaryExitsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): Int
  countBigInt(uniq: Ethereum2VoluntaryExitsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockRootHash: HashSelector, blockProposerIndex: [IntegerSelector!], validatorIndex: [IntegerSelector!], voluntaryExitEpoch: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Block Eth1 information"""
  eth1: Ethereum2Eth1Info!
  expression(get: String!): DecimalNumber
  maximum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String
  minimum(of: Ethereum2VoluntaryExitsMeasureable!, get: Ethereum2VoluntaryExitsMeasureable): String
  """Block parent hash"""
  parentRoot: String!
  """Block proposer"""
  proposer(blockProposerIndex: [IntegerSelector!]): Ethereum2ValidatorInfo
  """Signature"""
  signature: String!
  """Block state root hash"""
  stateRoot: String!
  """Validator"""
  validator: Ethereum2ValidatorInfo!
  voluntaryExitEpoch: Int!
  """Voluntary Exit Index (0 based ) in block"""
  voluntaryExitIndex: Int!
}

enum Ethereum2VoluntaryExitsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_root_hash
  """Block Proposer"""
  block_proposer
  """Validator index"""
  validator
}

enum Ethereum2VoluntaryExitsUniq {
  """Unique blocks"""
  blocks
  """Unique block proposers"""
  block_proposers
  """Unique date count"""
  dates
  """Unique validators"""
  validators
}

"""Address that have been active in transfers"""
type EthereumActiveAddress {
  """Transfer address"""
  address: EthereumAddressInfo
  count(uniq: ActiveAddress!, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: ActiveAddress!, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt
}

"""Address detailed information for Ethereum network"""
type EthereumAddressInfo {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Smart Contract if exists on the address"""
  smartContract: EthereumSmartContractInfo
}

"""Blockchain address"""
type EthereumAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """DEPRECATED Current address balance"""
  balance(in: BaseCurrencyEnum): Float
  """DEPRECATED Balances by currencies for the address"""
  balances(date: DateSelector, time: DateTimeSelector, currency: EthereumCurrencySelector, height: BlockSelectorRange): [EthereumBalance!]
  """Smart Contract if exists on the address"""
  smartContract: EthereumSmartContractInfoWithAttributes
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelector {
  """Equal to Address"""
  is: String
  """Not Equal to Address"""
  not: String
  """In the list of Addresses"""
  in: [String!]
  """Not in the list of Addresses"""
  notIn: [String!]
}

"""
Address should start from 0x and contain hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumAddressSelectorIn {
  """Equal to Address"""
  is: String
  """In the list of Addresses"""
  in: [String!]
}

"""
Counts and aggregates for the address, transfer count,
                  amount, number of distinct currencies,
                  times of the first and the last transactions
"""
type EthereumAddressStat {
  """Address"""
  address: Address
  """Balance"""
  balance: BigInt
  """Call Tx Count"""
  callTxCount: BigInt
  """Called Tx Count"""
  calledTxCount: BigInt
  """Days with received"""
  daysWithReceived: BigInt
  """Days with sent"""
  daysWithSent: BigInt
  """Days with transactions"""
  daysWithTransactions: BigInt
  """Days with transfers"""
  daysWithTransfers: BigInt
  """Amount of paid fee"""
  feeAmount: BigInt
  """First transfer at"""
  firstTransferAt: DateTime
  """First tx at"""
  firstTxAt: DateTime
  """Last transfer at"""
  lastTransferAt: DateTime
  """Last tx at"""
  lastTxAt: DateTime
  """Other Tx Count"""
  otherTxCount: BigInt
  """Receive Amount"""
  receiveAmount: BigInt
  """Receive from Count"""
  receiveFromCount: BigInt
  """Receive from currencies"""
  receiveFromCurrencies: BigInt
  """Receive tx Count"""
  receiveTxCount: BigInt
  """Send Amount"""
  sendAmount: BigInt
  """Send to count"""
  sendToCount: BigInt
  """Send to currencies"""
  sendToCurrencies: BigInt
  """Send tx count"""
  sendTxCount: BigInt
}

"""AddressStats"""
type EthereumAddressStats {
  """Address With Statistics"""
  address: EthereumAddressStat
}

input EthereumArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  reference: [EthereumAddressSelector!]
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
  callDepth: StringSelector
}

"""Arguments of Smart Contract Calls and Events"""
type EthereumArguments {
  any(of: EthereumArgumentsMeasureable!, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  """Method or event argument"""
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Caller of the method invocation ( tx sender or another smart contract )"""
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo
  """Counts and other metrics"""
  count(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """External call executed explicitly by tx sender. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  maximum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  minimum(of: EthereumArgumentsMeasureable!, get: EthereumArgumentsMeasureable, as: EthereumArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  number(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Float
  reference(reference: [EthereumAddressSelector!]): EthereumAddressInfo @deprecated(reason: "DEPRECATED! Please use ethereum { references }")
  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
  """Contract method or event"""
  smartContractSignature(smartContractMethod: MethodSelector, smartContractEvent: EventSelector, signatureType: SignatureTypeSelector): Signature
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
  """The Value of method or event argument"""
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum EthereumArgumentsConvertable {
  """Token symbol"""
  token_symbol
  """Token name"""
  token_name
}

enum EthereumArgumentsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Caller"""
  caller
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature"""
  signature_type
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
  """Argument"""
  argument
  """Argument type"""
  argument_type
  """Argument value"""
  argument_value
  """Argument index"""
  argument_index
}

"""Balance in a currency"""
type EthereumBalance {
  """Currency of transfer"""
  currency: Currency
  """History of balance changes by currencies for the address"""
  history: [EthereumBalanceChange!]
  value(in: BaseCurrencyEnum): Float
}

"""Change of balance in a currency"""
type EthereumBalanceChange {
  """Block number (height) in blockchain"""
  block: Int!
  """Block timestamp"""
  timestamp: ISO8601DateTime
  """Transfer amount ( positive inbound, negative outbound)"""
  transferAmount: Float
  value: Float
}

input EthereumBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [EthereumAddressSelector!]
  blockReward: [AmountSelector!]
  transactionCount: [IntegerSelector!]
  uncleCount: [IntegerSelector!]
  size: [IntegerSelector!]
}

"""Blocks in Ethereum blockchain"""
type EthereumBlocks {
  any(of: EthereumBlocksMeasureable!): String
  count(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  countBigInt(uniq: EthereumBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
  """Calendar date"""
  date: Date
  difficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  expression(get: String!): DecimalNumber
  gasLimit(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  gasUsed(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  """Block hash"""
  hash(blockHash: [HashSelector!]): String!
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String
  """Block miner"""
  miner(miner: [EthereumAddressSelector!]): EthereumAddressInfo
  minimum(of: EthereumBlocksMeasureable!, get: EthereumBlocksMeasureable): String
  """Block nonce"""
  nonce: Int!
  """Parent block hash"""
  parentHash: String!
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  """Currency of reward"""
  rewardCurrency: Currency
  size(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalDifficulty(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Float
  transactionCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  transactionCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
  uncleCount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): Int
  uncleCountBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [EthereumAddressSelector!], blockReward: [AmountSelector!], transactionCount: [IntegerSelector!], uncleCount: [IntegerSelector!], size: [IntegerSelector!]): BigInt
}

enum EthereumBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Block Reward"""
  block_reward
  """Block Miner"""
  miner
}

enum EthereumBlocksUniq {
  """Unique miner count"""
  miners
  """Unique date count"""
  dates
}

enum EthereumCallsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Caller"""
  caller
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
}

"""Coinpath"""
type EthereumCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: EthereumCoinpathAddress
  """Sender address"""
  sender: EthereumCoinpathAddress
  """Transaction of transfer happened"""
  transaction: TransactionHashValueTime
  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""Address detailed information for Ethereum network"""
type EthereumCoinpathAddress {
  """Address"""
  address: String
  """"""
  amountIn: DecimalNumber
  """"""
  amountOut: DecimalNumber
  """Annotations ( tags ), if exists"""
  annotation: String
  """"""
  balance: DecimalNumber
  """Smart Contract if exists on the address"""
  firstTxAt: DateTime
  """Smart Contract if exists on the address"""
  lastTxAt: DateTime
  """"""
  receiversCount: Int
  """"""
  sendersCount: Int
  """Smart Contract if exists on the address"""
  smartContract: EthereumSmartContractInfo
  """Address type"""
  type: String
}

"""
Currency selector in Ethereum blockchain.
  Currencies supported are native ( ETH / ETC ), ERC20, ERC721 tokens.
  You can specify currency symbol or smart contract address. Symbols ETH/ETC are reserved for native currencies in Ethereum mainnet and classic.
  Ethereum Smart contract address should start from 0x and contain 40 hex digits.
  If digits are case sensitive, address is checked against checksum according to EIP-55.
"""
input EthereumCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

"""Ethereum DEX attributes"""
type EthereumDex {
  """Address for DEX exchange identification"""
  address: Address!
  """Full name ( name for known, Protocol for unknown )"""
  fullName: String!
  """Full name ( name for known, Protocol / address for unknown )"""
  fullNameWithId: String!
  """Name for known exchanges"""
  name: String
}

input EthereumDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  protocol: [StringSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  exchangeAddress: [EthereumAddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [EthereumCurrencySelector!]
  buyCurrency: [EthereumCurrencySelector!]
  baseCurrency: [EthereumCurrencySelector!]
  quoteCurrency: [EthereumCurrencySelector!]
  maker: [EthereumAddressSelector!]
  makerSmartContractType: [SmartContractTypeSelector!]
  taker: [EthereumAddressSelector!]
  takerSmartContractType: [SmartContractTypeSelector!]
  makerOrTaker: [EthereumAddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

"""Trades on DEX smart contracts"""
type EthereumDexTrades {
  """Trader (maker or taker)"""
  address(makerOrTaker: [EthereumAddressSelector!]): Address
  any(of: EthereumDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Base currency"""
  baseCurrency(baseCurrency: [EthereumCurrencySelector!]): Currency
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Maker buys this currency"""
  buyCurrency(buyCurrency: [EthereumCurrencySelector!]): Currency
  count(uniq: EthereumDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  countBigInt(uniq: EthereumDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt
  """Calendar date"""
  date: Date
  """Identification of admin / manager / factory of smart contract, executing trades"""
  exchange(exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!]): EthereumDex
  expression(get: String!): DecimalNumber
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Trade 'maker' side"""
  maker(maker: [EthereumAddressSelector!]): Address
  maximum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  minimum(of: EthereumDexTradesMeasureable!, get: EthereumDexTradesMeasureable): String
  price(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  """Protocol name of the smart contract"""
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Quote currency"""
  quoteCurrency(quoteCurrency: [EthereumCurrencySelector!]): Currency
  quotePrice(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], protocol: [StringSelector!], smartContractAddress: [EthereumAddressSelector!], exchangeAddress: [EthereumAddressSelector!], exchangeName: [StringSelector!], sellCurrency: [EthereumCurrencySelector!], buyCurrency: [EthereumCurrencySelector!], baseCurrency: [EthereumCurrencySelector!], quoteCurrency: [EthereumCurrencySelector!], maker: [EthereumAddressSelector!], makerSmartContractType: [SmartContractTypeSelector!], taker: [EthereumAddressSelector!], takerSmartContractType: [SmartContractTypeSelector!], makerOrTaker: [EthereumAddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Maker sells this currency"""
  sellCurrency(sellCurrency: [EthereumCurrencySelector!]): Currency
  """Side of trade ( SELL / BUY )"""
  side: TradeSide
  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
  """Trade 'taker' side"""
  taker(taker: [EthereumAddressSelector!]): Address
  """Time interval"""
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float
  """Index of trade in transaction, used to separate trades in transaction"""
  tradeIndex(tradeIndex: [StringSelector!]): String
  """Transaction of DexTrade"""
  transaction(txHash: [HashSelector!], txSender: [EthereumAddressSelector!]): EthereumTransactionInfoExtended
}

enum EthereumDexTradesMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Buy Amount"""
  buy_amount
  """Sell Amount"""
  sell_amount
  """Price"""
  price
  """Quote Price"""
  quote_price
  """Maker"""
  maker
  """Taker"""
  taker
  """Buy Currency symbol"""
  buy_currency_symbol
  """Buy Token address"""
  buy_currency_address
  """Sell Currency symbol"""
  sell_currency_symbol
  """Sell Token address"""
  sell_currency_address
}

enum EthereumDexTradesUniq {
  """Unique TX senders count"""
  senders
  """Unique makers count"""
  makers
  """Unique makers count"""
  takers
  """Unique makers & takers count"""
  address
  """Buy currencies count"""
  buy_currency
  """Sell currencies count"""
  sell_currency
  """Base currencies count"""
  base_currency
  """Quote currencies count"""
  quote_currency
  """Unique blocks"""
  blocks
  """Unique transactions count"""
  txs
  """Unique date count"""
  dates
  """Unique smart contract count"""
  smart_contracts
  """Unique protocols count"""
  protocols
}

enum EthereumEventsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Smart Contract"""
  smart_contract
  """Smart Contract Event Name"""
  signature_name
  """Smart Contract Event Signature"""
  signature
  """Smart Contract Event Signature Hash"""
  signature_hash
}

enum EthereumNetwork {
  """Ethereum Mainnet"""
  ethereum
  """Ethereum Classic"""
  ethclassic
  """Ethereum PoW"""
  ethpow
  """Ethereum Classic ( no reorg from block 10904146)"""
  ethclassic_reorg
  """Celo Alfajores Testnet"""
  celo_alfajores
  """Celo Baklava Testnet"""
  celo_baklava
  """DEPRECATED. Use celo_mainnet"""
  celo_rc1
  """Celo Mainnet"""
  celo_mainnet
  """Binance Smart Chain Mainnet"""
  bsc
  """Binance Smart Chain Testnet"""
  bsc_testnet
  """Goerli Ethereum Testnet"""
  goerli
  """Matic (Polygon) Mainnet"""
  matic
  """Velas Mainnet"""
  velas
  """Velas Testnet"""
  velas_testnet
  """Klaytn Mainnet"""
  klaytn
  """Avalanche C-chain"""
  avalanche
  """Fantom Mainnet"""
  fantom
  """Moonbeam Mainnet"""
  moonbeam
  """Cronos Mainnet"""
  cronos
}

input EthereumReferencesFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  reference: [EthereumAddressSelector!]
  argument: [ArgumentSelector!]
  argumentType: [ArgumentTypeSelector!]
  signatureType: SignatureTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
  callDepth: StringSelector
}

"""Address value of method or event argument"""
type EthereumReferencess {
  any(of: EthereumReferencessMeasureable!, as: EthereumReferencessConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  """Method or event argument"""
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Caller of the method invocation ( tx sender or another smart contract )"""
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo
  """Counts and other metrics"""
  count(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractArgumentsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """External call executed explicitly by tx sender. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  maximum(of: EthereumReferencessMeasureable!, get: EthereumReferencessMeasureable, as: EthereumReferencessConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  minimum(of: EthereumReferencessMeasureable!, get: EthereumReferencessMeasureable, as: EthereumReferencessConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  number(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], reference: [EthereumAddressSelector!], value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: [ArgumentTypeSelector!], signatureType: SignatureTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Float
  """Address value of method or event argument"""
  reference(reference: [EthereumAddressSelector!]): EthereumAddressInfo
  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
  """Contract method or event"""
  smartContractSignature(smartContractMethod: MethodSelector, smartContractEvent: EventSelector, signatureType: SignatureTypeSelector): Signature
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

enum EthereumReferencessConvertable {
  """Token symbol"""
  token_symbol
  """Token name"""
  token_name
}

enum EthereumReferencessMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Caller"""
  caller
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature"""
  signature_type
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
  """Argument type"""
  argument_type
  """Argument value"""
  argument_value
  """Argument index"""
  argument_index
}

"""Ethereum smart contract"""
type EthereumSmartContract {
  """Smart Contract Address"""
  address: Address!
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

input EthereumSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  caller: [EthereumAddressSelector!]
  smartContractAddress: [EthereumAddressSelector!]
  smartContractMethod: MethodSelector
  smartContractType: SmartContractTypeSelector
  external: Boolean
  success: Boolean
  callDepth: StringSelector
}

"""Smart Contract Calls"""
type EthereumSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: Boolean, callDepth: StringSelector): Float
  any(of: EthereumCallsMeasureable!): String
  """Call arguments"""
  arguments: [ArgumentNameValue!]
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Caller of the method invocation ( tx sender or another smart contract )"""
  caller(caller: [EthereumAddressSelector!]): EthereumAddressInfo
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: Boolean, callDepth: StringSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: Boolean, callDepth: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """External call executed explicitly by tx sender. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  """Gas used for transaction in external call, or by methd in internal call"""
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], caller: [EthereumAddressSelector!], smartContractAddress: [EthereumAddressSelector!], smartContractMethod: MethodSelector, smartContractType: SmartContractTypeSelector, external: Boolean, success: Boolean, callDepth: StringSelector): Float
  maximum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String
  minimum(of: EthereumCallsMeasureable!, get: EthereumCallsMeasureable): String
  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Transaction where call happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

"""Smart Contract Events"""
type EthereumSmartContractEvent {
  any(of: EthereumEventsMeasureable!): String
  """Event arguments"""
  arguments: [ArgumentNameValue!]
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], smartContractType: SmartContractTypeSelector, smartContractAddress: [EthereumAddressSelector!], smartContractEvent: EventSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String
  minimum(of: EthereumEventsMeasureable!, get: EthereumEventsMeasureable): String
  """Smart contract being called"""
  smartContract(smartContractAddress: [EthereumAddressSelector!]): EthereumSmartContract
  """Contract event logged"""
  smartContractEvent(smartContractEvent: EventSelector): Event
  """Transaction where event happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

input EthereumSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  smartContractType: SmartContractTypeSelector
  smartContractAddress: [EthereumAddressSelector!]
  smartContractEvent: EventSelector
}

"""Blockchain smart contract"""
type EthereumSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

"""Blockchain smart contract"""
type EthereumSmartContractInfoWithAttributes {
  """Attributes from readonly methods"""
  attributes: [SmartContractReadonlyAttribute!]
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

input EthereumTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txSender: [EthereumAddressSelector!]
  txTo: [EthereumAddressSelector!]
  txCreates: [EthereumAddressSelector!]
  txIndex: TxIndexSelector
  success: Boolean
  amount: [AmountSelector!]
  gasCurrency: [EthereumCurrencySelector!]
  gasValue: [AmountSelector!]
  txType: [StringSelector!]
  feePayer: [StringSelector!]
  feeRatio: TxIndexSelector
}

"""Blockchain transaction info"""
type EthereumTransactionInfo {
  """Gas consumed"""
  gas: Int!
  """Gas price in Gwei"""
  gasPrice: Float!
  """Gas value cost"""
  gasValue: Float!
  """Hash hex representation"""
  hash: String!
  """Transaction from address"""
  txFrom: EthereumAddressInfo!
}

"""Blockchain Transaction Extended info"""
type EthereumTransactionInfoExtended {
  """Gas consumed"""
  gas: Int!
  """Gas price in Gwei"""
  gasPrice: Float!
  """Gas value cost"""
  gasValue: Float!
  """Hash hex representation"""
  hash: String!
  """Transaction index in block, 0 based"""
  index: Int
  """Transaction nonce"""
  nonce: Int
  """Transaction receiver"""
  to: EthereumAddressInfo
  """Transaction from address"""
  txFrom: EthereumAddressInfo!
}

"""Transactions in Ethereum blockchain"""
type EthereumTransactions {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], txType: [StringSelector!], feePayer: [StringSelector!], feeRatio: TxIndexSelector): Float
  any(of: EthereumTransactionsMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], txType: [StringSelector!], feePayer: [StringSelector!], feeRatio: TxIndexSelector): Int
  countBigInt(uniq: EthereumTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], txType: [StringSelector!], feePayer: [StringSelector!], feeRatio: TxIndexSelector): BigInt
  """Created smart contract"""
  creates(txCreates: [EthereumAddressSelector!]): EthereumAddressInfo
  """Currency of amount"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Error message if any"""
  error: String
  expression(get: String!): DecimalNumber
  """Fee payer"""
  feePayer: String
  """Fee ratio"""
  feeRatio: Int
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], txType: [StringSelector!], feePayer: [StringSelector!], feeRatio: TxIndexSelector): Float
  """Currency of gas"""
  gasCurrency(gasCurrency: [EthereumCurrencySelector!]): Currency
  """Gas price in Gwei"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], txType: [StringSelector!], feePayer: [StringSelector!], feeRatio: TxIndexSelector): Float!
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txSender: [EthereumAddressSelector!], txTo: [EthereumAddressSelector!], txCreates: [EthereumAddressSelector!], txIndex: TxIndexSelector, success: Boolean, amount: [AmountSelector!], gasCurrency: [EthereumCurrencySelector!], gasValue: [AmountSelector!], txType: [StringSelector!], feePayer: [StringSelector!], feeRatio: TxIndexSelector): Float
  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!
  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  maximum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String
  minimum(of: EthereumTransactionsMeasureable!, get: EthereumTransactionsMeasureable): String
  """Transaction nonce"""
  nonce: Int
  """Transaction sender"""
  sender(txSender: [EthereumAddressSelector!]): EthereumAddressInfo
  """Success"""
  success(success: Boolean): Boolean
  """Transaction receiver"""
  to(txTo: [EthereumAddressSelector!]): EthereumAddressInfo
  """Transaction type"""
  txType: String
}

enum EthereumTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """Transaction Sender"""
  tx_sender
  """Gas value"""
  gas_value
  """Gas price"""
  gas_price
  """Gas used"""
  gas
  """Transaction type"""
  tx_type
  """Fee payer"""
  fee_payer
  """Fee ratio"""
  fee_ratio
}

enum EthereumTransactionsUniq {
  """Unique TX senders count"""
  senders
  """Unique TX receivers count"""
  receivers
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique TX types count"""
  tx_types
  """Unique fee payers count"""
  fee_payers
  """Unique fee ratios count"""
  fee_ratios
}

input EthereumTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: [EthereumAddressSelector!]
  entityId: EntitySelector
  sender: [EthereumAddressSelector!]
  receiver: [EthereumAddressSelector!]
  currency: [EthereumCurrencySelector!]
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type EthereumTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: EthereumTransfersMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt
  """Currency of transfer"""
  currency(currency: [EthereumCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String
  expression(get: String!): DecimalNumber
  """External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts."""
  external(external: Boolean): Boolean
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: [EthereumAddressSelector!], entityId: EntitySelector, sender: [EthereumAddressSelector!], receiver: [EthereumAddressSelector!], currency: [EthereumCurrencySelector!], external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String
  minimum(of: EthereumTransfersMeasureable!, get: EthereumTransfersMeasureable): String
  """Transfer receiver"""
  receiver(receiver: [EthereumAddressSelector!]): EthereumAddressInfo
  """Transfer sender"""
  sender(sender: [EthereumAddressSelector!]): EthereumAddressInfo
  """Success flag"""
  success(success: Boolean): Boolean
  """Transaction where transfer happened"""
  transaction(txHash: [HashSelector!], txFrom: [EthereumAddressSelector!]): EthereumTransactionInfo
}

enum EthereumTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency symbol"""
  currency_symbol
  """Token address"""
  currency_address
  """Entity ID"""
  entity_id
}

"""Smart contract event"""
type Event {
  """Name"""
  name: String
  """Signature"""
  signature: String
  """Signature Hash"""
  signatureHash: String!
}

"""Smart contract event. In selector you can use the name, signature or hex hash"""
input EventSelector {
  """Event signature is"""
  is: String
  """Event signature not"""
  not: String
  """Event signature in the list"""
  in: [String!]
  """Event signature not in the list"""
  notIn: [String!]
}

enum EventType {
  """Transaction"""
  transaction
  """Call Result"""
  call_result
}

"""Select by event type"""
input EventTypeSelector {
  """Eventy type is"""
  is: EventType
  """Eventy type not"""
  not: EventType
  """Eventy type in the list"""
  in: [EventType!]
  """Eventy type not in the list"""
  notIn: [EventType!]
}

"""Everscale Chain"""
type Everscale {
  """Information about address"""
  address(address: [AddressSelectorIn!]!): [EverscaleAddressInfo!]!
  """Everscale Arguments"""
  arguments(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, argumentType: EverscaleArgumentTypeSelector, argumentIndex: IntegerSelector, argumentField: StringSelector, argumentValue: StringSelector, any: [EverscaleArgumentFilter!], options: QueryOptions): [EverscaleArgument!]
  """Everscale Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txCount: IntegerSelector, status: IntegerSelector, globalId: IntegerSelector, logicalTimeStart: BigIntegerSelector, logicalTimeEnd: BigIntegerSelector, version: BigIntegerSelector, afterMerge: BooleanSelector, afterSplit: BooleanSelector, beforeSplit: BooleanSelector, wantMerge: BooleanSelector, wantSplit: BooleanSelector, verticalSeqNo: BigIntegerSelector, minimalReferenceMasterchainBlock: BigIntegerSelector, catchainSeqno: IntegerSelector, validatorListHastShort: IntegerSelector, softwareVersion: IntegerSelector, softwareCapabilities: StringSelector, valueFlowFromPreviousBlock: BigIntegerSelector, valueFlowToNextBlock: BigIntegerSelector, valueFlowImported: BigIntegerSelector, valueFlowExported: BigIntegerSelector, valueFlowFeesCollected: BigIntegerSelector, valueFlowFeesImported: BigIntegerSelector, valueFlowCreated: BigIntegerSelector, valueFlowMinted: BigIntegerSelector, any: [EverscaleBlockFilter!], options: QueryOptions): [EverscaleBlock!]
  """Everscale Calls"""
  calls(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, any: [EverscaleCallFilter!], options: QueryOptions): [EverscaleCall!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: CurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [EverscaleCoinpath!]
  """Everscale Events"""
  events(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, any: [EverscaleEventFilter!], options: QueryOptions): [EverscaleEvent!]
  """Everscale Messages"""
  messages(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageIndex: IntegerSelector, messageSender: StringSelector, messageReceiver: StringSelector, messageValue: FloatSelector, messageCreatedLogicalTime: BigIntegerSelector, messageIhrDisabled: BooleanSelector, messageIrbFee: FloatSelector, messageFwdFee: FloatSelector, messageBounce: BooleanSelector, messageBounced: BooleanSelector, messageBody: StringSelector, messageBodyHash: StringSelector, messageData: StringSelector, messageDataHash: StringSelector, messageBoc: StringSelector, any: [EverscaleMessageFilter!], options: QueryOptions): [EverscaleMessage!]
  """Everscale Phases"""
  phases(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, phaseType: StringSelector, phaseFee: FloatSelector, phaseData: StringSelector, any: [EverscalePhaseFilter!], options: QueryOptions): [EverscalePhase!]
  """Everscale Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txLogicalTime: IntegerSelector, txType: IntegerSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, txInMessageBounceFlag: BooleanSelector, txAccount: StringSelector, txAborted: BooleanSelector, txDestroyed: BooleanSelector, txOldHash: StringSelector, txNewHash: StringSelector, txOutMessagesCount: IntegerSelector, txAccountFees: FloatSelector, txExtInAndIhrInFees: FloatSelector, txCreditFirst: BooleanSelector, previousTxHash: StringSelector, previousTxLogicalTime: BigIntegerSelector, any: [EverscaleTransactionFilter!], options: QueryOptions): [EverscaleTransaction!]
  """Everscale Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, currency: CurrencySelector, transferSender: StringSelector, transferReceiver: StringSelector, entityId: BigIntIdSelector, transferType: EverscaleTransferTypeSelector, any: [EverscaleTransferFilter!], options: QueryOptions): [EverscaleTransfer!]
}

enum EverscaleAccountStateEnum {
  """The account`s code and data have been initialized as well."""
  Active
  """Initialized account."""
  NonExist
  """The account only has a balance; its code and data have not yet been initialized."""
  Uninit
  """The account`s code and data have been replaced by a hash, but the balance is still stored explicitly. The balance of a frozen account."""
  Frozen
}

"""Select by account state"""
input EverscaleAccountStateSelector {
  """Account state is"""
  is: EverscaleAccountStateEnum
  """Account state not"""
  not: EverscaleAccountStateEnum
  """Account state in the list"""
  in: [EverscaleAccountStateEnum!]
  """Account state not in the list"""
  notIn: [EverscaleAccountStateEnum!]
}

"""Address balance information for Everscale network"""
type EverscaleAddressBalance {
  """Currency"""
  currency: Currency
  value(in: BaseCurrencyEnum): Float
}

"""Address detailed information for Everscale network"""
type EverscaleAddressInfo {
  """Address"""
  address: Address
  """Current address balances"""
  balance: [EverscaleAddressBalance!]
}

"""Argument in Everscale blockchain"""
type EverscaleArgument {
  any(of: EverscaleArgumentMeasurable!): String
  """Hash of the the block"""
  blockHash: String
  """Shard number of block"""
  blockShard: String
  """Proposer block hash"""
  blockWorkchain: BigInt
  count(uniq: EverscaleArgumentUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, argumentType: EverscaleArgumentTypeSelector, argumentIndex: IntegerSelector, argumentField: StringSelector, argumentValue: StringSelector): Int
  countBigInt(uniq: EverscaleArgumentUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, argumentType: EverscaleArgumentTypeSelector, argumentIndex: IntegerSelector, argumentField: StringSelector, argumentValue: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Argument Field"""
  field: String
  """Number of block in the blockchains"""
  height: BigInt
  """Argument Index"""
  index: Int
  maximum(of: EverscaleArgumentMeasurable!, get: EverscaleArgumentMeasurable): String
  """messages"""
  messages(messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector): EverscaleMessageDimension
  minimum(of: EverscaleArgumentMeasurable!, get: EverscaleArgumentMeasurable): String
  """Previous Block"""
  previousBlock: BigInt
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """Timestamp"""
  timestamp: DateTime
  """Transactions"""
  transactions(txHash: HashSelector, txType: StringSelector, txAccount: AddressSelector, txAborted: BigIntIdSelector): EverscaleTransactionDimension
  """Argument Type"""
  type: String
  """Argument Vlaue"""
  value: String
}

input EverscaleArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  argumentType: EverscaleArgumentTypeSelector
  argumentIndex: IntegerSelector
  argumentField: StringSelector
  argumentValue: StringSelector
}

enum EverscaleArgumentMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Message"""
  previous_block
  """Tx Hash"""
  tx_hash
  """Tx Type"""
  tx_type
  """Tx Account"""
  tx_account
  """Tx Aborted"""
  tx_aborted
  """Message Hash"""
  message_hash
  """Message type name"""
  message_type_name
  """Message direction"""
  message_direction
  """Message sender"""
  message_sender
  """Message receiver"""
  message_receiver
  """Message value"""
  message_value
  """Signature"""
  signature
  """Signature Name"""
  signature_name
  """Signature Hash"""
  signature_hash
}

enum EverscaleArgumentTypeEnum {
  """Argument of call"""
  call
  """Argument of event"""
  event
}

"""Select by argument type"""
input EverscaleArgumentTypeSelector {
  """Argument type is"""
  is: EverscaleArgumentTypeEnum
  """Argument type not"""
  not: EverscaleArgumentTypeEnum
  """Argument type in the list"""
  in: [EverscaleArgumentTypeEnum!]
  """Argument type not in the list"""
  notIn: [EverscaleArgumentTypeEnum!]
}

enum EverscaleArgumentUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
  """Unique Number of transactions"""
  txs
  """Unique Number of messages"""
  messages
  """Unique Number of smart contracts"""
  smart_contracts
  """Unique Number of signatures"""
  smart_contract_methods
}

"""Block in Everscale blockchain"""
type EverscaleBlock {
  """After Merge"""
  afterMerge: Boolean
  """After Split"""
  afterSplit: Boolean
  any(of: EverscaleBlockMeasurable!): String
  """Before Split"""
  beforeSplit: Boolean
  """Boc"""
  boc: String
  count(uniq: EverscaleBlockUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txCount: IntegerSelector, status: IntegerSelector, globalId: IntegerSelector, logicalTimeStart: BigIntegerSelector, logicalTimeEnd: BigIntegerSelector, version: BigIntegerSelector, afterMerge: BooleanSelector, afterSplit: BooleanSelector, beforeSplit: BooleanSelector, wantMerge: BooleanSelector, wantSplit: BooleanSelector, verticalSeqNo: BigIntegerSelector, minimalReferenceMasterchainBlock: BigIntegerSelector, catchainSeqno: IntegerSelector, validatorListHastShort: IntegerSelector, softwareVersion: IntegerSelector, softwareCapabilities: StringSelector, valueFlowFromPreviousBlock: BigIntegerSelector, valueFlowToNextBlock: BigIntegerSelector, valueFlowImported: BigIntegerSelector, valueFlowExported: BigIntegerSelector, valueFlowFeesCollected: BigIntegerSelector, valueFlowFeesImported: BigIntegerSelector, valueFlowCreated: BigIntegerSelector, valueFlowMinted: BigIntegerSelector): Int
  countBigInt(uniq: EverscaleBlockUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txCount: IntegerSelector, status: IntegerSelector, globalId: IntegerSelector, logicalTimeStart: BigIntegerSelector, logicalTimeEnd: BigIntegerSelector, version: BigIntegerSelector, afterMerge: BooleanSelector, afterSplit: BooleanSelector, beforeSplit: BooleanSelector, wantMerge: BooleanSelector, wantSplit: BooleanSelector, verticalSeqNo: BigIntegerSelector, minimalReferenceMasterchainBlock: BigIntegerSelector, catchainSeqno: IntegerSelector, validatorListHastShort: IntegerSelector, softwareVersion: IntegerSelector, softwareCapabilities: StringSelector, valueFlowFromPreviousBlock: BigIntegerSelector, valueFlowToNextBlock: BigIntegerSelector, valueFlowImported: BigIntegerSelector, valueFlowExported: BigIntegerSelector, valueFlowFeesCollected: BigIntegerSelector, valueFlowFeesImported: BigIntegerSelector, valueFlowCreated: BigIntegerSelector, valueFlowMinted: BigIntegerSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Information about block general"""
  general(catchainSeqno: IntegerSelector, validatorListHastShort: IntegerSelector, softwareVersion: IntegerSelector, softwareCapabilities: StringSelector): EverscaleGeneralDimension
  """Global Id"""
  globalId: Int
  """Hash of the the block"""
  hash: String
  """Number of block in the blockchains"""
  height: BigInt
  """Logical Time end"""
  logicalTimeEnd: BigInt
  """Logical Time Start"""
  logicalTimeStart: BigInt
  maximum(of: EverscaleBlockMeasurable!, get: EverscaleBlockMeasurable): String
  """Minimal Reference Masterchain Block"""
  minimalReferenceMasterchainBlock: BigInt
  minimum(of: EverscaleBlockMeasurable!, get: EverscaleBlockMeasurable): String
  """Previous Block"""
  previousBlock: BigInt
  """Random Seed"""
  randomSeed: String
  """Shard number of block"""
  shard: String
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """Status"""
  status: Int
  """Timestamp"""
  timestamp: DateTime
  """Tx Count"""
  txCount: BigInt
  value(valueFlowFromPreviousBlock: BigIntegerSelector, valueFlowToNextBlock: BigIntegerSelector, valueFlowImported: BigIntegerSelector, valueFlowExported: BigIntegerSelector, valueFlowFeesCollected: BigIntegerSelector, valueFlowFeesImported: BigIntegerSelector, valueFlowCreated: BigIntegerSelector, valueFlowMinted: BigIntegerSelector): EverscaleValueDimension
  """Version"""
  version: BigInt
  """Vertical Sequence"""
  verticalSeqNo: BigInt
  """Want Merge"""
  wantMerge: Boolean
  """Want Split"""
  wantSplit: Boolean
  """Proposer block hash"""
  workchain: BigInt
}

input EverscaleBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txCount: IntegerSelector
  status: IntegerSelector
  globalId: IntegerSelector
  logicalTimeStart: BigIntegerSelector
  logicalTimeEnd: BigIntegerSelector
  version: BigIntegerSelector
  afterMerge: BooleanSelector
  afterSplit: BooleanSelector
  beforeSplit: BooleanSelector
  wantMerge: BooleanSelector
  wantSplit: BooleanSelector
  verticalSeqNo: BigIntegerSelector
  minimalReferenceMasterchainBlock: BigIntegerSelector
  catchainSeqno: IntegerSelector
  validatorListHastShort: IntegerSelector
  softwareVersion: IntegerSelector
  softwareCapabilities: StringSelector
  valueFlowFromPreviousBlock: BigIntegerSelector
  valueFlowToNextBlock: BigIntegerSelector
  valueFlowImported: BigIntegerSelector
  valueFlowExported: BigIntegerSelector
  valueFlowFeesCollected: BigIntegerSelector
  valueFlowFeesImported: BigIntegerSelector
  valueFlowCreated: BigIntegerSelector
  valueFlowMinted: BigIntegerSelector
}

enum EverscaleBlockMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Block"""
  previous_block
  """Count of transactions in this block"""
  tx_count
  """Status"""
  status
  """Global ID"""
  global_id
  """Logical Time Start"""
  logical_time_start
  """Logical Time End"""
  logical_time_end
  """Version"""
  version
  """After Merge"""
  after_merge
  """After Split"""
  after_split
  """Before Split"""
  before_split
  """Want Merge"""
  want_merge
  """Want Split"""
  want_split
  """Vertical Sequence"""
  vertical_seq_no
  """Minimal Reference Masterchain Block"""
  minimal_reference_masterchain_block
  """Value From Previous Block"""
  value_flow_from_previous_block
  """Value To Previous Block"""
  value_flow_to_previous_block
  """Value Imported"""
  value_flow_imported
  """Value Exported"""
  value_flow_exported
  """Value Fees collected"""
  value_flow_fees_collected
  """Value Fees imported"""
  value_flow_fees_imported
  """Value created"""
  value_flow_created
  """Value minted"""
  value_flow_minted
}

enum EverscaleBlockUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
}

"""Call in Everscale blockchain"""
type EverscaleCall {
  any(of: EverscaleCallMeasurable!): String
  """Hash of the the block"""
  blockHash: String
  """Shard number of block"""
  blockShard: String
  """Proposer block hash"""
  blockWorkchain: BigInt
  count(uniq: EverscaleCallUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector): Int
  countBigInt(uniq: EverscaleCallUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Number of block in the blockchains"""
  height: BigInt
  maximum(of: EverscaleCallMeasurable!, get: EverscaleCallMeasurable): String
  """messages"""
  messages(messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector): EverscaleMessageDimension
  minimum(of: EverscaleCallMeasurable!, get: EverscaleCallMeasurable): String
  """Previous Block"""
  previousBlock: BigInt
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """Timestamp"""
  timestamp: DateTime
  """Transactions"""
  transactions(txHash: HashSelector, txType: StringSelector, txAccount: AddressSelector, txAborted: BigIntIdSelector): EverscaleTransactionDimension
}

input EverscaleCallFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
}

enum EverscaleCallMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Message"""
  previous_block
  """Tx Hash"""
  tx_hash
  """Tx Type"""
  tx_type
  """Tx Account"""
  tx_account
  """Tx Aborted"""
  tx_aborted
  """Message Hash"""
  message_hash
  """Message type name"""
  message_type_name
  """Message direction"""
  message_direction
  """Message sender"""
  message_sender
  """Message receiver"""
  message_receiver
  """Message value"""
  message_value
  """Signature"""
  signature
  """Signature Name"""
  signature_name
  """Signature Hash"""
  signature_hash
}

enum EverscaleCallUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
  """Unique Number of transactions"""
  txs
  """Unique Number of messages"""
  messages
  """Unique Number of smart contracts"""
  smart_contracts
  """Unique Number of signatures"""
  smart_contract_methods
}

"""Everscale Coinpath"""
type EverscaleCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: EverscaleCoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: EverscaleCoinpathMeasureable!, get: EverscaleCoinpathMeasureable): String
  minimum(of: EverscaleCoinpathMeasureable!, get: EverscaleCoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Transaction of transfer happened"""
  transaction: TransactionHashValueTime
}

enum EverscaleCoinpathMeasureable {
  """Time"""
  time
  """Block"""
  block
  """Version"""
  tx_hash
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Depth"""
  depth
}

"""Event in Everscale blockchain"""
type EverscaleEvent {
  any(of: EverscaleEventMeasurable!): String
  """Hash of the the block"""
  blockHash: String
  """Shard number of block"""
  blockShard: String
  """Proposer block hash"""
  blockWorkchain: BigInt
  count(uniq: EverscaleEventUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector): Int
  countBigInt(uniq: EverscaleEventUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Number of block in the blockchains"""
  height: BigInt
  maximum(of: EverscaleEventMeasurable!, get: EverscaleEventMeasurable): String
  """messages"""
  messages(messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector): EverscaleMessageDimension
  minimum(of: EverscaleEventMeasurable!, get: EverscaleEventMeasurable): String
  """Previous Block"""
  previousBlock: BigInt
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """Timestamp"""
  timestamp: DateTime
  """Transactions"""
  transactions(txHash: HashSelector, txType: StringSelector, txAccount: AddressSelector, txAborted: BigIntIdSelector): EverscaleTransactionDimension
}

input EverscaleEventFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
}

enum EverscaleEventMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Message"""
  previous_block
  """Tx Hash"""
  tx_hash
  """Tx Type"""
  tx_type
  """Tx Account"""
  tx_account
  """Tx Aborted"""
  tx_aborted
  """Message Hash"""
  message_hash
  """Message type name"""
  message_type_name
  """Message direction"""
  message_direction
  """Message sender"""
  message_sender
  """Message receiver"""
  message_receiver
  """Message value"""
  message_value
  """Signature"""
  signature
  """Signature Name"""
  signature_name
  """Signature Hash"""
  signature_hash
}

enum EverscaleEventUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
  """Unique Number of transactions"""
  txs
  """Unique Number of messages"""
  messages
  """Unique Number of smart contracts"""
  smart_contracts
  """Unique Number of signatures"""
  smart_contract_methods
}

"""General Block information"""
type EverscaleGeneralDimension {
  """Catchain Sequence"""
  catchainSeqno: BigInt
  """Software capabilities"""
  softwareCapabilities: String
  """Software version"""
  softwareVersion: BigInt
  """Validator List Hast Short"""
  validatorListHashShort: BigInt
}

"""Message in Everscale blockchain"""
type EverscaleMessage {
  any(of: EverscaleMessageMeasurable!): String
  """Hash of the the block"""
  blockHash: String
  """Shard number of block"""
  blockShard: String
  """Proposer block hash"""
  blockWorkchain: BigInt
  """Message boc"""
  boc: String
  """Message body"""
  body: String
  """Message body hash"""
  bodyHash: String
  """Message Bounce"""
  bounce: Boolean
  """Message bounced"""
  bounced: Boolean
  count(uniq: EverscaleMessageUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageIndex: IntegerSelector, messageSender: StringSelector, messageReceiver: StringSelector, messageValue: FloatSelector, messageCreatedLogicalTime: BigIntegerSelector, messageIhrDisabled: BooleanSelector, messageIrbFee: FloatSelector, messageFwdFee: FloatSelector, messageBounce: BooleanSelector, messageBounced: BooleanSelector, messageBody: StringSelector, messageBodyHash: StringSelector, messageData: StringSelector, messageDataHash: StringSelector, messageBoc: StringSelector): Int
  countBigInt(uniq: EverscaleMessageUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageIndex: IntegerSelector, messageSender: StringSelector, messageReceiver: StringSelector, messageValue: FloatSelector, messageCreatedLogicalTime: BigIntegerSelector, messageIhrDisabled: BooleanSelector, messageIrbFee: FloatSelector, messageFwdFee: FloatSelector, messageBounce: BooleanSelector, messageBounced: BooleanSelector, messageBody: StringSelector, messageBodyHash: StringSelector, messageData: StringSelector, messageDataHash: StringSelector, messageBoc: StringSelector): BigInt
  """Message created logical time"""
  createdLogicalTime: BigInt
  """Message data"""
  data: String
  """Message data hash"""
  dataHash: String
  """Calendar date"""
  date: Date
  """Message Direction"""
  direction: String
  expression(get: String!): DecimalNumber
  """Message fwd fee"""
  fwdFee: Float
  """Message Hash"""
  hash: String
  """Number of block in the blockchains"""
  height: BigInt
  """Message ihr disabled"""
  ihrDisabled: Boolean
  """Message ihr fee"""
  ihrFee: Float
  """Message index"""
  index: Int
  maximum(of: EverscaleMessageMeasurable!, get: EverscaleMessageMeasurable): String
  minimum(of: EverscaleMessageMeasurable!, get: EverscaleMessageMeasurable): String
  """Previous Block"""
  previousBlock: BigInt
  """Message receiver"""
  receiver: Address
  """Message sender"""
  sender: Address
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """Timestamp"""
  timestamp: DateTime
  """Transactions"""
  transactions(txHash: HashSelector, txType: StringSelector, txAccount: AddressSelector, txAborted: BigIntIdSelector): EverscaleTransactionDimension
  """Message Type Name"""
  typeName: String
  value(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageIndex: IntegerSelector, messageSender: StringSelector, messageReceiver: StringSelector, messageValue: FloatSelector, messageCreatedLogicalTime: BigIntegerSelector, messageIhrDisabled: BooleanSelector, messageIrbFee: FloatSelector, messageFwdFee: FloatSelector, messageBounce: BooleanSelector, messageBounced: BooleanSelector, messageBody: StringSelector, messageBodyHash: StringSelector, messageData: StringSelector, messageDataHash: StringSelector, messageBoc: StringSelector): Float
}

"""Information about message"""
type EverscaleMessageDimension {
  """Message Direction"""
  direction: String
  """Message Hash"""
  hash: String
  """Message Receiver"""
  receiver: Address
  """Message Sender"""
  sender: Address
  """Message Type"""
  typeName: String
  """Message value"""
  value: Float
}

enum EverscaleMessageDirectionEnum {
  """Inbound message"""
  in
  """Outbound Message"""
  out
}

"""Select by message direction"""
input EverscaleMessageDirectionSelector {
  """Message Direction is"""
  is: EverscaleMessageDirectionEnum
  """Message Direction not"""
  not: EverscaleMessageDirectionEnum
  """Message Direction in the list"""
  in: [EverscaleMessageDirectionEnum!]
  """Message Direction not in the list"""
  notIn: [EverscaleMessageDirectionEnum!]
}

input EverscaleMessageFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageIndex: IntegerSelector
  messageSender: StringSelector
  messageReceiver: StringSelector
  messageValue: FloatSelector
  messageCreatedLogicalTime: BigIntegerSelector
  messageIhrDisabled: BooleanSelector
  messageIrbFee: FloatSelector
  messageFwdFee: FloatSelector
  messageBounce: BooleanSelector
  messageBounced: BooleanSelector
  messageBody: StringSelector
  messageBodyHash: StringSelector
  messageData: StringSelector
  messageDataHash: StringSelector
  messageBoc: StringSelector
}

enum EverscaleMessageMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Message"""
  previous_block
  """Tx Hash"""
  tx_hash
  """Tx Type"""
  tx_type
  """Tx Account"""
  tx_account
  """Message Hash"""
  message_hash
  """Message Type Name"""
  message_type_name
  """Message direction"""
  message_direction
  """Message Index"""
  message_index
  """Message sender"""
  message_sender
  """Message receiver"""
  message_receiver
  """Message value"""
  message_value
  """Message created logical time"""
  created_logical_time
  """Message Ihr Disabled"""
  ihr_disabled
  """Message ihr fee"""
  ihr_fee
  """Message fwd fee"""
  fwd_fee
  """Message bounce"""
  bounce
  """Message bounced"""
  bounced
  """Message body"""
  body
  """Message body hash"""
  body_hash
  """Message data"""
  data
  """Message data hash"""
  data_hash
  """Message boc"""
  boc
}

enum EverscaleMessageTypeNameEnum {
  """Internal Message"""
  Internal
  """ExtInt Message"""
  ExtInt
  """ExtOut Message"""
  ExtOut
}

"""Select by message type name"""
input EverscaleMessageTypeNameSelector {
  """Message type name is"""
  is: EverscaleMessageTypeNameEnum
  """Message type name not"""
  not: EverscaleMessageTypeNameEnum
  """Message type name in the list"""
  in: [EverscaleMessageTypeNameEnum!]
  """Message type name not in the list"""
  notIn: [EverscaleMessageTypeNameEnum!]
}

enum EverscaleMessageUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
  """Unique Number of transactions"""
  txs
  """Unique Number of Messages"""
  messages
  """Unique Number of Message Receivers"""
  message_receiver
  """Unique Number of Message Senders"""
  message_sender
}

enum EverscaleNetwork {
  """Everscale"""
  everscale
}

"""Phase in Everscale blockchain"""
type EverscalePhase {
  any(of: EverscalePhaseMeasurable!): String
  """Hash of the the block"""
  blockHash: String
  """Shard number of block"""
  blockShard: String
  """Proposer block hash"""
  blockWorkchain: BigInt
  count(uniq: EverscalePhaseUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, phaseType: StringSelector, phaseFee: FloatSelector, phaseData: StringSelector): Int
  countBigInt(uniq: EverscalePhaseUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, phaseType: StringSelector, phaseFee: FloatSelector, phaseData: StringSelector): BigInt
  """Phase data"""
  data: String
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, phaseType: StringSelector, phaseFee: FloatSelector, phaseData: StringSelector): Float
  """Number of block in the blockchains"""
  height: BigInt
  maximum(of: EverscalePhaseMeasurable!, get: EverscalePhaseMeasurable): String
  minimum(of: EverscalePhaseMeasurable!, get: EverscalePhaseMeasurable): String
  """Previous Block"""
  previousBlock: BigInt
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """Timestamp"""
  timestamp: DateTime
  """Transactions"""
  transactions(txHash: HashSelector, txType: StringSelector, txAccount: AddressSelector, txAborted: BigIntIdSelector): EverscaleTransactionDimension
  """Phase Type"""
  type: String
}

input EverscalePhaseFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  phaseType: StringSelector
  phaseFee: FloatSelector
  phaseData: StringSelector
}

enum EverscalePhaseMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Message"""
  previous_block
  """Tx Hash"""
  tx_hash
  """Tx Type"""
  tx_type
  """Tx Account"""
  tx_account
  """Phase type"""
  phase_type
  """Phase data"""
  phase_data
  """Phase fee"""
  phase_fee
}

enum EverscalePhaseUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
  """Unique Number of transactions"""
  txs
  """Unique Number of phases"""
  phases
}

"""Information about sharded block"""
type EverscaleShardedBlockDimension {
  """Hash of the the master block"""
  hash: String
  """Number of master block in the blockchains"""
  height: BigInt
  """Shard master number of block"""
  shard: String
  """Workchain master block hash"""
  workchain: BigInt
}

"""Transaction in Everscale blockchain"""
type EverscaleTransaction {
  """Transaction Aborted"""
  aborted: Boolean
  """Transaction Account"""
  account: String
  accountFees(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txLogicalTime: IntegerSelector, txType: IntegerSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, txInMessageBounceFlag: BooleanSelector, txAccount: StringSelector, txAborted: BooleanSelector, txDestroyed: BooleanSelector, txOldHash: StringSelector, txNewHash: StringSelector, txOutMessagesCount: IntegerSelector, txAccountFees: FloatSelector, txExtInAndIhrInFees: FloatSelector, txCreditFirst: BooleanSelector, previousTxHash: StringSelector, previousTxLogicalTime: BigIntegerSelector): Float
  any(of: EverscaleTransactionMeasurable!): String
  """Hash of the the block"""
  blockHash: String
  """Shard number of block"""
  blockShard: String
  """Proposer block hash"""
  blockWorkchain: BigInt
  """Transaction Boc"""
  boc: String
  count(uniq: EverscaleTransactionUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txLogicalTime: IntegerSelector, txType: IntegerSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, txInMessageBounceFlag: BooleanSelector, txAccount: StringSelector, txAborted: BooleanSelector, txDestroyed: BooleanSelector, txOldHash: StringSelector, txNewHash: StringSelector, txOutMessagesCount: IntegerSelector, txAccountFees: FloatSelector, txExtInAndIhrInFees: FloatSelector, txCreditFirst: BooleanSelector, previousTxHash: StringSelector, previousTxLogicalTime: BigIntegerSelector): Int
  countBigInt(uniq: EverscaleTransactionUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txLogicalTime: IntegerSelector, txType: IntegerSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, txInMessageBounceFlag: BooleanSelector, txAccount: StringSelector, txAborted: BooleanSelector, txDestroyed: BooleanSelector, txOldHash: StringSelector, txNewHash: StringSelector, txOutMessagesCount: IntegerSelector, txAccountFees: FloatSelector, txExtInAndIhrInFees: FloatSelector, txCreditFirst: BooleanSelector, previousTxHash: StringSelector, previousTxLogicalTime: BigIntegerSelector): BigInt
  """Transaction Credit First"""
  creditFirst: Int
  """Calendar date"""
  date: Date
  """Transaction Destroyed"""
  destroyed: Boolean
  """The end state of an account after a transaction"""
  endStatus: String
  expression(get: String!): DecimalNumber
  """Tx Ext In And Ihr In Fees"""
  extInAndIhrInFees: Float
  """Transaction Hash"""
  hash: String
  """Number of block in the blockchains"""
  height: BigInt
  """Internal Message bounce flag"""
  inMessageBounceFlag: Boolean
  """Transaction Logical Time"""
  logicalTime: BigInt
  maximum(of: EverscaleTransactionMeasurable!, get: EverscaleTransactionMeasurable): String
  minimum(of: EverscaleTransactionMeasurable!, get: EverscaleTransactionMeasurable): String
  """Transaction New Hash"""
  newHash: String
  """Transaction Old Hash"""
  oldHash: String
  """The initial state of account"""
  originalStatus: String
  """Transaction Out Messages count"""
  outMessagesCount: Int
  """Previous Block"""
  previousBlock: BigInt
  """Transaction Out Messages count"""
  previousTxHash: String
  """Transaction Previous Tx Logical Time"""
  previousTxLogicalTime: BigInt
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """Timestamp"""
  timestamp: DateTime
  """Transaction Type"""
  type: String
}

"""Information about transaction"""
type EverscaleTransactionDimension {
  """Transaction Aborted"""
  aborted: Boolean
  """Transaction Account"""
  account: String
  """The end state of an account after a transaction"""
  endStatus: String
  """Transaction Hash"""
  hash: String
  """The initial state of account"""
  originalStatus: String
  """Transaction Type"""
  type: String
}

input EverscaleTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txLogicalTime: IntegerSelector
  txType: IntegerSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  txInMessageBounceFlag: BooleanSelector
  txAccount: StringSelector
  txAborted: BooleanSelector
  txDestroyed: BooleanSelector
  txOldHash: StringSelector
  txNewHash: StringSelector
  txOutMessagesCount: IntegerSelector
  txAccountFees: FloatSelector
  txExtInAndIhrInFees: FloatSelector
  txCreditFirst: BooleanSelector
  previousTxHash: StringSelector
  previousTxLogicalTime: BigIntegerSelector
}

enum EverscaleTransactionMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Transaction"""
  previous_block
  """Tx Hash"""
  tx_hash
  """Tx Type"""
  tx_type
  """Tx Account"""
  tx_account
  """Tx Old hash"""
  tx_old_hash
  """Tx New Hash"""
  tx_new_hash
  """Previous Tx Hash"""
  previous_tx_hash
  """Previous Tx Logical Time"""
  previous_tx_logical_time
}

enum EverscaleTransactionUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
  """Unique Number of Transactions"""
  txs
}

"""Transfer in Everscale blockchain"""
type EverscaleTransfer {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, currency: CurrencySelector, transferSender: StringSelector, transferReceiver: StringSelector, entityId: BigIntIdSelector, transferType: EverscaleTransferTypeSelector): Float
  """Input value as decimal"""
  amountDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, currency: CurrencySelector, transferSender: StringSelector, transferReceiver: StringSelector, entityId: BigIntIdSelector, transferType: EverscaleTransferTypeSelector): DecimalNumberAsDiv
  any(of: EverscaleTransferMeasurable!): String
  """Hash of the the block"""
  blockHash: String
  """Shard number of block"""
  blockShard: String
  """Proposer block hash"""
  blockWorkchain: BigInt
  count(uniq: EverscaleTransferUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, currency: CurrencySelector, transferSender: StringSelector, transferReceiver: StringSelector, entityId: BigIntIdSelector, transferType: EverscaleTransferTypeSelector): Int
  countBigInt(uniq: EverscaleTransferUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, blockHeight: BlockSelector, blockShard: BigIntIdSelector, blockWorkchain: BigIntIdSelector, shardedHeight: BlockSelector, shardedBlockHash: HashSelector, shardedBlockShard: BigIntIdSelector, shardedBlockWorkchain: BigIntIdSelector, previousBlock: BlockSelector, txHash: StringSelector, txType: IntegerSelector, txAccount: StringSelector, txAborted: StringSelector, txOriginalStatus: EverscaleAccountStateSelector, txEndStatus: EverscaleAccountStateSelector, messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector, currency: CurrencySelector, transferSender: StringSelector, transferReceiver: StringSelector, entityId: BigIntIdSelector, transferType: EverscaleTransferTypeSelector): BigInt
  """Currency of transfer"""
  currency: Currency
  """Calendar date"""
  date: Date
  """NFT Id"""
  entityId: BigInt!
  expression(get: String!): DecimalNumber
  """Number of block in the blockchains"""
  height: BigInt
  maximum(of: EverscaleTransferMeasurable!, get: EverscaleTransferMeasurable): String
  """messages"""
  messages(messageHash: HashSelector, messageTypeName: EverscaleMessageTypeNameSelector, messageDirection: EverscaleMessageDirectionSelector, messageSender: AddressSelector, messageReceiver: AddressSelector, messageValue: FloatSelector): EverscaleMessageDimension
  minimum(of: EverscaleTransferMeasurable!, get: EverscaleTransferMeasurable): String
  """Previous Block"""
  previousBlock: BigInt
  """Transfer To"""
  receiver: Address!
  """Transfer From"""
  sender: Address!
  """Sharded Block Information"""
  shardedBlock(height: BlockSelector, hash: HashSelector, shard: StringIdSelector, workchain: BigIntIdSelector): EverscaleShardedBlockDimension
  """Timestamp"""
  timestamp: DateTime
  """Transactions"""
  transactions(txHash: HashSelector, txType: StringSelector, txAccount: AddressSelector, txAborted: BigIntIdSelector): EverscaleTransactionDimension
  """Transfer type"""
  transferType: String!
}

input EverscaleTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  blockHeight: BlockSelector
  blockShard: BigIntIdSelector
  blockWorkchain: BigIntIdSelector
  shardedHeight: BlockSelector
  shardedBlockHash: HashSelector
  shardedBlockShard: BigIntIdSelector
  shardedBlockWorkchain: BigIntIdSelector
  previousBlock: BlockSelector
  txHash: StringSelector
  txType: IntegerSelector
  txAccount: StringSelector
  txAborted: StringSelector
  txOriginalStatus: EverscaleAccountStateSelector
  txEndStatus: EverscaleAccountStateSelector
  messageHash: HashSelector
  messageTypeName: EverscaleMessageTypeNameSelector
  messageDirection: EverscaleMessageDirectionSelector
  messageSender: AddressSelector
  messageReceiver: AddressSelector
  messageValue: FloatSelector
  currency: CurrencySelector
  transferSender: StringSelector
  transferReceiver: StringSelector
  entityId: BigIntIdSelector
  transferType: EverscaleTransferTypeSelector
}

enum EverscaleTransferMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  hash
  """Number of block in the blockhains"""
  height
  """Shard of block in the blockhains"""
  shard
  """Workchain of block in the blockhains"""
  workchain
  """Number of sharded block block in the blockhains"""
  sharded_block
  """Hash of the the sharded block block"""
  sharded_block_hash
  """Shard of sharded block block in the blockhains"""
  sharded_block_shard
  """Workchain of sharded block block in the blockhains"""
  sharded_block_workchain
  """Previous Message"""
  previous_block
  """Tx Hash"""
  tx_hash
  """Tx Type"""
  tx_type
  """Tx Account"""
  tx_account
  """Tx Aborted"""
  tx_aborted
  """Message Hash"""
  message_hash
  """Message type name"""
  message_type_name
  """Message direction"""
  message_direction
  """Message sender"""
  message_sender
  """Message receiver"""
  message_receiver
  """Message value"""
  message_value
  """Value"""
  value
  """Currency Symbol"""
  currency_symbol
  """Currency Address"""
  currency_address
  """Currency Name"""
  currency_name
}

enum EverscaleTransferTypeEnum {
  """Transaction transfer"""
  transaction
  """Token Transfers"""
  token_transfer
  """Token Mint"""
  token_mint
  """Token Burn"""
  token_burn
}

"""Select by message type name"""
input EverscaleTransferTypeSelector {
  """Transfer type name is"""
  is: EverscaleTransferTypeEnum
  """Transfer type name not"""
  not: EverscaleTransferTypeEnum
  """Transfer type name in the list"""
  in: [EverscaleTransferTypeEnum!]
  """Transfer type name not in the list"""
  notIn: [EverscaleTransferTypeEnum!]
}

enum EverscaleTransferUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of Shards in the blockchains"""
  block_shard
  """Unique Number of workchains in the blockchains"""
  block_workchain
  """Unique Number of sharded blocks in the blockchains"""
  sharded_blocks
  """Unique Number of sharded block shards in the blockchains"""
  sharded_block_shards
  """Unique Number of sharded block workchains in the blockchains"""
  sharded_block_workchains
  """Unique Number of transactions"""
  txs
  """Unique Number of messages"""
  messages
  """Unique Number of currencies"""
  currencies
  """Unique Number of senders"""
  senders
  """Unique Number of receivers"""
  receivers
}

"""Value Block information"""
type EverscaleValueDimension {
  """Created"""
  created: BigInt
  """Exported"""
  exported: BigInt
  """Fees Collected"""
  feesCollected: BigInt
  """Fees imported"""
  feesImported: BigInt
  """From Previous Block"""
  fromPreviousBlock: BigInt
  """Imported"""
  imported: BigInt
  """Minted"""
  minted: BigInt
  """Value Flow To Next Block"""
  toNextBlock: BigInt
}

"""Filecoin"""
type Filecoin {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [FilecoinAddressInfoWithBalance!]!
  """Filecoin Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector, any: [FilecoinBlockFilter!], options: QueryOptions): [FilecoinBlock!]
  """Filecoin Network Calls"""
  calls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector, any: [FilecoinCallFilter!], options: QueryOptions): [FilecoinCalls!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [FilecoinCoinpath!]
  """Filecoin Network Messages ( blocks, transfers, ... )"""
  messages(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector, any: [FilecoinMessageFilter!], options: QueryOptions): [FilecoinMessages!]
  """Filecoin Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector, any: [FilecoinTransferFilter!], options: QueryOptions): [FilecoinTransfers!]
}

"""Blockchain address"""
type FilecoinAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Wallet balance"""
  balance(in: BaseCurrencyEnum): Float
}

"""Block"""
type FilecoinBlock {
  any(of: FilecoinBlocksMeasureable!): String
  blockSig: NameWithId
  blsAggregate: NameWithId
  count(uniq: FilecoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  countBigInt(uniq: FilecoinBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): BigInt
  """Calendar date"""
  date: Date
  electionProof: String
  expression(get: String!): DecimalNumber
  forkSignalling: BigInt
  """Block hash"""
  hash(blockHash: [HashSelector!]): String!
  """Block round in blockchain"""
  height(height: BlockSelector): Int!
  """Block index on height"""
  index(blockIndex: IntegerSelector): Int
  maximum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  messageCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  messageCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): BigInt
  messages: String
  """Miner"""
  miner(miner: AddressSelector): Address
  minerTips(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  minimum(of: FilecoinBlocksMeasureable!, get: FilecoinBlocksMeasureable): String
  parentMessageReceipts: String
  parentStateRoot: String
  parentWeight: BigInt
  reward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  ticket: String
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  totalReward(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Float
  winCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): Int
  winCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, miner: [AddressSelector!], blockIndex: IntegerSelector): BigInt
  wincount: Int
}

input FilecoinBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  miner: [AddressSelector!]
  blockIndex: IntegerSelector
}

enum FilecoinBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Block Miner"""
  miner
}

enum FilecoinBlockUniq {
  """Miner"""
  miners
  """Unique date count"""
  dates
  """Unique block height count"""
  heights
  """Unique block count"""
  blocks
}

input FilecoinCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  messageMethod: IntegerSelector
}

"""Calls in Filecoin blockchain"""
type FilecoinCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Float
  """Amount as decimal"""
  amountDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): DecimalNumberAsDiv
  any(of: FilecoinCallsMeasureable!): String
  """Block where transfer Message is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Call hash"""
  callHash: String
  """Call hash"""
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): Int
  countBigInt(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, messageMethod: IntegerSelector): BigInt
  """Calendar date"""
  date: Date
  exitCode: BigInt
  expression(get: String!): DecimalNumber
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float
  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String
  """Message Method"""
  messageMethod(messageMethod: IntegerSelector): NameWithId
  """Method"""
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minimum(of: FilecoinCallsMeasureable!, get: FilecoinCallsMeasureable): String
  nonce: BigInt
  """Message receiver"""
  receiver(receiver: AddressSelector): AddressWithAccount
  returnValue: String
  """Message sender"""
  sender(sender: AddressSelector): AddressWithAccount
  """Success"""
  success(success: Boolean): Boolean
}

enum FilecoinCallsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Message hash"""
  message_hash
  """Amount"""
  amount
  """Gas value"""
  gas_value
  """Gas limit"""
  gas_limit
  """Gas used"""
  gas
}

"""Coinpath"""
type FilecoinCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Message of transfer happened"""
  message: TransactionHashValue
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
}

input FilecoinMessageFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  index: IntegerSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  success: Boolean
  amount: AmountSelector
}

"""Messages in Filecoin blockchain"""
type FilecoinMessages {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  """Amount as decimal"""
  amountDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
  any(of: FilecoinMessagesMeasureable!): String
  baseFeeBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  baseFeeBurnDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
  """Block where transfer Message is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  burned(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  burnedDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  countBigInt(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): BigInt
  """Calendar date"""
  date: Date
  exitCode: BigInt
  expression(get: String!): DecimalNumber
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Int
  gasBigInt(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): BigInt
  gasFeeCap: BigInt
  gasLimit: BigInt
  gasPremium: Float
  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String
  """Method"""
  method(method: IntegerSelector): NameWithId
  minedBlock: FilecoinMinedBlock
  minerPenalty(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minerPenaltyDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
  minerTip(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  minerTipDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
  minimum(of: FilecoinMessagesMeasureable!, get: FilecoinMessagesMeasureable): String
  nonce: BigInt
  overEstimationBurn(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  overEstimationBurnDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
  """Message receiver"""
  receiver(receiver: AddressSelector): AddressWithAccount
  refund(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  refundDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
  returnValue: String
  """Message sender"""
  sender(sender: AddressSelector): AddressWithAccount
  signature: String
  signatureType: String
  """Signed Message hash"""
  signedHash: String
  """Success"""
  success(success: Boolean): Boolean
  totalCost(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): Float
  totalCostDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, index: IntegerSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, success: Boolean, amount: AmountSelector): DecimalNumberAsDiv
}

enum FilecoinMessagesMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Message hash"""
  message_hash
  """Amount"""
  amount
  """Gas value"""
  gas_value
  """Gas limit"""
  gas_limit
  """Gas used"""
  gas
}

enum FilecoinMessagesUniq {
  """Unique block heights"""
  blocks
  """Unique date count"""
  dates
  """Unique Message senders"""
  senders
  """Unique Message receivers"""
  receivers
}

"""Filecoin Mined Block"""
type FilecoinMinedBlock {
  """Hash"""
  hash: String
  """Index on height"""
  index: Int
  """Miner"""
  miner: Address
}

enum FilecoinNetwork {
  """Filecoin Mainnet"""
  filecoin
}

input FilecoinTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  method: IntegerSelector
  amount: AmountSelector
  transferType: TransferTypeSelector
  messageMethod: IntegerSelector
}

"""Transfers in Filecoin blockchain"""
type FilecoinTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Float
  """Amount as decimal"""
  amountDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): DecimalNumberAsDiv
  any(of: FilecoinTransfersMeasureable!): String
  """Block where transfer Transfer is included"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  """Call hash"""
  callHash: String
  """Call hash"""
  callPath: String
  count(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): Int
  countBigInt(uniq: FilecoinMessagesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, sender: AddressSelector, receiver: AddressSelector, method: IntegerSelector, amount: AmountSelector, transferType: TransferTypeSelector, messageMethod: IntegerSelector): BigInt
  """Currency of transfer"""
  currency: Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Message hash"""
  hash(hash: HashSelector): String
  maximum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String
  """Message Method"""
  messageMethod(messageMethod: IntegerSelector): NameWithId
  """Method"""
  method(method: IntegerSelector): NameWithId
  minimum(of: FilecoinTransfersMeasureable!, get: FilecoinTransfersMeasureable): String
  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address
  """Transfer sender"""
  sender(sender: AddressSelector): Address
  """Transfer timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Type of transfer"""
  transferType(transferType: TransferTypeSelector): FilecoinTransferType
}

enum FilecoinTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Message hash"""
  message_hash
  """Amount"""
  amount
  """Currency Symbol"""
  currency_symbol
  """Currency Name"""
  currency_name
  """Token Type"""
  token_type
  """Token ID"""
  token_id
}

enum FilecoinTransferType {
  """Send (transfer)"""
  send
  """Miner Tip"""
  miner
  """Reward"""
  reward
  """Burn"""
  burn
  """Rebalance"""
  rebalance
  """Genesis"""
  genesis
}

"""Select by number"""
input FloatSelector {
  """is"""
  is: Float
  """not"""
  not: Float
  """in the list"""
  in: [Float!]
  """not in the list"""
  notIn: [Float!]
  """greater than"""
  gt: Float
  """less than"""
  lt: Float
  """less or equal than"""
  lteq: Float
  """greater or equal than"""
  gteq: Float
  """in range"""
  between: [Float!]
}

"""Flow Chain"""
type Flow {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [FlowAddressInfoWithBalance!]!
  """The outermost portion of the transaction, which contains the payload and envelope signatures"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, type: StringSelector, value: StringSelector, valueAsInt: IntegerSelector, valueAsFix: IntegerSelector, index: IntegerSelector, any: [FlowArgumentFilter!], options: QueryOptions): [FlowArgument!]
  """
  A block seal is an attestation that the execution result of a specific block has
                     been verified and approved by a quorum of verification nodes.
  """
  blockSeals(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, blockSealId: HashSelector, executionReceiptId: HashSelector, index: StringSelector, any: [FlowBlockSealFilter!], options: QueryOptions): [FlowBlockSeal!]
  """Full block information."""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, id: HashSelector, parentBlockId: HashSelector, collectionsCount: IntegerSelector, transactionsCount: IntegerSelector, any: [FlowBlockFilter!], options: QueryOptions): [FlowBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: CurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [FlowCoinpath!]
  """A collection is a batch of transactions that have been includes in a block."""
  collections(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, collectionId: HashSelector, index: IntegerSelector, transactionsCount: IntegerSelector, any: [FlowCollectionFilter!], options: QueryOptions): [FlowCollection!]
  """Event fields"""
  eventFields(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, fieldAsInt: IntegerSelector, fieldAsFix: IntegerSelector, any: [FlowEventFieldFilter!], options: QueryOptions): [FlowEventField!]
  """
  An event is emitted as the result of a transaction execution.
          Events are either user-defined events originating from a Cadence smart contract, or built-in Flow system events.
  """
  events(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, any: [FlowEventFilter!], options: QueryOptions): [FlowEvent!]
  """Blockchain Transaction Inputs"""
  inputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector, any: [FlowInputFilter!], options: QueryOptions): [FlowInput!]
  """Blockchain Transaction Outputs"""
  outputs(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector, any: [FlowOutputFilter!], options: QueryOptions): [FlowOutput!]
  """List of transaction authorizers"""
  transactionAuthorizers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, collectionId: HashSelector, transactionId: HashSelector, indexInCollection: IntegerSelector, referenceBlockId: StringSelector, gasLimit: IntegerSelector, payer: AddressSelector, proposer: AddressSelector, proposalKeyId: IntegerSelector, proposalKeySequenceNumber: IntegerSelector, eventsCount: IntegerSelector, statusCode: IntegerSelector, authorizer: AddressSelector, any: [FlowTransactionAuthorizerFilter!], options: QueryOptions): [FlowTransactionAuthorizer!]
  """The outermost portion of the transaction, which contains the payload and envelope signatures"""
  transactionEnvelopeSignatures(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, collectionId: HashSelector, transactionId: HashSelector, indexInCollection: IntegerSelector, referenceBlockId: StringSelector, gasLimit: IntegerSelector, payer: AddressSelector, proposer: AddressSelector, proposalKeyId: IntegerSelector, proposalKeySequenceNumber: IntegerSelector, eventsCount: IntegerSelector, statusCode: IntegerSelector, address: AddressSelector, keyId: IntegerSelector, signature: StringSelector, any: [FlowTransactionEnvelopeSignatureFilter!], options: QueryOptions): [FlowTransactionEnvelopeSignature!]
  """
  The transaction authorization envelope contains both the
                     transaction payload and the payload signatures.
  """
  transactionPayloadSignatures(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, collectionId: HashSelector, transactionId: HashSelector, indexInCollection: IntegerSelector, referenceBlockId: StringSelector, gasLimit: IntegerSelector, payer: AddressSelector, proposer: AddressSelector, proposalKeyId: IntegerSelector, proposalKeySequenceNumber: IntegerSelector, eventsCount: IntegerSelector, statusCode: IntegerSelector, address: AddressSelector, keyId: IntegerSelector, signature: StringSelector, any: [FlowTransactionPayloadSignatureFilter!], options: QueryOptions): [FlowTransactionPayloadSignature!]
  """A transaction represents a unit of computation that is submitted to the Flow network."""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, collectionId: HashSelector, transactionId: HashSelector, indexInCollection: IntegerSelector, referenceBlockId: StringSelector, gasLimit: IntegerSelector, payer: AddressSelector, proposer: AddressSelector, proposalKeyId: IntegerSelector, proposalKeySequenceNumber: IntegerSelector, eventsCount: IntegerSelector, statusCode: IntegerSelector, any: [FlowTransactionFilter!], options: QueryOptions): [FlowTransaction!]
}

"""Blockchain address"""
type FlowAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """FLOW currency balance"""
  balance(in: BaseCurrencyEnum): Float
}

"""Arguments in Flow blockchain"""
type FlowArgument {
  any(of: FlowArgumentMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowArgumentUniq): Int
  countBigInt(uniq: FlowArgumentUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Index of the argument inside transaction"""
  index: Int!
  maximum(of: FlowArgumentMeasureable!, get: FlowArgumentMeasureable): String
  minimum(of: FlowArgumentMeasureable!, get: FlowArgumentMeasureable): String
  """The time this transaction was created"""
  time: DateTime
  """Transaction information"""
  transaction(transactionId: HashSelector, transactionIndexInCollection: IntegerSelector, transactionStatusCode: IntegerSelector): FlowMinorTransactionDimension!
  """Type of field, e.g. UInt64, String, Bool, etc.."""
  type: String!
  """Value"""
  value: String!
  valueAsFix(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, type: StringSelector, value: StringSelector, valueAsInt: IntegerSelector, valueAsFix: IntegerSelector, index: IntegerSelector): Float
  """Value converted to integer"""
  valueAsInt: Int!
}

input FlowArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  type: StringSelector
  value: StringSelector
  valueAsInt: IntegerSelector
  valueAsFix: IntegerSelector
  index: IntegerSelector
}

enum FlowArgumentMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """ID transaction"""
  transaction_id
  """Value"""
  value
  """Type"""
  type
  """Value with UFix64 type and converted to integer"""
  value_as_fix
}

enum FlowArgumentUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of transactions"""
  transactions
}

"""Block in Flow blockchain"""
type FlowBlock {
  any(of: FlowBlockMeasureable!): String
  """	BLS signatures of consensus nodes"""
  blockSignatures: [String!]
  """Count of collections"""
  collectionsCount: Int
  count(uniq: FlowBlockUniq): Int
  countBigInt(uniq: FlowBlockUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Height of the block in the chain"""
  height: BigInt
  """SHA3-256 hash of the entire block payload"""
  id: String
  maximum(of: FlowBlockMeasureable!, get: FlowBlockMeasureable): String
  minimum(of: FlowBlockMeasureable!, get: FlowBlockMeasureable): String
  """ID of the previous block in the chain"""
  parentBlockId: String
  """The time this transaction was created"""
  time: DateTime
  """Count of transactions"""
  transactionsCount: Int
}

type FlowBlockDimension {
  """Height of the block in the chain"""
  height: BigInt
  """SHA3-256 hash of the entire block payload"""
  id: String
}

input FlowBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  id: HashSelector
  parentBlockId: HashSelector
  collectionsCount: IntegerSelector
  transactionsCount: IntegerSelector
}

enum FlowBlockMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Height of the block in the chain"""
  height
  """SHA3-256 hash of the entire block payload"""
  id
  """ID of the previous block in the chain"""
  parent_block_id
  """Count of collections"""
  collections_count
  """Count of transactions"""
  transactions_count
}

"""Block seals in Flow blockchain"""
type FlowBlockSeal {
  any(of: FlowBlockSealsMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowBlockSealUniq): Int
  countBigInt(uniq: FlowBlockSealUniq): BigInt
  """The date this transaction was created"""
  date: Date
  """ID execution receipt being sealed"""
  executionReceiptId: String
  """BLS signatures of verification nodes on the execution receipt contents"""
  executionReceiptSignatures: [String!]
  expression(get: String!): DecimalNumber
  """Index inside block"""
  index: Int
  maximum(of: FlowBlockSealsMeasureable!, get: FlowBlockSealsMeasureable): String
  minimum(of: FlowBlockSealsMeasureable!, get: FlowBlockSealsMeasureable): String
  """BLS signatures of verification nodes on the result approval contents"""
  resultApprovalSignatures: [String!]
  """ID of the block being sealed"""
  sealId: String
  """The time this transaction was created"""
  time: DateTime
}

input FlowBlockSealFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  blockSealId: HashSelector
  executionReceiptId: HashSelector
  index: StringSelector
}

enum FlowBlockSealsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Height of the block in the chain"""
  height
  """SHA3-256 hash of the entire block payload"""
  block_id
  """ID of the block being sealed"""
  block_seal_id
  """ID execution receipt being sealed"""
  execution_receipt_id
}

enum FlowBlockSealUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique number of sealed blocks"""
  block_seal_id
  """ID execution receipt being sealed"""
  execution_receipt_id
}

enum FlowBlockUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
}

"""FlowCoinpath"""
type FlowCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Transaction of transfer happened"""
  transaction: FlowTransactionHashIndexValues
}

"""Collections in Flow blockchain"""
type FlowCollection {
  any(of: FlowCollectionsMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowCollectionUniq): Int
  countBigInt(uniq: FlowCollectionUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """SHA3-256 hash of the collection contents"""
  id: String
  """Index of collection inside block"""
  index: Int
  maximum(of: FlowCollectionsMeasureable!, get: FlowCollectionsMeasureable): String
  minimum(of: FlowCollectionsMeasureable!, get: FlowCollectionsMeasureable): String
  """BLS signatures of the collection nodes guaranteeing the collection"""
  signatures: [String!]
  """The time this transaction was created"""
  time: DateTime
  """Count of transactions inside collection"""
  transactionsCount: Int
}

input FlowCollectionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  index: IntegerSelector
  transactionsCount: IntegerSelector
}

enum FlowCollectionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Height of the block in the chain"""
  height
  """SHA3-256 hash of the entire block payload"""
  block_id
  """SHA3-256 hash of the collection contents"""
  collection_id
  """Index of collection inside block"""
  collection_index
  """Count of transactions inside collection"""
  transactions_count
}

enum FlowCollectionUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """SHA3-256 hash of the collection contents"""
  collection_id
  """Index of collection inside block"""
  collection_index
}

enum FlowDirection {
  """Inbound transfers"""
  inbound
  """Outbound transfers"""
  outbound
}

"""Events in Flow blockchain"""
type FlowEvent {
  any(of: FlowEventMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowEventUniq): Int
  countBigInt(uniq: FlowEventUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  index: Int!
  maximum(of: FlowEventMeasureable!, get: FlowEventMeasureable): String
  minimum(of: FlowEventMeasureable!, get: FlowEventMeasureable): String
  """Smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod: Method
  """The time this transaction was created"""
  time: DateTime
  """Transaction information"""
  transaction(transactionId: HashSelector, transactionIndexInCollection: IntegerSelector, transactionStatusCode: IntegerSelector): FlowMinorTransactionDimension!
  """Type of field, e.g. UInt64, String, Bool, etc.."""
  type: String!
}

"""EventFields in Flow blockchain"""
type FlowEventField {
  any(of: FlowEventFieldMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowEventFieldUniq): Int
  countBigInt(uniq: FlowEventFieldUniq): BigInt
  """The date this transaction was created"""
  date: Date
  """Index of event inside transaction"""
  eventIndex: Int!
  expression(get: String!): DecimalNumber
  """Field"""
  field: String!
  """Field as fix"""
  fieldAsFix: String!
  """Field as fix"""
  fieldAsInt: String!
  """Index of field inside event"""
  index: String!
  maximum(of: FlowEventFieldMeasureable!, get: FlowEventFieldMeasureable): String
  minimum(of: FlowEventFieldMeasureable!, get: FlowEventFieldMeasureable): String
  """Smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod: Method
  """The time this transaction was created"""
  time: DateTime
  """Transaction information"""
  transaction(transactionId: HashSelector, transactionIndexInCollection: IntegerSelector, transactionStatusCode: IntegerSelector): FlowMinorTransactionDimension!
  """Type of field, e.g. UInt64, String, Bool, etc.."""
  type: String!
}

input FlowEventFieldFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
  eventIndex: IntegerSelector
  fieldAsInt: IntegerSelector
  fieldAsFix: IntegerSelector
}

enum FlowEventFieldMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """ID transaction"""
  tx_id
  """TX status code"""
  tx_status_code
  """Index of transaction inside collection"""
  tx_index_in_collection
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature Hash"""
  signature_hash
}

enum FlowEventFieldUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of transactions"""
  transactions
  """Unique Number of events"""
  events
  """Unique Number of smart contract"""
  smart_contracts
  """Unique Number of smart contract methods"""
  smart_contract_methods
}

input FlowEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  index: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
}

enum FlowEventMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """ID transaction"""
  tx_id
  """TX status code"""
  tx_status_code
  """Index of transaction inside collection"""
  tx_index_in_collection
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature Hash"""
  signature_hash
}

enum FlowEventUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of transactions"""
  transactions
  """Unique Number of events"""
  events
  """Unique Number of smart contract"""
  smart_contracts
  """Unique Number of smart contract methods"""
  smart_contract_methods
}

type FlowFullTransactionDimension {
  """Error message"""
  errorMessage: String
  """Count of events inside transaction"""
  eventsCount: Int
  """Gas Limit"""
  gasLimit: BigInt
  """ID of the transaction"""
  id: String
  """Transaction Index inside collection"""
  indexInCollection: Int
  """The account paying for the transaction fees"""
  payer: String
  """ID of proposal key on the proposal account"""
  proposalKeyId: Int
  """Sequence number for the proposal key"""
  proposalKeySequenceNumber: Int
  """The account that specifies a proposal key"""
  proposer: String
  """Block ID used to determine transaction expiry"""
  referenceBlockId: String
  """Status code of transaction where 0 is success and 1 is failure"""
  statusCode: Int
}

"""Inputs in Flow blockchain"""
type FlowInput {
  """Address"""
  address: Address!
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector): Float
  """Input value as decimal"""
  amountDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector): DecimalNumberAsDiv
  any(of: FlowInputMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowInputUniq): Int
  countBigInt(uniq: FlowInputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector): BigInt
  """Currency of transfer"""
  currency: Currency
  """The date this transaction was created"""
  date: Date
  """NFT Id"""
  entityId: BigInt!
  """Index of event inside transaction"""
  eventIndex: Int!
  expression(get: String!): DecimalNumber
  maximum(of: FlowInputMeasureable!, get: FlowInputMeasureable): String
  minimum(of: FlowInputMeasureable!, get: FlowInputMeasureable): String
  """Smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod: Method
  """The time this transaction was created"""
  time: DateTime
  """Transaction information"""
  transaction(transactionId: HashSelector, transactionIndexInCollection: IntegerSelector, transactionStatusCode: IntegerSelector): FlowMinorTransactionDimension!
  """Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee"""
  transferReason: String!
  """Type of field, e.g. UInt64, String, Bool, etc.."""
  type: String!
}

input FlowInputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  index: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
  eventIndex: IntegerSelector
  address: StringSelector
  entityId: BigIntIdSelector
  transferReason: FlowTransferReasonSelector
  currency: CurrencySelector
}

enum FlowInputMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """ID transaction"""
  tx_id
  """TX status code"""
  tx_status_code
  """Index of transaction inside collection"""
  tx_index_in_collection
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Hash"""
  signature_hash
  """Type"""
  type
  """Index of event inside transaction"""
  event_index
  """Address"""
  address
  """Amount"""
  amount
  """Currency symbol"""
  currency_symbol
  """Currency address"""
  currency_address
  """Entity ID"""
  entity_id
}

enum FlowInputUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of transactions"""
  transactions
  """Unique Number of events"""
  events
  """Unique Number of smart contract"""
  smart_contracts
  """Unique Number of smart contract methods"""
  smart_contract_methods
  """Unique Number of types"""
  types
  """Unique Number of symbol currencies"""
  currencies
}

type FlowMinorTransactionDimension {
  """ID of the transaction"""
  id: String
  """Transaction Index inside collection"""
  indexInCollection: Int
  """Status code of transaction where 0 is success and 1 is failure"""
  statusCode: Int
}

enum FlowNetwork {
  """Elrond mainnet"""
  flow
}

"""Outputs in Flow blockchain"""
type FlowOutput {
  """Address"""
  address: Address!
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector): Float
  """Input value as decimal"""
  amountDecimal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector): DecimalNumberAsDiv
  any(of: FlowOutputMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  count(uniq: FlowOutputUniq): Int
  countBigInt(uniq: FlowOutputUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockId: HashSelector, transactionId: HashSelector, transactionStatusCode: IntegerSelector, transactionIndexInCollection: IntegerSelector, index: IntegerSelector, smartContractAddress: StringSelector, smartContractMethod: MethodSelector, type: StringSelector, eventIndex: IntegerSelector, address: StringSelector, entityId: BigIntIdSelector, transferReason: FlowTransferReasonSelector, currency: CurrencySelector): BigInt
  """Currency of transfer"""
  currency: Currency
  """The date this transaction was created"""
  date: Date
  """NFT Id"""
  entityId: BigInt!
  """Index of event inside transaction"""
  eventIndex: Int!
  expression(get: String!): DecimalNumber
  maximum(of: FlowOutputMeasureable!, get: FlowOutputMeasureable): String
  minimum(of: FlowOutputMeasureable!, get: FlowOutputMeasureable): String
  """Smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod: Method
  """The time this transaction was created"""
  time: DateTime
  """Transaction information"""
  transaction(transactionId: HashSelector, transactionIndexInCollection: IntegerSelector, transactionStatusCode: IntegerSelector): FlowMinorTransactionDimension!
  """Transfer reason, e.g. nft_transfer, fungible_token_transfer, fee"""
  transferReason: String!
  """Type of field, e.g. UInt64, String, Bool, etc.."""
  type: String!
}

input FlowOutputFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  transactionId: HashSelector
  transactionStatusCode: IntegerSelector
  transactionIndexInCollection: IntegerSelector
  index: IntegerSelector
  smartContractAddress: StringSelector
  smartContractMethod: MethodSelector
  type: StringSelector
  eventIndex: IntegerSelector
  address: StringSelector
  entityId: BigIntIdSelector
  transferReason: FlowTransferReasonSelector
  currency: CurrencySelector
}

enum FlowOutputMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """ID transaction"""
  tx_id
  """TX status code"""
  tx_status_code
  """Index of transaction inside collection"""
  tx_index_in_collection
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Hash"""
  signature_hash
  """Type"""
  type
  """Index of event inside transaction"""
  event_index
  """Address"""
  address
  """Amount"""
  amount
  """Currency symbol"""
  currency_symbol
  """Currency address"""
  currency_address
  """Entity ID"""
  entity_id
}

enum FlowOutputUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of transactions"""
  transactions
  """Unique Number of events"""
  events
  """Unique Number of smart contract"""
  smart_contracts
  """Unique Number of smart contract methods"""
  smart_contract_methods
  """Unique Number of types"""
  types
  """Unique Number of symbol currencies"""
  currencies
}

"""Transactions in Flow  blockchain"""
type FlowTransaction {
  any(of: FlowTransactionMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  """SHA3-256 hash of the collection contents"""
  collectionId: String
  count(uniq: FlowTransactionUniq): Int
  countBigInt(uniq: FlowTransactionUniq): BigInt
  """The date this transaction was created"""
  date: Date
  """Error message"""
  errorMessage: String
  """Count of events inside transaction"""
  eventsCount: Int
  expression(get: String!): DecimalNumber
  """Gas Limit"""
  gasLimit: BigInt
  """ID of the transaction"""
  id: String
  """Transaction Index inside collection"""
  indexInCollection: Int
  maximum(of: FlowTransactionMeasureable!, get: FlowTransactionMeasureable): String
  minimum(of: FlowTransactionMeasureable!, get: FlowTransactionMeasureable): String
  """The account paying for the transaction fees"""
  payer: Address
  """ID of proposal key on the proposal account"""
  proposalKeyId: Int
  """Sequence number for the proposal key"""
  proposalKeySequenceNumber: Int
  """The account that specifies a proposal key"""
  proposer: Address
  """Block ID used to determine transaction expiry"""
  referenceBlockId: String
  """Raw source code for a Cadence script, encoded as UTF-8 bytes"""
  script: String
  """Status code of transaction where 0 is success and 1 is failure"""
  statusCode: Int
  """The time this transaction was created"""
  time: DateTime
}

"""TransactionAuthorizers in Flow blockchain"""
type FlowTransactionAuthorizer {
  any(of: FlowTransactionAuthorizerMeasureable!): String
  """Account authorizing the transaction to mutate their state."""
  authorizer: Address
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  """SHA3-256 hash of the collection contents"""
  collectionId: String
  count(uniq: FlowTransactionAuthorizerUniq): Int
  countBigInt(uniq: FlowTransactionAuthorizerUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: FlowTransactionAuthorizerMeasureable!, get: FlowTransactionAuthorizerMeasureable): String
  minimum(of: FlowTransactionAuthorizerMeasureable!, get: FlowTransactionAuthorizerMeasureable): String
  """The time this transaction was created"""
  time: DateTime
  """Information about transaction"""
  transaction(transactionId: HashSelector, indexInCollection: IntegerSelector, referenceBlockId: HashSelector, gasLimit: IntegerSelector, payer: HashSelector, proposer: HashSelector, proposalKeyId: IntegerSelector, proposalKeySequenceNumber: IntegerSelector, eventsCount: IntegerSelector, errorMessage: StringSelector, statusCode: IntegerSelector): FlowFullTransactionDimension!
}

input FlowTransactionAuthorizerFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
  authorizer: AddressSelector
}

enum FlowTransactionAuthorizerMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """SHA3-256 hash of the collection contents"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """Gas Limit"""
  gas_limit
  """The account paying for the transaction fees"""
  payer
  """The account that specifies a proposal key"""
  proposer
  """Proposer Key ID"""
  proposer_key_id
  """Proposer key sequence number"""
  proposal_key_sequence_number
  """Count of events inside transactions"""
  events_count
  """Error message in transaction"""
  error_message
  """Status code of transaction"""
  status_code
  """Account authorizing the transaction to mutate their state."""
  authorizer
}

enum FlowTransactionAuthorizerUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of collection"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """The account paying for the transaction fees"""
  payers
  """The account that specifies a proposal key"""
  proposers
  """Unique Number of authorizers"""
  authorizers
}

"""TransactionEnvelopeSignature in Flow blockchain"""
type FlowTransactionEnvelopeSignature {
  """Address of the account for this signature"""
  address: Address!
  any(of: FlowTransactionEnvelopeSignatureMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  """SHA3-256 hash of the collection contents"""
  collectionId: String!
  count(uniq: FlowTransactionEnvelopeSignatureUniq): Int
  countBigInt(uniq: FlowTransactionEnvelopeSignatureUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """ID of the account key"""
  keyId: Int!
  maximum(of: FlowTransactionEnvelopeSignatureMeasureable!, get: FlowTransactionEnvelopeSignatureMeasureable): String
  minimum(of: FlowTransactionEnvelopeSignatureMeasureable!, get: FlowTransactionEnvelopeSignatureMeasureable): String
  """Raw signature data"""
  signature: String!
  """The time this transaction was created"""
  time: DateTime
  """Information about transaction"""
  transaction(transactionId: HashSelector, indexInCollection: IntegerSelector, referenceBlockId: HashSelector, gasLimit: IntegerSelector, payer: HashSelector, proposer: HashSelector, proposalKeyId: IntegerSelector, proposalKeySequenceNumber: IntegerSelector, eventsCount: IntegerSelector, errorMessage: StringSelector, statusCode: IntegerSelector): FlowFullTransactionDimension!
}

input FlowTransactionEnvelopeSignatureFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
  address: AddressSelector
  keyId: IntegerSelector
  signature: StringSelector
}

enum FlowTransactionEnvelopeSignatureMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """SHA3-256 hash of the collection contents"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """Gas Limit"""
  gas_limit
  """The account paying for the transaction fees"""
  payer
  """The account that specifies a proposal key"""
  proposer
  """Proposer Key ID"""
  proposer_key_id
  """Proposer key sequence number"""
  proposal_key_sequence_number
  """Count of events inside transactions"""
  events_count
  """Error message in transaction"""
  error_message
  """Status code of transaction"""
  status_code
  """Address of the account for this signature"""
  address
  """ID of account key"""
  key_id
  """Raw signature data"""
  signature
}

enum FlowTransactionEnvelopeSignatureUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of collection"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """The account paying for the transaction fees"""
  payers
  """The account that specifies a proposal key"""
  proposers
  """The address and key ID fields declare the account key that generated the signature"""
  addresses
}

input FlowTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
}

"""Blockchain transaction"""
type FlowTransactionHashIndexValues {
  """Hash hex representation"""
  id: String!
  """Transaction value in input"""
  valueIn: Float!
  """Transaction value in input"""
  valueInDecimal: DecimalNumber!
  """Transaction value in output"""
  valueOut: Float!
  """Transaction value in output"""
  valueOutDecimal: DecimalNumber!
}

enum FlowTransactionMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """SHA3-256 hash of the collection contents"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """Gas Limit"""
  gas_limit
  """The account paying for the transaction fees"""
  payer
  """The account that specifies a proposal key"""
  proposer
  """Proposer Key ID"""
  proposer_key_id
  """Proposer key sequence number"""
  proposal_key_sequence_number
  """Count of events inside transactions"""
  events_count
  """Error message in transaction"""
  error_message
  """Status code of transaction"""
  status_code
}

"""TransactionPayloadSignature in Flow blockchain"""
type FlowTransactionPayloadSignature {
  """Address of the account for this signature"""
  address: Address!
  any(of: FlowTransactionPayloadSignatureMeasureable!): String
  """Block information"""
  block(height: BlockSelector, blockId: HashSelector): FlowBlockDimension!
  """SHA3-256 hash of the collection contents"""
  collectionId: String!
  count(uniq: FlowTransactionPayloadSignatureUniq): Int
  countBigInt(uniq: FlowTransactionPayloadSignatureUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """ID of the account key"""
  keyId: Int!
  maximum(of: FlowTransactionPayloadSignatureMeasureable!, get: FlowTransactionPayloadSignatureMeasureable): String
  minimum(of: FlowTransactionPayloadSignatureMeasureable!, get: FlowTransactionPayloadSignatureMeasureable): String
  """Raw signature data"""
  signature: String!
  """The time this transaction was created"""
  time: DateTime
  """Information about transaction"""
  transaction(transactionId: HashSelector, indexInCollection: IntegerSelector, referenceBlockId: HashSelector, gasLimit: IntegerSelector, payer: HashSelector, proposer: HashSelector, proposalKeyId: IntegerSelector, proposalKeySequenceNumber: IntegerSelector, eventsCount: IntegerSelector, errorMessage: StringSelector, statusCode: IntegerSelector): FlowFullTransactionDimension!
}

input FlowTransactionPayloadSignatureFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockId: HashSelector
  collectionId: HashSelector
  transactionId: HashSelector
  indexInCollection: IntegerSelector
  referenceBlockId: StringSelector
  gasLimit: IntegerSelector
  payer: AddressSelector
  proposer: AddressSelector
  proposalKeyId: IntegerSelector
  proposalKeySequenceNumber: IntegerSelector
  eventsCount: IntegerSelector
  statusCode: IntegerSelector
  address: AddressSelector
  keyId: IntegerSelector
  signature: StringSelector
}

enum FlowTransactionPayloadSignatureMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Number of block in the blockhains"""
  height
  """Hash of the the block"""
  block_id
  """SHA3-256 hash of the collection contents"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """Gas Limit"""
  gas_limit
  """The account paying for the transaction fees"""
  payer
  """The account that specifies a proposal key"""
  proposer
  """Proposer Key ID"""
  proposer_key_id
  """Proposer key sequence number"""
  proposal_key_sequence_number
  """Count of events inside transactions"""
  events_count
  """Error message in transaction"""
  error_message
  """Status code of transaction"""
  status_code
  """Address of the account for this signature"""
  address
  """ID of account key"""
  key_id
  """Raw signature data"""
  signature
}

enum FlowTransactionPayloadSignatureUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of collection"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """The account paying for the transaction fees"""
  payers
  """The account that specifies a proposal key"""
  proposers
  """The address and key ID fields declare the account key that generated the signature"""
  addresses
}

enum FlowTransactionUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
  """Unique Number of collection"""
  collection_id
  """Transaction ID"""
  tx_id
  """Transaction index inside collection"""
  tx_index_in_collection
  """Reference block hash"""
  reference_block_id
  """The account paying for the transaction fees"""
  payers
  """The account that specifies a proposal key"""
  proposers
}

enum FlowTransferReasonEnum {
  """Currency transfer"""
  fungible_token_transfer
  """NFT Transfer"""
  nft_transfer
  """Fee paid"""
  fee
}

"""Select by transfer reason"""
input FlowTransferReasonSelector {
  """Reason is"""
  is: FlowTransferReasonEnum
  """Reason not"""
  not: FlowTransferReasonEnum
  """Reason in the list"""
  in: [FlowTransferReasonEnum!]
  """Reason not in the list"""
  notIn: [FlowTransferReasonEnum!]
}

"""Select transactions by group"""
input GroupSelector {
  """Transaction group is"""
  is: String
  """Transaction group not"""
  not: String
  """Transaction group in the list"""
  in: [String!]
  """Transaction group not in the list"""
  notIn: [String!]
}

"""Harmony Chain"""
type Harmony {
  """Arguments of Smart Contract Calls and Events"""
  arguments(time: DateTimeSelector, date: DateSelector, ledger: BlockSelector, blockHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, sender: HashSelector, receiver: HashSelector, smartContractAddress: HashSelector, smartContractId: IntegerSelector, argument: StringSelector, any: [HarmonyArgumentsFilter!], options: QueryOptions): [HarmonyArguments!]
  """Harmony Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, shardId: BigIntegerSelector, epoch: BigIntegerSelector, ledger: BlockSelector, blockHash: HashSelector, miner: HashSelector, difficulty: HashSelector, nonce: BigIntegerSelector, viewId: HashSelector, parentHash: HashSelector, transactionCount: HashSelector, size: BigIntegerSelector, stakingTransactionsCount: HashSelector, unclesCount: HashSelector, any: [HarmonyBlocksFilter!], options: QueryOptions): [HarmonyBlocks!]
  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, any: [HarmonySmartContractCallsFilter!], options: QueryOptions): [HarmonySmartContractCalls!]
  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, any: [HarmonySmartContractEventsFilter!], options: QueryOptions): [HarmonySmartContractEvents!]
  """Harmony Staking Transactions"""
  stakingTransactions(date: DateSelector, transactionHash: HashSelector, ledger: BlockSelector, shardId: BigIntIdSelector, nonce: BigIntIdSelector, transactionType: StakingTransactionsTypeSelector, validatorAddress: HashSelector, delegatorAddress: HashSelector, success: Boolean, status: Boolean, any: [HarmonyStakingTransactionsFilter!], options: QueryOptions): [HarmonyStakingTransactions!]
  """Harmony Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, epoch: BigIntegerSelector, nonce: BigIntegerSelector, transactionHash: StringSelector, transactionIndex: HashSelector, ledger: BigIntIdSelector, creates: StringSelector, sender: HashSelector, receiver: HashSelector, success: Boolean, status: Boolean, any: [HarmonyTransactionsFilter!], options: QueryOptions): [HarmonyTransactions!]
  """Harmony Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, ledger: BlockSelector, blockHash: HashSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, sender: HashSelector, transferFrom: AddressSelector, transferTo: AddressSelector, status: Boolean, success: Boolean, currency: CurrencySelector, entityId: IntIdSelector, any: [HarmonyTransfersFilter!], options: QueryOptions): [HarmonyTransfers!]
}

"""Arguments of Smart Contract Calls and Events"""
type HarmonyArguments {
  """Address"""
  address: String
  any(of: HarmonyArgumentsMeasureable!): String
  """Argument Index"""
  argIndex: String
  """Argument Type"""
  argType: String
  """Argument"""
  argument(argument: String): String
  """Transaction hash"""
  blockHash(blockHash: HashSelector): String
  """Call Path"""
  callPath: String
  count(uniq: HarmonyArgumentsUniq): Int
  """The date this transaction was created"""
  date: Date
  """Epoch"""
  epoch: BigInt
  expression(get: String!): DecimalNumber
  """Value"""
  external: Int
  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyArgumentsMeasureable!, get: HarmonyArgumentsMeasureable): String
  minimum(of: HarmonyArgumentsMeasureable!, get: HarmonyArgumentsMeasureable): String
  """The number of transactions made by the sender prior to this one."""
  nonce: BigInt
  """Number"""
  number: String
  """Address of the receiver"""
  receiver(receiver: HashSelector): String
  """Address of the sender"""
  sender(sender: HashSelector): String
  """ShardID"""
  shardId: BigInt
  """Signature ID"""
  signatureId: BigInt
  """Address of the smart contract"""
  smartContractAddress(smartContractAddress: HashSelector): String
  """Id of the smart contract"""
  smartContractId(smartContractAddress: IntegerSelector): BigInt
  """The time this transaction was created"""
  time: DateTime
  """To Shard ID"""
  toShardId: BigInt
  """Value"""
  value: String
}

input HarmonyArgumentsFilter {
  time: DateTimeSelector
  date: DateSelector
  ledger: BlockSelector
  blockHash: HashSelector
  nonce: BigIntIdSelector
  txIndex: BigIntegerSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  sender: HashSelector
  receiver: HashSelector
  smartContractAddress: HashSelector
  smartContractId: IntegerSelector
  argument: StringSelector
}

enum HarmonyArgumentsMeasureable {
  """Time"""
  time
  """Date"""
  date
  """Block hash"""
  block_hash
  """Address of the sender"""
  sender
  """Address of  the receive"""
  receiver
  """TX Index"""
  tx_index
  """Epoch"""
  epoch
  """Nonce"""
  nonce
  """Shard ID"""
  shard_id
  """TO Shard ID"""
  to_shard_id
  """Address of the smart contract"""
  smart_contract_address
  """Id of the smart contract"""
  smart_contract_id
  """Signature"""
  signature
  """Name of the signature"""
  signature_name
  """Hash of the signature"""
  signature_hash
  """Value"""
  value
  """Address"""
  address
}

enum HarmonyArgumentsUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique ledger count"""
  ledger
  """Unique block hash count"""
  block_hash
  """Unique smart contract address"""
  smart_contract_address
  """Unique address of the sender"""
  sender
  """Unique address of the receiver"""
  receiver
  """Unique addresses"""
  address
}

"""Blocks in Harmony blockchain"""
type HarmonyBlocks {
  any(of: HarmonyBlocksMeasureable!): String
  """Transaction hash"""
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyBlocksUniq): Int
  countBigInt(uniq: HarmonyBlocksUniq): BigInt
  """The date this transaction was created"""
  date: Date
  """Difficulty"""
  difficulty: String
  """Epoch"""
  epoch: BigInt
  expression(get: String!): DecimalNumber
  """The extra data field of this block"""
  extraData: String
  gasLimit(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, shardId: BigIntegerSelector, epoch: BigIntegerSelector, ledger: BlockSelector, blockHash: HashSelector, miner: HashSelector, difficulty: HashSelector, nonce: BigIntegerSelector, viewId: HashSelector, parentHash: HashSelector, transactionCount: HashSelector, size: BigIntegerSelector, stakingTransactionsCount: HashSelector, unclesCount: HashSelector): Float
  gasUsed(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, shardId: BigIntegerSelector, epoch: BigIntegerSelector, ledger: BlockSelector, blockHash: HashSelector, miner: HashSelector, difficulty: HashSelector, nonce: BigIntegerSelector, viewId: HashSelector, parentHash: HashSelector, transactionCount: HashSelector, size: BigIntegerSelector, stakingTransactionsCount: HashSelector, unclesCount: HashSelector): Float
  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  """The bloom filter for the logs of the block. null when its pending block"""
  logsBloom: String
  maximum(of: HarmonyBlocksMeasureable!, get: HarmonyBlocksMeasureable): String
  """Transaction hash"""
  miner(miner: HashSelector): String
  minimum(of: HarmonyBlocksMeasureable!, get: HarmonyBlocksMeasureable): String
  """Mix Hash"""
  mixHash: String
  """Nonce"""
  nonce: BigInt
  """Parent hash"""
  parentHash(parentHash: HashSelector): String
  """Receipts Root"""
  receiptsRoot: String
  """ShardID"""
  shardId: BigInt
  """Integer the size of this block in bytes"""
  size(size: HashSelector): BigInt
  """Staking Transaction Count"""
  stakingTransactionsCount(stakingTransactionsCount: HashSelector): BigInt
  """The root of the final state trie of the block"""
  stateRoot: String
  """The time this transaction was created"""
  time: DateTime
  """Transaction Count"""
  transactionCount(transactionCount: HashSelector): BigInt
  """The root of the transaction trie of the block"""
  transactionsRoot: String
  """Count of ucles hashes"""
  unclesCount(unclesCount: HashSelector): BigInt
  """View ID"""
  viewId(viewId: HashSelector): String
}

input HarmonyBlocksFilter {
  date: DateSelector
  time: DateTimeSelector
  shardId: BigIntegerSelector
  epoch: BigIntegerSelector
  ledger: BlockSelector
  blockHash: HashSelector
  miner: HashSelector
  difficulty: HashSelector
  nonce: BigIntegerSelector
  viewId: HashSelector
  parentHash: HashSelector
  transactionCount: HashSelector
  size: BigIntegerSelector
  stakingTransactionsCount: HashSelector
  unclesCount: HashSelector
}

enum HarmonyBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Gas limit"""
  gas_limit
  """Gas Used"""
  gas_used
  """Block hash"""
  block_hash
  """Parent hash"""
  paret_hash
  """Transaction Count"""
  transaction_count
}

enum HarmonyBlocksUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique ledger count"""
  ledger
  """Unique block hash count"""
  block_hash
  """Unique parent hash count"""
  parent_hash
  """Unique miner count"""
  miner
  """Unique mix hash count"""
  mix_hash
  """Unique state root count"""
  state_root
  """Unique receipts root count"""
  receipts_root
  """Unique transactions root count"""
  transactions_root
}

enum HarmonyEventsMeasureable {
  """Time"""
  time
  """Date"""
  date
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Nonce"""
  nonce
  """Transaction Index"""
  tx_index
  """Shard ID"""
  shard_id
  """To Shard ID"""
  to_shard_id
  """Action To"""
  tx_to
  """Action From"""
  tx_from
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Smart Contract Method Name"""
  signature_name
}

enum HarmonyNetwork {
  """Harmony Mainnat"""
  harmony
  """Harmony Testnet"""
  harmony_testnet
}

"""Smart Contract Calls"""
type HarmonySmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  any(of: HarmonySmartContractCallsMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callPath: String
  """Counts and other metrics"""
  count(uniq: HarmonySmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int
  """Counts and other metrics"""
  countBigInt(uniq: HarmonySmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """External call executed explicitly by caller. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int
  """Gas unit price"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, nonce: BigIntIdSelector, txIndex: BigIntegerSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  maximum(of: HarmonySmartContractCallsMeasureable!, get: HarmonySmartContractCallsMeasureable): String
  minimum(of: HarmonySmartContractCallsMeasureable!, get: HarmonySmartContractCallsMeasureable): String
  """Nonce"""
  nonce(nonce: IntegerSelector): BigInt
  """ShardID"""
  shardId: BigInt
  """Smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """ToShardID"""
  toShardId: BigInt
  """Action from address"""
  txFrom(txFrom: AddressSelector): Address
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Tx index"""
  txIndex: BigInt
  """Transaction Sender"""
  txSender(txSender: AddressSelector): Address
  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

input HarmonySmartContractCallsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  nonce: BigIntIdSelector
  txIndex: BigIntegerSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

enum HarmonySmartContractCallsMeasureable {
  """Time"""
  time
  """Date"""
  date
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Nonce"""
  nonce
  """Transaction Index"""
  tx_index
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Shard ID"""
  shard_id
  """To Shard ID"""
  to_shard_id
  """Action From"""
  tx_from
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_path
  """Success"""
  success
  """External"""
  external
}

enum HarmonySmartContractCallsUniq {
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique transactions count"""
  txs
  """Unique transactions senders"""
  tx_sender
  """Unique callers count"""
  tx_to
  """Unique transaction senders"""
  tx_from
  """Unique smart contracts count"""
  smart_contracts
  """Unique smart contract methods count"""
  smart_contract_methods
}

"""Smart Contract Events"""
type HarmonySmartContractEvents {
  any(of: HarmonyEventsMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Counts and other metrics"""
  count(uniq: SmartContractEventsUniq): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractEventsUniq): BigInt
  """Calendar date"""
  date: Date
  """Transaction hash where transfer happened"""
  epoch(epoch: IntegerSelector): BigInt
  expression(get: String!): DecimalNumber
  maximum(of: HarmonyEventsMeasureable!, get: HarmonyEventsMeasureable): String
  minimum(of: HarmonyEventsMeasureable!, get: HarmonyEventsMeasureable): String
  """The number of transactions made by the sender prior to this one."""
  nonce(nonce: IntegerSelector): BigInt
  """ShardID"""
  shardId: BigInt
  """Smart contract address"""
  smartContractAddress: Address
  """Contract method invoked"""
  smartContractEvent(smartContractEvent: EventSelector): Event
  """ToShardID"""
  toShardId: BigInt
  """Action from address"""
  txFrom(txFrom: AddressSelector): Address
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Tx index"""
  txIndex: BigInt
  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

input HarmonySmartContractEventsFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  nonce: BigIntIdSelector
  txIndex: BigIntegerSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

"""StakingTransactions in Harmony blockchain"""
type HarmonyStakingTransactions {
  any(of: HarmonyStakingTransactionsMeasureable!): String
  """Hash of block"""
  blockHash: String
  count(uniq: HarmonyStakingTransactionsUniq): Int
  countBigInt(uniq: HarmonyStakingTransactionsUniq): BigInt
  """Data"""
  data: String
  """The date this transaction was created"""
  date: Date
  """Delegator Address"""
  delegatorAddress(delegatorAddress: HashSelector): String
  """Epoch"""
  epoch: BigInt
  expression(get: String!): DecimalNumber
  """Gas provided by the sender"""
  gas: BigInt
  """Gas price provided by the sender"""
  gasPrice: String
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transactionHash: HashSelector, ledger: BlockSelector, shardId: BigIntIdSelector, nonce: BigIntIdSelector, transactionType: StakingTransactionsTypeSelector, validatorAddress: HashSelector, delegatorAddress: HashSelector, success: Boolean, status: Boolean): Float
  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyStakingTransactionsMeasureable!, get: HarmonyStakingTransactionsMeasureable): String
  minimum(of: HarmonyStakingTransactionsMeasureable!, get: HarmonyStakingTransactionsMeasureable): String
  """The number of transactions made by the sender prior to this one"""
  nonce: BigInt
  """ShardID"""
  shardId: BigInt
  """Status"""
  status(status: Boolean): Boolean
  """Successful of not"""
  success(success: Boolean): Boolean
  """The time this transaction was created"""
  time: DateTime
  """Transaction hash"""
  transactionHash(transactionHash: HashSelector): String
  """Transaction type"""
  transactionType(transactionType: StakingTransactionsTypeSelector): String
  """Validator Address"""
  validatorAddress(validatorAddress: HashSelector): String
  """Value transferred in ATTO"""
  value: String
}

input HarmonyStakingTransactionsFilter {
  date: DateSelector
  transactionHash: HashSelector
  ledger: BlockSelector
  shardId: BigIntIdSelector
  nonce: BigIntIdSelector
  transactionType: StakingTransactionsTypeSelector
  validatorAddress: HashSelector
  delegatorAddress: HashSelector
  success: Boolean
  status: Boolean
}

enum HarmonyStakingTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Transaction Hash"""
  transaction_hash
  """Gas price provided by the sender"""
  gas_price
  """Validator Address"""
  validator_address
  """Deligator Address"""
  deligator_address
  """Value transferred in ATTO"""
  value
  """Gas price provided by the sender"""
  gasPrice
  """Gas provided by the sender"""
  gas
}

enum HarmonyStakingTransactionsUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique block"""
  ledger
  """Unique address validator"""
  validator_address
  """Unique delegator validator"""
  delegator_address
  """Unique smart contract addresses"""
  smart_contract_address
}

"""Transactions in Harmony blockchain"""
type HarmonyTransactions {
  any(of: HarmonyTransactionsMeasureable!): String
  """Hash of the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyTransactionsUniq): Int
  countBigInt(uniq: HarmonyTransactionsUniq): BigInt
  """Transaction creates"""
  creates(creates: HashSelector): String
  """Data"""
  data: String
  """The date this transaction was created"""
  date: Date
  """Epoch"""
  epoch: BigInt
  expression(get: String!): DecimalNumber
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, epoch: BigIntegerSelector, nonce: BigIntegerSelector, transactionHash: StringSelector, transactionIndex: HashSelector, ledger: BigIntIdSelector, creates: StringSelector, sender: HashSelector, receiver: HashSelector, success: Boolean, status: Boolean): Float
  """Gas price provided by the sender"""
  gasPrice: String
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, shardId: BigIntegerSelector, toShardId: BigIntegerSelector, epoch: BigIntegerSelector, nonce: BigIntegerSelector, transactionHash: StringSelector, transactionIndex: HashSelector, ledger: BigIntIdSelector, creates: StringSelector, sender: HashSelector, receiver: HashSelector, success: Boolean, status: Boolean): Float
  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyTransactionsMeasureable!, get: HarmonyTransactionsMeasureable): String
  minimum(of: HarmonyTransactionsMeasureable!, get: HarmonyTransactionsMeasureable): String
  """The number of transactions made by the sender prior to this one"""
  nonce: BigInt
  """Address of the receiver"""
  receiver(receiver: HashSelector): String
  """Address of the sender"""
  sender(sender: HashSelector): String
  """ShardID"""
  shardId: BigInt
  """Status"""
  status(status: Boolean): Boolean
  """Successful of not"""
  success(success: Boolean): Boolean
  """The time this transaction was created"""
  time: DateTime
  """ToShardID"""
  toShardId: BigInt
  """Integer of the transactions index position in the block. null when its pending."""
  transactionHash(transactionHash: HashSelector): String
  """Index of the transaction"""
  transactionIndex(transactionIndex: HashSelector): Int
  """Value transferred in ATTO"""
  value: String
}

input HarmonyTransactionsFilter {
  date: DateSelector
  time: DateTimeSelector
  shardId: BigIntegerSelector
  toShardId: BigIntegerSelector
  epoch: BigIntegerSelector
  nonce: BigIntegerSelector
  transactionHash: StringSelector
  transactionIndex: HashSelector
  ledger: BigIntIdSelector
  creates: StringSelector
  sender: HashSelector
  receiver: HashSelector
  success: Boolean
  status: Boolean
}

enum HarmonyTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Transaction Hash"""
  transactionHash
  """Transaction Index"""
  transactionIndex
  """Gas price provided by the sender"""
  gas_price
  """Validator Address"""
  sender
  """Deligator Address"""
  receiver
  """Value transferred in ATTO"""
  value
  """Gas price provided by the sender"""
  gasPrice
  """Gas value provided by the sender"""
  gasValue
  """Gas provided by the sender"""
  gas
  """Shard ID"""
  shardId
  """To Shard ID"""
  toShardId
  """Status"""
  status
  """Success"""
  success
}

enum HarmonyTransactionsUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique block"""
  ledger
  """Unique sender"""
  sender
  """Unique receiver"""
  receiver
}

"""Transfers in Harmony blockchain"""
type HarmonyTransfers {
  any(of: HarmonyTransfersMeasureable!): String
  """Hash of the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: HarmonyTransfersUniq): Int
  countBigInt(uniq: HarmonyTransfersUniq): BigInt
  """Currency of transfer"""
  currency(currency: CurrencySelector): Currency
  """Data"""
  data: String
  """The date this transaction was created"""
  date: Date
  """Entity"""
  entityId: Int
  """Epoch"""
  epoch: BigInt
  expression(get: String!): DecimalNumber
  """External"""
  external(external: Boolean): Boolean
  """Gas provided by the sender"""
  gas: BigInt
  """Gas price provided by the sender"""
  gasPrice: String
  gasValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, ledger: BlockSelector, blockHash: HashSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, sender: HashSelector, transferFrom: AddressSelector, transferTo: AddressSelector, status: Boolean, success: Boolean, currency: CurrencySelector, entityId: IntIdSelector): Float
  """Hash of the block where this transaction was in"""
  ledger(ledger: BlockSelector): BigInt
  maximum(of: HarmonyTransfersMeasureable!, get: HarmonyTransfersMeasureable): String
  minimum(of: HarmonyTransfersMeasureable!, get: HarmonyTransfersMeasureable): String
  """The number of transactions made by the sender prior to this one"""
  nonce: BigInt
  """ShardID"""
  shardId: BigInt
  """Staking Tx Type"""
  stakingTxType: String
  """Status"""
  status(status: Boolean): Boolean
  """Successful of not"""
  success(success: Boolean): Boolean
  """The time this transaction was created"""
  time: DateTime
  """TO Shard ID"""
  toShardId: BigInt
  """Integer of the transactions index position in the block. null when its pending."""
  transactionHash(transactionHash: HashSelector): String
  """Index of the transaction"""
  transactionIndex(transactionIndex: HashSelector): Int
  """Address of the payer"""
  transferFrom(transferFrom: HashSelector): Address
  """Address of the receiver"""
  transferTo(transferTo: HashSelector): Address
  """Address of transaction sender"""
  txSender: String
  """Address of transaction receiver"""
  txTo: String
  """Value transferred in ATTO"""
  value: String
}

input HarmonyTransfersFilter {
  date: DateSelector
  time: DateTimeSelector
  ledger: BlockSelector
  blockHash: HashSelector
  transactionHash: HashSelector
  transactionIndex: IntegerSelector
  sender: HashSelector
  transferFrom: AddressSelector
  transferTo: AddressSelector
  status: Boolean
  success: Boolean
  currency: CurrencySelector
  entityId: IntIdSelector
}

enum HarmonyTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  ledger
  """Block Hash"""
  block_hash
  """Transaction Hash"""
  transaction_hash
  """Gas price provided by the sender"""
  gas_price
  """Validator Address"""
  sender
  """Value transferred in ATTO"""
  value
  """Gas value provided by the sender"""
  gas_value
  """Gas provided by the sender"""
  gas
  """Staking Tx Type"""
  staking_tx_type
  """Currency symbol"""
  currency_symbol
  """Token address"""
  currency_address
  """Token ID"""
  token_id
  """Token type"""
  token_type
  """Token From"""
  transfer_from
  """Token To"""
  transfer_to
  """Tx Sender"""
  tx_sender
  """Tx To"""
  tx_to
  """Tx To"""
  entity_id
}

enum HarmonyTransfersUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique block"""
  ledger
  """Unique sender"""
  sender
  """Unique transfer from"""
  transfer_from
  """Unique transfer to"""
  transfer_to
}

"""Select by hash"""
input HashSelector {
  """Hash is"""
  is: String
  """Hash not"""
  not: String
  """Hash in the list"""
  in: [String!]
  """Hash not in the list"""
  notIn: [String!]
}

"""Hedera Chain"""
type Hedera {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [HederaAddressInfoWithBalance!]!
  """Blockchain Arguments"""
  arguments(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean, any: [HederaArgumentFilter!], options: QueryOptions): [HederaArgument!]
  """Blockhain Calls"""
  calls(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, callInput: HashSelector, callResult: HashSelector, success: Boolean, any: [HederaCallFilter!], options: QueryOptions): [HederaCall!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [HederaCoinpath!]
  """Blockhain Inputs"""
  inputs(date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!], any: [HederaInputFilter!], options: QueryOptions): [HederaInput!]
  """Blockhain Messages"""
  messages(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaMessageFilter!], options: QueryOptions): [HederaMessage!]
  """Blockchain Outputs"""
  outputs(date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaOutputFilter!], options: QueryOptions): [HederaOutput!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, any: [HederaTransactionFilter!], options: QueryOptions): [HederaTransaction!]
}

"""Address detailed information for Hedera network"""
type HederaAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Native currency balance"""
  balance(in: BaseCurrencyEnum): Float
  """Token balances"""
  tokenBalances: [HederaBalance!]
}

"""Arguments in Hedera blockchain"""
type HederaArgument {
  any(of: HederaArgumentsMeasureable!): String
  """Argument type"""
  argtype: String
  """Argument"""
  argument: String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaArgumentsUniq): Int
  countBigInt(uniq: HederaArgumentsUniq): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maximum(of: HederaArgumentsMeasureable!, get: HederaArgumentsMeasureable): String
  memo: String
  minimum(of: HederaArgumentsMeasureable!, get: HederaArgumentsMeasureable): String
  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account
  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account
  """Transaction result"""
  result(result: HashSelector): TransactionResult
  """Smart contract"""
  smartContractEntity: Account
  """Success"""
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
  """Value"""
  value: String
}

input HederaArgumentFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  success: Boolean
}

enum HederaArgumentsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Valid start"""
  valid_start
  """Valid duration"""
  valid_duration
  """Transaction Hash"""
  transaction_hash
  """Max Fee"""
  max_fee
  """Charged Fee"""
  transaction_fee
}

enum HederaArgumentsUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique consensus time"""
  consensus_times
  """Unique payer account"""
  payer_account
  """Unique node account"""
  node_account
  """Unique node account"""
  smart_contract_entity
  """Unique initial balance"""
  initial_balance
}

"""Token Balance"""
type HederaBalance {
  """Staking Balance"""
  balance: Float
  """Token ID"""
  tokenId: String
}

"""Calls in Hedera blockchain"""
type HederaCall {
  any(of: HederaCallsMeasureable!): String
  """Call input"""
  callInput(callInput: HashSelector): String
  """Call input"""
  callResult(callResult: HashSelector): String
  chargedTxFee: BigInt
  consensusTimestamp: Timestamp
  count(uniq: HederaCallsUniq): Int
  countBigInt(uniq: HederaCallsUniq): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Currency of transfer"""
  feeCurrency: Currency
  gas(calculate: AmountAggregateFunction, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, callInput: HashSelector, callResult: HashSelector, success: Boolean): Int
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  maximum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String
  memo: String
  minimum(of: HederaCallsMeasureable!, get: HederaCallsMeasureable): String
  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account
  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account
  """Transaction result"""
  result(result: HashSelector): TransactionResult
  """Smart contract"""
  smartContractEntity: Account
  """Success"""
  success(success: Boolean): Boolean
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, smartContractEntity: StringSelector, transactionHash: HashSelector, result: HashSelector, success: Boolean): Float
  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaCallFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  smartContractEntity: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  callInput: HashSelector
  callResult: HashSelector
  success: Boolean
}

enum HederaCallsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Valid start"""
  valid_start
  """Valid duration"""
  valid_duration
  """Transaction Hash"""
  transaction_hash
  """Max Fee"""
  max_fee
  """Charged Fee"""
  transaction_fee
}

enum HederaCallsUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique consensus time"""
  consensus_times
  """Unique payer account"""
  payer_account
  """Unique node account"""
  node_account
  """Unique node account"""
  smart_contract_entity
  """Unique initial balance"""
  initial_balance
}

"""Coinpath"""
type HederaCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Attributes of transaction included in Coinpath result"""
  transactions: [CoinpathEntry!]
}

"""Currency selector in Hedera blockchain."""
input HederaCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

"""Inputs in Hedera blockchain"""
type HederaInput {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  any(of: HederaInputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaInputsUniq): Int
  countBigInt(uniq: HederaInputsUniq): BigInt
  """Currency of transfer"""
  currency(currency: HederaCurrencySelector): Currency
  """Calendar date"""
  date: Date
  """Entity"""
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber
  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String
  memo: String
  minimum(of: HederaInputMeasureable!, get: HederaInputMeasureable): String
  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account
  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account
  """Transaction result"""
  result(result: HashSelector): TransactionResult
  """Success"""
  success(success: Boolean): Boolean
  """Calendar time"""
  time: DateTime
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  """Transfer Account"""
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaInputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
  amount: [AmountSelector!]
}

enum HederaInputMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Valid start"""
  valid_start
  """Valid duration"""
  valid_duration
  """Transaction Hash"""
  transaction_hash
  """Max Fee"""
  max_fee
  """Charged Fee"""
  transaction_fee
  """Amount"""
  amount
  """Currency Symbol"""
  currency_symbol
  """Currency Address"""
  currency_address
  """Token Type"""
  token_type
  """Token ID"""
  token_id
}

enum HederaInputsUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique consensus time"""
  consensus_times
  """Unique payer account"""
  payer_account
  """Unique node account"""
  node_account
  """Unique entity id"""
  entity_id
  """Unique entity type"""
  entity_type
  """Unique initial balance"""
  initial_balance
}

"""Messages in Hedera blockchain"""
type HederaMessage {
  any(of: HederaMessageMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaMessagesUniq): Int
  countBigInt(uniq: HederaMessagesUniq): BigInt
  """Calendar date"""
  date: Date
  """Entity"""
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber
  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String
  memo: String
  message: String
  minimum(of: HederaMessageMeasureable!, get: HederaMessageMeasureable): String
  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account
  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account
  """Transaction result"""
  result(result: HashSelector): TransactionResult
  """Success"""
  success(success: Boolean): Boolean
  """Calendar date time"""
  time: DateTime
  """Transaction running hash"""
  topicRunningHash(topicRunningHash: StringSelector): String
  """Transaction running hash"""
  topicSequenceNumber(topicSequenceNumber: HashSelector): String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, transactionRunningHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaMessageFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  transactionRunningHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaMessageMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Valid start"""
  valid_start
  """Valid duration"""
  valid_duration
  """Transaction Hash"""
  transaction_hash
  """Max Fee"""
  max_fee
  """Charged Fee"""
  transaction_fee
}

enum HederaMessagesUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique consensus time"""
  consensus_times
  """Unique payer account"""
  payer_account
  """Unique node account"""
  node_account
  """Unique entity id"""
  entity_id
  """Unique entity type"""
  entity_type
  """Unique initial balance"""
  initial_balance
}

enum HederaNetwork {
  """The Hedera mainnet"""
  hedera
  """The Hedera testnets"""
  hedera_testnets
}

"""Outputs in Hedera blockchain"""
type HederaOutput {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean, amount: [AmountSelector!]): Float
  any(of: HederaOutputMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaOutputUniq): Int
  countBigInt(uniq: HederaOutputUniq): BigInt
  """Currency of transfer"""
  currency(currency: HederaCurrencySelector): Currency
  """Calendar date"""
  date: Date
  """Entity"""
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber
  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String
  memo: String
  minimum(of: HederaOutputMeasureable!, get: HederaOutputMeasureable): String
  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account
  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account
  """Transaction result"""
  result(result: HashSelector): TransactionResult
  """Success"""
  success(success: Boolean): Boolean
  """Calendar time"""
  time: DateTime
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, transferEntity: StringSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  transactionValidDurationInSec: Int
  """Transfer Account"""
  transferEntity: Account
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaOutputFilter {
  date: DateSelector
  transferEntity: StringSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaOutputMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Valid start"""
  valid_start
  """Valid duration"""
  valid_duration
  """Transaction Hash"""
  transaction_hash
  """Max Fee"""
  max_fee
  """Charged Fee"""
  transaction_fee
  """Amount"""
  amount
  """Currency Symbol"""
  currency_symbol
  """Currency Address"""
  currency_address
  """Token Type"""
  token_type
  """Token ID"""
  token_id
}

enum HederaOutputUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique consensus time"""
  consensus_times
  """Unique Transfer entity"""
  transfer_entity
  """Unique payer account"""
  payer_account
  """Unique node account"""
  node_account
  """Unique entity id"""
  entity_id
  """Unique entity type"""
  entity_type
  """Unique initial balance"""
  initial_balance
}

"""Transactions in Hedera blockchain"""
type HederaTransaction {
  any(of: HederaTransactionMeasureable!): String
  consensusTimestamp: Timestamp
  count(uniq: HederaTransactionsUniq): Int
  countBigInt(uniq: HederaTransactionsUniq): BigInt
  """Calendar date"""
  date: Date
  """Entity"""
  entity(entityType: EntityTypeSelector): Entity
  expression(get: String!): DecimalNumber
  """Currency of transfer"""
  feeCurrency: Currency
  initialBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  maximum(of: HederaTransactionMeasureable!, get: HederaTransactionMeasureable): String
  memo: String
  minimum(of: HederaTransactionMeasureable!, get: HederaTransactionMeasureable): String
  """
  Used to reference a specific
        account of the node the transaction is being sent to
  """
  nodeAccount: Account
  """
  Used to
        reference a specific account in transactions
  """
  payerAccount: Account
  """Transaction result"""
  result(result: HashSelector): TransactionResult
  """Success"""
  success(success: Boolean): Boolean
  """Calendar time"""
  time: DateTime
  transactionBytes: String
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, nodeAccount: StringSelector, payerAccount: StringSelector, transactionHash: HashSelector, result: HashSelector, entityType: EntityTypeSelector, success: Boolean): Float
  """Transaction hash where transfer happened"""
  transactionHash(transactionHash: HashSelector): String
  """Transaction Type"""
  transactionType: String
  transactionValidDurationInSec: Int
  validStart(time: DateTimeSelector, nanoseconds: BigInt): Timestamp
}

input HederaTransactionFilter {
  date: DateSelector
  nodeAccount: StringSelector
  payerAccount: StringSelector
  transactionHash: HashSelector
  result: HashSelector
  entityType: EntityTypeSelector
  success: Boolean
}

enum HederaTransactionMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Valid start"""
  valid_start
  """Valid duration"""
  valid_duration
  """Transaction Hash"""
  transaction_hash
  """Max Fee"""
  max_fee
  """Charged Fee"""
  transaction_fee
}

enum HederaTransactionsUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique consensus time"""
  consensus_times
  """Unique transaction type"""
  transaction_type
  """Unique payer account"""
  payer_account
  """Unique node account"""
  node_account
  """Unique entity id"""
  entity_id
  """Unique entity type"""
  entity_type
  """Unique initial balance"""
  initial_balance
}

"""Input Script Type of UTXO transaction input"""
type InputScript {
  """Script annotation"""
  annotation: String
  """Long script pattern"""
  pattern: String!
  """Short script pattern"""
  shortPattern: String!
  """Simple script pattern"""
  simplePattern: String!
  """Script type"""
  type: String
}

"""Solana Instruction"""
type Instruction {
  action: Action
  callPath: String
  external: Boolean
  program: Program
}

"""Solana Instruction"""
type InstructionWithExternals {
  action: Action
  callPath: String
  external: Boolean
  externalAction: Action
  externalProgram: Program
  program: Program
}

"""Select limited upper number"""
input IntegerLimitedSelector {
  """is"""
  is: Int
  """in the list"""
  in: [Int!]
  """less than"""
  lt: Int
  """less or equal than"""
  lteq: Int
  """in range"""
  between: [Int!]
}

"""Select by number"""
input IntegerSelector {
  """is"""
  is: Int
  """not"""
  not: Int
  """in the list"""
  in: [Int!]
  """not in the list"""
  notIn: [Int!]
  """greater than"""
  gt: Int
  """less than"""
  lt: Int
  """less or equal than"""
  lteq: Int
  """greater or equal than"""
  gteq: Int
  """in range"""
  between: [Int!]
}

"""Select by ID"""
input IntIdSelector {
  """ID is"""
  is: Int
  """ID not"""
  not: Int
  """ID in the list"""
  in: [Int!]
  """ID not in the list"""
  notIn: [Int!]
  """ID greater than"""
  gt: Int
  """ID less than"""
  lt: Int
  """ID less or equal than"""
  lteq: Int
  """ID greater or equal than"""
  gteq: Int
  """ID in range"""
  between: [Int!]
}

"""An ISO 8601-encoded date"""
scalar ISO8601Date

"""An ISO 8601-encoded datetime"""
scalar ISO8601DateTime

"""Libra"""
type Libra {
  """Libra Network Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector, any: [LibraBlockFilter!], options: QueryOptions): [LibraBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [LibraCoinpath!]
  """Libra Network Currency Minting"""
  mints(date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!], any: [LibraMintFilter!], options: QueryOptions): [LibraMints!]
  """Libra Network Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector, any: [LibraTransactionFilter!], options: QueryOptions): [LibraTransactions!]
  """Libra Network Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector, any: [LibraTransferFilter!], options: QueryOptions): [LibraTransfers!]
}

"""Block"""
type LibraBlock {
  any(of: LibraBlocksMeasureable!): String
  count(uniq: LibraBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): Int
  countBigInt(uniq: LibraBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  gasUsed(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, proposer: [AddressSelector!], metadata: StringSelector): Float
  """Block round in blockchain"""
  height(height: BlockSelector): Int!
  """Key"""
  key: String
  maximum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String
  """Metadata"""
  metadata(metadata: StringSelector): String
  minimum(of: LibraBlocksMeasureable!, get: LibraBlocksMeasureable): String
  """Proposer"""
  proposer(proposer: AddressSelector): Address
  """Sequence number"""
  sequenceNumber: Int
  """Status Name"""
  statusName: String
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Version of transaction for this block"""
  version(version: IntegerSelector): Int!
  """Version hash of transaction for this block"""
  versionHash: String!
  """VM Status"""
  vmStatus: Int
}

input LibraBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  proposer: [AddressSelector!]
  metadata: StringSelector
}

enum LibraBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block round"""
  block
  """Version"""
  version
  """Proposer"""
  proposer
  """Gas Used"""
  gas_used
}

enum LibraBlockUniq {
  """Proposer"""
  proposer
  """Unique date count"""
  dates
}

"""Coinpath"""
type LibraCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: LibraCoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String
  minimum(of: LibraCoinpathMeasureable!, get: LibraCoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Transaction of transfer happened"""
  transaction: LibraTransactionValue
}

enum LibraCoinpathMeasureable {
  """Time"""
  time
  """Block"""
  block
  """Version"""
  version
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Depth"""
  depth
}

"""
Currency selector in Libra blockchain.
Libra has native chain currency (LBR) and a number of others ( Coin1/Coin2 ) for Testnet.
Use name of currency for selection
"""
input LibraCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

input LibraMintFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  version: IntegerSelector
  minter: AddressSelector
  currency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
}

"""Mints in Libra blockchain"""
type LibraMints {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): Float
  any(of: LibraMintsMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraMintsUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): Int
  countBigInt(uniq: LibraMintsUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, version: IntegerSelector, minter: AddressSelector, currency: [LibraCurrencySelector!], amount: [AmountSelector!]): BigInt
  """Currency of transfer"""
  currency(currency: [LibraCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String
  minimum(of: LibraMintsMeasureable!, get: LibraMintsMeasureable): String
  """Minter"""
  minter(sender: AddressSelector): Address
  """Sequence number"""
  sequenceNumber: Int
  """Status Name"""
  statusName: String
  """Success"""
  success(success: Boolean): Boolean
  """Mint timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!
  """Version hash of blockchain for this transaction"""
  versionHash: String!
  """VM Status"""
  vmStatus: Int
}

enum LibraMintsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Version"""
  version
  """Mint version hash"""
  version_hash
  """Amount"""
  amount
  """Minter"""
  minter
  """Currency symbol"""
  currency_symbol
}

enum LibraMintsUniq {
  """Unique blocks"""
  blocks
  """Unique versions"""
  versions
  """Unique date count"""
  dates
  """Unique minters"""
  minters
  """Unique currencies"""
  currencies
}

input LibraTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  scriptType: ScriptTypeSelectorSelector
  success: Boolean
  gasCurrency: [LibraCurrencySelector!]
  scriptHash: StringSelector
}

"""Transactions in Libra blockchain"""
type LibraTransactions {
  any(of: LibraTransactionsMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: LibraTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Int
  countBigInt(uniq: LibraTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): BigInt
  """Calendar date"""
  date: Date
  """Expiration Time"""
  expirationTime: DateTime
  expression(get: String!): DecimalNumber
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Int
  """Currency of gas"""
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency
  """Gas unit price"""
  gasPrice(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, scriptType: ScriptTypeSelectorSelector, success: Boolean, gasCurrency: [LibraCurrencySelector!], scriptHash: StringSelector): Float
  """Max gas amount"""
  maxGasAmount: Int
  maximum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String
  minimum(of: LibraTransactionsMeasureable!, get: LibraTransactionsMeasureable): String
  """Public key"""
  publicKey: String
  """Script Hash"""
  scriptHash(scriptHash: StringSelector): String
  """Script Type"""
  scriptType: ScriptTypeSelectorSelector
  """Transaction sender"""
  sender(txSender: AddressSelector): Address
  """Sequence number"""
  sequenceNumber: Int
  """Signature"""
  signature: String
  """Signature scheme"""
  signatureScheme: String
  """Status Name"""
  statusName: String
  """Success"""
  success(success: Boolean): Boolean
  """Transaction timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!
  """Version hash of blockchain for this transaction"""
  versionHash: String!
  """VM Status"""
  vmStatus: Int
}

enum LibraTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Version"""
  version
  """Transaction Sender"""
  tx_sender
  """Script Hash"""
  script_hash
  """Gas price"""
  gas_price
  """Gas used"""
  gas
}

enum LibraTransactionsUniq {
  """Unique blocks"""
  blocks
  """Unique versions"""
  versions
  """Unique date count"""
  dates
  """Unique transaction senders"""
  senders
  """Unique transaction script hashes"""
  scripts
}

"""Blockchain transaction with value"""
type LibraTransactionValue {
  """Transaction value"""
  value: Float!
  """Transaction version"""
  version: Int!
}

input LibraTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  version: IntegerSelector
  txSender: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: [LibraCurrencySelector!]
  gasCurrency: [LibraCurrencySelector!]
  amount: [AmountSelector!]
  scriptType: ScriptTypeSelectorSelector
  scriptHash: StringSelector
}

"""Transfers in Libra blockchain"""
type LibraTransfers {
  amount(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float
  any(of: LibraTransfersMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): BigInt
  """Currency of transfer"""
  currency(currency: [LibraCurrencySelector!]): Currency
  """Calendar date"""
  date: Date
  """Expiration Time"""
  expirationTime: DateTime
  expression(get: String!): DecimalNumber
  gas(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Int
  """Currency of gas"""
  gasCurrency(gasCurrency: [LibraCurrencySelector!]): Currency
  """Gas price"""
  gasPrice: Float!
  gasValue(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, version: IntegerSelector, txSender: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: [LibraCurrencySelector!], gasCurrency: [LibraCurrencySelector!], amount: [AmountSelector!], scriptType: ScriptTypeSelectorSelector, scriptHash: StringSelector): Float
  """Max gas amount"""
  maxGasAmount: Int
  maximum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String
  minimum(of: LibraTransfersMeasureable!, get: LibraTransfersMeasureable): String
  """Public key"""
  publicKey: String
  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address
  """Script Hash"""
  scriptHash(scriptHash: StringSelector): String
  """Script Type"""
  scriptType: ScriptTypeSelectorSelector
  """Transfer sender"""
  sender(sender: AddressSelector): Address
  """Sequence number"""
  sequenceNumber: Int
  """Signature"""
  signature: String
  """Signature scheme"""
  signatureScheme: String
  """Status Name"""
  statusName: String
  """Success"""
  success(success: Boolean): Boolean
  """Transfer timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """Transaction sender"""
  txSender(txSender: AddressSelector): Address
  """Version of blockchain for this transaction"""
  version(version: IntegerSelector): Int!
  """Version hash of blockchain for this transaction"""
  versionHash: String!
  """VM Status"""
  vmStatus: Int
}

enum LibraTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  height
  """Version"""
  version
  """Version hash"""
  version_hash
  """Amount"""
  amount
  """Transfer Sender"""
  tx_sender
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Script Hash"""
  script_hash
  """Currency symbol"""
  currency_symbol
  """Gas value"""
  gas_value
  """Gas price"""
  gas_price
  """Gas used"""
  gas
}

"""Limit by definition"""
input LimitByOption {
  """Take limit for each combination of the field"""
  each: String!
  """Limit number of results"""
  limit: Int
  """Offset of results, starting from 0"""
  offset: Int
}

"""Solana Log"""
type Log {
  consumed: BigInt!
  instruction: String!
  logs: String!
  result: String!
  totalGas: BigInt!
}

"""Blockchain message"""
type MessageHash {
  """Message hash hex representation"""
  messageHash: String!
}

"""Smart contract method"""
type Method {
  """Name"""
  name: String
  """Signature"""
  signature: String
  """Signature Hash"""
  signatureHash: String!
}

"""Smart contract method. In selector you can use the name, signature or hex hash"""
input MethodSelector {
  """Method signature is"""
  is: String
  """Method signature not"""
  not: String
  """Method signature in the list"""
  in: [String!]
  """Method signature not in the list"""
  notIn: [String!]
}

"""Query metric object"""
type Metric {
  """Metric cost"""
  cost: Float!
  """Metric divider"""
  divider: BigInt!
  """Metric maximum"""
  max: BigInt!
  """Metric maximum unit"""
  maxUnit: Float!
  """Metric minimum"""
  min: BigInt!
  """Metric minimum unit"""
  minUnit: Float!
  """Metric name"""
  name: String!
  """Metric price"""
  price: Float!
  """Metric value"""
  value: BigInt!
  """Metric value unit"""
  valueUnit: Float!
}

"""Query metrics"""
type Metrics {
  """Graphql query ID"""
  id: String!
  """Metrics"""
  list: [Metric!]!
  """Points"""
  points: Float!
  """SQL requests count"""
  sqlRequestsCount: Int!
}

"""Information about miniblock"""
type MiniblockElrond {
  """Miniblock hash"""
  hash: String
  """Hash of the receiver block"""
  receiverBlockHash: String
  """Number of the receiver shard"""
  receiverShard: String
  """Miniblock type"""
  type: String
}

"""Name with an identifier"""
type NameWithId {
  """ID"""
  id: Int
  """Name"""
  name: String
}

enum Network {
  """Ethereum Mainnet"""
  ethereum
  """Ethereum Classic"""
  ethclassic
  """Ethereum PoW"""
  ethpow
  """Ethereum Classic ( no reorg from block 10904146)"""
  ethclassic_reorg
  """Binance DEX"""
  binance
  """Celo Alfajores Testnet"""
  celo_alfajores
  """Celo Baklava Testnet"""
  celo_baklava
  """DEPRECATED. Use celo_mainnet"""
  celo_rc1
  """Celo Mainnet"""
  celo_mainnet
  """Bitcoin ( BTC )"""
  bitcoin
  """Bitcoin Cash ( BCH )"""
  bitcash
  """Bitcoin SV ( BSV )"""
  bitcoinsv
  """Litecoin ( LTC )"""
  litecoin
  """Dash ( DASH )"""
  dash
  """Dogecoin ( DOGE )"""
  dogecoin
  """Cardano ( ADA )"""
  cardano
  """Zcash ( ZEC )"""
  zcash
  """Algorand Mainnet (ALGO)"""
  algorand
  """Algorand Testnet"""
  algorand_testnet
  """Algorand Betanet"""
  algorand_betanet
  """Conflux Oceanus"""
  conflux_oceanus
  """Conflux Tethys"""
  conflux_tethys
  """Conflux Hydra"""
  conflux_hydra
  """Libra Testnet"""
  libra_testnet
  """Diem Testnet"""
  diem_testnet
  """EOS Mainnet"""
  eos
  """TRON Mainnet"""
  tron
  """Binance Smart Chain Mainnet"""
  bsc
  """Binance Smart Chain Testnet"""
  bsc_testnet
  """Goerli Ethereum Testnet"""
  goerli
  """Beacon Chain Ethereum 2.0"""
  eth2
  """Medalla Ethereum 2.0 Beacon Testnet"""
  medalla
  """Filecoin Mainnet"""
  filecoin
  """Hedera Hashgraph"""
  hedera
  """Solana Mainnet"""
  solana
  """Matic (Polygon) Mainnet"""
  matic
  """Velas Mainnet"""
  velas
  """Velas Testnet"""
  velas_testnet
  """Klaytn Mainnet"""
  klaytn
  """Elrond Mainnet"""
  elrond
  """Flow Mainnet"""
  flow
  """Avalanche C-chain"""
  avalanche
  """Fantom Mainnet"""
  fantom
  """Moonbeam Mainnet"""
  moonbeam
  """Cronos Mainnet"""
  cronos
  """Cosmos Hub"""
  cosmoshub
  """Heimdall (Matic Verification Network)"""
  heimdall
  """Crypto.org Mainnet"""
  crypto_mainnet
  """Crypto.org Croeseid Testnet"""
  crypto_testnet
  """Terra Mainnet"""
  terra
  """Stellar Ledger"""
  stellar
  """Ripple XRP Ledger"""
  ripple
  """Harmony Mainnet"""
  harmony
  """Harmony Testnet"""
  harmony_testnet
  """Tezos"""
  tezos
  """Everscale"""
  everscale
}

"""Blockchain operation"""
type OperationIndexed {
  """Operation index"""
  index: Int!
  """Operation name"""
  name: String!
}

"""Blockchain operation"""
type OperationIndexedWithAccount {
  """Operation index"""
  index: Int!
  """Operation name"""
  name: String!
  """Operation account"""
  sourceAccount: Address!
}

"""Select order by ID"""
input OrderIdSelector {
  """Order ID is"""
  is: String
  """Order ID not"""
  not: String
  """Order ID in the list"""
  in: [String!]
  """Order ID not in the list"""
  notIn: [String!]
}

"""Select by order side"""
input OrderSideSelector {
  """Order Side is"""
  is: BinanceOrderSide
  """Order Side not"""
  not: BinanceOrderSide
  """Order Side in the list"""
  in: [BinanceOrderSide!]
  """Order Side not in the list"""
  notIn: [BinanceOrderSide!]
}

"""Select by order status"""
input OrderStatusSelector {
  """Order Status is"""
  is: BinanceOrderStatus
  """Order Status not"""
  not: BinanceOrderStatus
  """Order Status in the list"""
  in: [BinanceOrderStatus!]
  """Order Status not in the list"""
  notIn: [BinanceOrderStatus!]
}

"""Select by order time in force"""
input OrderTimeInForceSelector {
  """Order TimeInForce is"""
  is: BinanceOrderTimeInForce
  """Order TimeInForce not"""
  not: BinanceOrderTimeInForce
  """Order TimeInForce in the list"""
  in: [BinanceOrderTimeInForce!]
  """Order TimeInForce not in the list"""
  notIn: [BinanceOrderTimeInForce!]
}

"""Select by order type"""
input OrderTypeSelector {
  """Order Type is"""
  is: BinanceOrderType
  """Order Type not"""
  not: BinanceOrderType
  """Order Type in the list"""
  in: [BinanceOrderType!]
  """Order Type not in the list"""
  notIn: [BinanceOrderType!]
}

"""Select by output index ( o based )"""
input OutputIndexSelector {
  """Output index is"""
  is: Int
  """Output index not"""
  not: Int
  """Output index in the list"""
  in: [Int!]
  """Output index not in the list"""
  notIn: [Int!]
  """Output index greater than"""
  gt: Int
  """Output index less than"""
  lt: Int
  """Output index less or equal than"""
  lteq: Int
  """Output index greater or equal than"""
  gteq: Int
  """Output index in range"""
  between: [Int!]
}

"""Output Script Type of UTXO transaction output"""
type OutputScript {
  """Script annotation"""
  annotation: String
  """Long script pattern"""
  pattern: String!
  """Short script pattern"""
  short: String!
  """Simple script pattern"""
  simplePattern: String!
  """Script type"""
  type: String
}

enum PriceAggregateFunction {
  """Maximum"""
  maximum
  """Minimum"""
  minimum
  """Aggregated over interval"""
  sum
  """Average"""
  average
  """Median"""
  median
  """Any value"""
  any
  """Last value"""
  anyLast
}

"""Solana Program"""
type Program {
  id: String!
  name: String!
  parsed: Boolean!
  parsedName: String!
}

enum Protocol {
  """Ethereum"""
  ethereum
  """Conflux"""
  conflux
  """Binance DEX"""
  binance
  """Bitcoin"""
  bitcoin
  """Algorand"""
  algorand
  """Libra"""
  libra
  """EOS"""
  eos
  """Tron"""
  tron
  """Filecoin"""
  filecoin
  """Hedera Hashgraph"""
  hedera
  """Solana"""
  solana
  """Cardano"""
  cardano
  """Elrond"""
  elrond
  """Flow"""
  flow
  """Cosmos"""
  cosmos
  """Stellar Ledger"""
  stellar
  """Ripple XRP Ledger"""
  ripple
  """Harmony"""
  harmony
  """Tezos"""
  tezos
  """Everscale"""
  everscale
}

"""Blockchain Unified GraphQL API"""
type Query {
  """Algorand Chains Dataset"""
  algorand(network: AlgorandNetwork): Algorand
  """Binance DEX Chain Dataset"""
  binance: Binance
  """Bitcoin and other UTXO Chains Dataset"""
  bitcoin(network: BitcoinNetwork): Bitcoin
  """Cardano Chain Dataset"""
  cardano(network: CardanoNetwork): Cardano
  """Conflux Chains Dataset"""
  conflux(network: ConfluxNetwork): Conflux
  """Cosmos Dataset"""
  cosmos(network: CosmosNetwork): Cosmos
  """Diem ( former Libra ) Testnet Dataset"""
  diem(network: DiemNetwork): Libra
  """Elrond Dataset"""
  elrond(network: ElrondNetwork): Elrond
  """EOS Mainnet Dataset"""
  eos(network: EosNetwork): Eos
  """Ethereum Mainnet / Classic Chain Datasets"""
  ethereum(network: EthereumNetwork): Ethereum
  """Ethereum v2.0 Beacon Chain Datasets"""
  ethereum2(network: Ethereum2Network): Ethereum2
  """Everscale Dataset"""
  everscale(network: EverscaleNetwork): Everscale
  """Filecoin Dataset"""
  filecoin(network: FilecoinNetwork): Filecoin
  """Flow Dataset"""
  flow(network: FlowNetwork): Flow
  """Harmony Dataset"""
  harmony(network: HarmonyNetwork): Harmony
  """Hedera Dataset"""
  hedera(network: HederaNetwork): Hedera
  """Query metrics"""
  metrics(queryId: String!, options: SeedOptions): Metrics @deprecated(reason: "DEPRECATED! Please use utilities { metrics }")
  """Ripple Dataset"""
  ripple(network: RippleNetwork): Ripple
  """Search by query string"""
  search(string: String!, limit: Int, offset: Int, network: Network): [Result!]
  """Solana Dataset"""
  solana(network: SolanaNetwork): Solana
  """Stellar Dataset"""
  stellar(network: StellarNetwork): Stellar
  """Tezos Dataset"""
  tezos(network: TezosNetwork): Tezos
  """Tron Mainnet Dataset"""
  tron(network: TronNetwork): Tron
  """Utilities"""
  utilities: Utilities
}

"""Limits, Ordering, Constraints"""
input QueryOptions {
  """Limit number of results"""
  limit: Int
  """Limit number of results by specific field"""
  limitBy: LimitByOption
  """Offset of results, starting from 0"""
  offset: Int
  """Ordering field(s) for ascending"""
  asc: [String!]
  """Ordering field(s) for descending"""
  desc: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for descending"""
  descByInteger: [String!]
  """Converting field(s) to integer datatype and then ordering field(s) for ascending"""
  ascByInteger: [String!]
}

"""Solana Receiver"""
type Receiver {
  address: String!
  mintAccount: String!
  type: String!
}

"""Search result item"""
type Result {
  """Blockchain where result is found"""
  network: BlockchainNetwork!
  """Subject in blockchain"""
  subject: Subject!
}

"""Select by reward type"""
input RewardTypeSelector {
  """Type is"""
  is: SolanaRewardType
  """Type not"""
  not: SolanaRewardType
  """Type in the list"""
  in: [SolanaRewardType!]
  """Type not in the list"""
  notIn: [SolanaRewardType!]
}

"""Ripple Chain"""
type Ripple {
  """Ripple Account Roots"""
  accountRoots(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, domain: StringSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, ownerCount: BigIntIdSelector, transferRate: BigIntIdSelector, prevBalance: FloatSelector, balance: FloatSelector, any: [RippleAccountRootFilter!], options: QueryOptions): [RippleAccountRoot!]
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [RippleAddressInfo!]!
  """Blockchain Address Statistics"""
  addressStats(address: AddressSelector!, options: QueryOptions): [RippleAddressStats!]
  """Ripple Balances"""
  balances(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, currencySymbol: CurrencySelector, issuer: AddressSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector, any: [RippleBalanceFilter!], options: QueryOptions): [RippleBalance!]
  """Ripple Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BigIntIdSelector, hash: HashSelector, accountHash: HashSelector, transactionHash: HashSelector, totalCoins: FloatSelector, any: [RippleBlockFilter!], options: QueryOptions): [RippleBlock!]
  """Ripple Checks"""
  checks(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, expiration: BigIntIdSelector, invoiceId: StringSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, sendMax: FloatSelector, any: [RippleCheckFilter!], options: QueryOptions): [RippleCheck!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currencyFrom: CurrencySelector, currencyTo: CurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [RippleCoinpath!]
  """Ripple Escrows"""
  escrows(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, condition: StringSelector, cancelAfter: BigIntIdSelector, finishAfter: BigIntIdSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, amount: FloatSelector, any: [RippleEscrowFilter!], options: QueryOptions): [RippleEscrow!]
  """Ripple NFTokenOffers"""
  nftokenOffers(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, fromAccount: AddressSelector, destinationAccount: AddressSelector, nftokenCurrencySymbol: CurrencySelector, currencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, nftokenAmount: FloatSelector, mount: FloatSelector, any: [RippleNftokenOfferFilter!], options: QueryOptions): [RippleNFTokenOffer!]
  """Ripple Offers"""
  offers(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector, any: [RippleOfferFilter!], options: QueryOptions): [RippleOffer!]
  """Ripple Payments"""
  payments(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, sender: AddressSelector, receiver: AddressSelector, amountCurrency: CurrencySelector, amountIssuer: AddressSelector, deliveredCurrency: CurrencySelector, deliveredIssuer: AddressSelector, sendMaxCurrency: CurrencySelector, sendMaxIssuer: AddressSelector, deliverMinCurrency: CurrencySelector, deliverMinIssuer: AddressSelector, tag: BigIntIdSelector, invoice: StringSelector, flags: BigIntIdSelector, partial: BooleanSelector, amount: FloatSelector, deliveredAmount: FloatSelector, sendMaxAmount: FloatSelector, deliverMinAmount: FloatSelector, any: [RipplePaymentFilter!], options: QueryOptions): [RipplePayment!]
  """Ripple Ripple States"""
  rippleStates(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, lowAccount: AddressSelector, highAccount: AddressSelector, currencySymbol: CurrencySelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector, any: [RippleRippleStateFilter!], options: QueryOptions): [RippleRippleState!]
  """Ripple Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, type: StringSelector, memos: StringSelector, sourceTag: BigIntIdSelector, accountTxnId: AddressSelector, sequence: BigIntIdSelector, lastLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, result: StringSelector, success: BooleanSelector, fee: FloatSelector, any: [RippleTransactionFilter!], options: QueryOptions): [RippleTransaction!]
  """Ripple Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, sender: AddressSelector, receiver: AddressSelector, currencyFromSymbol: CurrencySelector, currencyToSymbol: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector, any: [RippleTransferFilter!], options: QueryOptions): [RippleTransfer!]
}

"""Account root in Ripple blockchain"""
type RippleAccountRoot {
  """Account"""
  account: Address
  any(of: RippleAccountRootMeasurable!): String
  balance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, domain: StringSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, ownerCount: BigIntIdSelector, transferRate: BigIntIdSelector, prevBalance: FloatSelector, balance: FloatSelector): DecimalNumberAsDiv
  """Block"""
  block: BigInt
  count(uniq: RippleAccountRootUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, domain: StringSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, ownerCount: BigIntIdSelector, transferRate: BigIntIdSelector, prevBalance: FloatSelector, balance: FloatSelector): Int
  countBigInt(uniq: RippleAccountRootUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, domain: StringSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, ownerCount: BigIntIdSelector, transferRate: BigIntIdSelector, prevBalance: FloatSelector, balance: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  """Domain"""
  domain: String
  expression(get: String!): DecimalNumber
  """Flags"""
  flags: BigInt
  maximum(of: RippleAccountRootMeasurable!, get: RippleAccountRootMeasurable): String
  minimum(of: RippleAccountRootMeasurable!, get: RippleAccountRootMeasurable): String
  """Operation"""
  operation: String
  ownerCount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, domain: StringSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, ownerCount: BigIntIdSelector, transferRate: BigIntIdSelector, prevBalance: FloatSelector, balance: FloatSelector): BigInt
  prevBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, domain: StringSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, ownerCount: BigIntIdSelector, transferRate: BigIntIdSelector, prevBalance: FloatSelector, balance: FloatSelector): DecimalNumberAsDiv
  """Prev ledger sequence"""
  prevLedgerSequence: BigInt
  """Prev txn"""
  prevTxnId: String
  """Sequence"""
  sequence: BigInt
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
  transferRate(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, domain: StringSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, ownerCount: BigIntIdSelector, transferRate: BigIntIdSelector, prevBalance: FloatSelector, balance: FloatSelector): BigInt
}

input RippleAccountRootFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  domain: StringSelector
  sequence: BigIntIdSelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  ownerCount: BigIntIdSelector
  transferRate: BigIntIdSelector
  prevBalance: FloatSelector
  balance: FloatSelector
}

enum RippleAccountRootMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Transaction type"""
  transactionType
  """Operation"""
  operation
  """Account"""
  account
  """Prev balance"""
  prevBalance
  """Balance"""
  balance
  """Domain"""
  domain
  """Owner count"""
  ownerCount
  """Transfer rate"""
  transferRate
  """Sequence"""
  sequence
  """Prev txn"""
  prevTxnId
  """Prev ledger sequence"""
  prevLedgerSequence
  """Flags"""
  flags
}

enum RippleAccountRootUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq transaction types count"""
  transactionTypes
  """Uniq operations count"""
  operations
  """Uniq accounts count"""
  accounts
  """Uniq domains count"""
  domains
  """Uniq sequences count"""
  sequences
  """Uniq prev txn ids count"""
  prevTxnIds
  """Uniq prev ledger sequences count"""
  prevLedgerSequences
  """Uniq flags count"""
  flags
}

"""Address detailed information for Ripple network"""
type RippleAddressInfo {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """XRP balance"""
  balance(in: BaseCurrencyEnum): Float
  """Token Balances"""
  tokenBalances: [RippleTokenBalances!]
}

"""
Counts and aggregates for the address, transfer count,
                  amount, number of distinct currencies,
                  times of the first and the last transactions
"""
type RippleAddressStat {
  """Address"""
  address: Address
  """Balance"""
  balance: BigInt
  """Days with received"""
  daysWithReceived: BigInt
  """Days with sent"""
  daysWithSent: BigInt
  """Days with transactions"""
  daysWithTransactions: BigInt
  """Days with transfers"""
  daysWithTransfers: BigInt
  """First transfer at"""
  firstTransferAt: DateTime
  """First tx at"""
  firstTxAt: DateTime
  """Last transfer at"""
  lastTransferAt: DateTime
  """Last tx at"""
  lastTxAt: DateTime
  """Receive Amount"""
  receiveAmount: BigInt
  """Receive from Count"""
  receiveFromCount: BigInt
  """Receive from currencies"""
  receiveFromCurrencies: BigInt
  """Receive tx Count"""
  receiveTxCount: BigInt
  """Send Amount"""
  sendAmount: BigInt
  """Send to count"""
  sendToCount: BigInt
  """Send to currencies"""
  sendToCurrencies: BigInt
  """Send tx count"""
  sendTxCount: BigInt
}

"""AddressStat"""
type RippleAddressStats {
  """Address With Statistics"""
  address: RippleAddressStat
}

"""Balance in Ripple blockchain"""
type RippleBalance {
  """Account"""
  account: Address
  any(of: RippleBalanceMeasurable!): String
  balance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, currencySymbol: CurrencySelector, issuer: AddressSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): Float
  """Block"""
  block: BigInt
  count(uniq: RippleBalanceUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, currencySymbol: CurrencySelector, issuer: AddressSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): Int
  countBigInt(uniq: RippleBalanceUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, currencySymbol: CurrencySelector, issuer: AddressSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Flags"""
  flags: BigInt
  """Issuer"""
  issuer: Address
  maximum(of: RippleBalanceMeasurable!, get: RippleBalanceMeasurable): String
  minimum(of: RippleBalanceMeasurable!, get: RippleBalanceMeasurable): String
  """Operation"""
  operation: String
  prevBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, currencySymbol: CurrencySelector, issuer: AddressSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): Float
  """Prev ledger sequence"""
  prevLedgerSequence: BigInt
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
}

input RippleBalanceFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  currencySymbol: CurrencySelector
  issuer: AddressSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  balance: FloatSelector
  prevBalance: FloatSelector
}

enum RippleBalanceMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Transaction type"""
  transactionType
  """Operation"""
  operation
  """Account"""
  account
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Issuer"""
  issuer
  """Prev balance"""
  prevBalance
  """Balance"""
  balance
  """Prev ledger sequence"""
  prevLedgerSequence
  """Flags"""
  flags
}

enum RippleBalanceUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq transaction types count"""
  transactionTypes
  """Uniq operations count"""
  operations
  """Uniq accounts count"""
  accounts
  """Uniq currency names count"""
  currencyNames
  """Uniq currency symbols count"""
  currencySymbols
  """Uniq issuers count"""
  issuers
  """Uniq prev ledger sequences count"""
  prevLedgerSequences
  """Uniq flags count"""
  flags
}

"""Block in Ripple blockchain"""
type RippleBlock {
  """Account hash"""
  accountHash: String
  any(of: RippleBlockMeasurable!): String
  count(uniq: RippleBlockUniq, date: DateSelector, time: DateTimeSelector, height: BigIntIdSelector, hash: HashSelector, accountHash: HashSelector, transactionHash: HashSelector, totalCoins: FloatSelector): Int
  countBigInt(uniq: RippleBlockUniq, date: DateSelector, time: DateTimeSelector, height: BigIntIdSelector, hash: HashSelector, accountHash: HashSelector, transactionHash: HashSelector, totalCoins: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Block hash"""
  hash: String
  """Block number (height) in blockchain"""
  height: BigInt
  maximum(of: RippleBlockMeasurable!, get: RippleBlockMeasurable): String
  minimum(of: RippleBlockMeasurable!, get: RippleBlockMeasurable): String
  """Timestamp"""
  timestamp: DateTime
  totalCoins(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BigIntIdSelector, hash: HashSelector, accountHash: HashSelector, transactionHash: HashSelector, totalCoins: FloatSelector): DecimalNumberAsDiv
  """Transaction hash"""
  transactionHash: String
}

input RippleBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BigIntIdSelector
  hash: HashSelector
  accountHash: HashSelector
  transactionHash: HashSelector
  totalCoins: FloatSelector
}

enum RippleBlockMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Hash"""
  hash
  """Total coins"""
  totalCoins
  """Account hash"""
  accountHash
  """Transaction hash"""
  transactionHash
}

enum RippleBlockUniq {
  """Uniq dates count"""
  dates
  """Uniq blocks count"""
  blocks
  """Uniq hashes count"""
  hashes
  """Uniq account hashes count"""
  accountHashes
  """Uniq transaction hashes count"""
  transactionHashes
}

"""Check in Ripple blockchain"""
type RippleCheck {
  """Account"""
  account: Address
  any(of: RippleCheckMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: RippleCheckUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, expiration: BigIntIdSelector, invoiceId: StringSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, sendMax: FloatSelector): Int
  countBigInt(uniq: RippleCheckUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, expiration: BigIntIdSelector, invoiceId: StringSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, sendMax: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Destination"""
  destination: Address
  """Destination tag"""
  destinationTag: BigInt
  """Expiration"""
  expiration: BigInt
  expression(get: String!): DecimalNumber
  """Flags"""
  flags: BigInt
  """Invoice"""
  invoiceId: String
  maximum(of: RippleCheckMeasurable!, get: RippleCheckMeasurable): String
  minimum(of: RippleCheckMeasurable!, get: RippleCheckMeasurable): String
  """Operation"""
  operation: String
  """Prev ledger sequence"""
  prevLedgerSequence: BigInt
  """Prev txn"""
  prevTxnId: String
  sendMax(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, expiration: BigIntIdSelector, invoiceId: StringSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, sendMax: FloatSelector): Float
  """Sequence"""
  sequence: BigInt
  """Source tag"""
  sourceTag: BigInt
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
}

input RippleCheckFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  destination: StringSelector
  currencySymbol: CurrencySelector
  expiration: BigIntIdSelector
  invoiceId: StringSelector
  sourceTag: BigIntIdSelector
  destinationTag: BigIntIdSelector
  sequence: BigIntIdSelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  sendMax: FloatSelector
}

enum RippleCheckMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Transaction type"""
  transactionType
  """Operation"""
  operation
  """Account"""
  account
  """Destination"""
  destination
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Send max"""
  sendMax
  """Expiration"""
  expiration
  """Invoice"""
  invoiceId
  """Source tag"""
  sourceTag
  """Destination tag"""
  destinationTag
  """Sequence"""
  sequence
  """Prev txn"""
  prevTxnId
  """Prev ledger sequence"""
  prevLedgerSequence
  """Flags"""
  flags
}

enum RippleCheckUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq transaction types count"""
  transactionTypes
  """Uniq operations count"""
  operations
  """Uniq accounts count"""
  accounts
  """Uniq destinations count"""
  destinations
  """Uniq currency names count"""
  currencyNames
  """Uniq currency symbols count"""
  currencySymbols
  """Uniq expirations count"""
  expirations
  """Uniq invoice ids count"""
  invoiceIds
  """Uniq source tags count"""
  sourceTags
  """Uniq destination tags count"""
  destinationTags
  """Uniq sequences count"""
  sequences
  """Uniq prev txn ids count"""
  prevTxnIds
  """Uniq prev ledger sequences count"""
  prevLedgerSequences
  """Uniq flags count"""
  flags
}

"""Ripple Coinpath"""
type RippleCoinpath {
  """Summary of transfered value from"""
  amountFrom(in: BaseCurrencyEnum): Float
  """Summary of transfered value to"""
  amountTo(in: BaseCurrencyEnum): Float
  any(of: RippleCoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency From of transfer"""
  currencyFrom: Currency
  """Currency To of transfer"""
  currencyTo: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: RippleCoinpathMeasureable!, get: RippleCoinpathMeasureable): String
  minimum(of: RippleCoinpathMeasureable!, get: RippleCoinpathMeasureable): String
  """Operation"""
  operation: String
  """Receiver address"""
  receiver: StellarCoinpathAddress
  """Sender address"""
  sender: StellarCoinpathAddress
  """Transaction of transfer happened"""
  transaction: StellarTransactionCoinpathDimension
}

enum RippleCoinpathMeasureable {
  """Time"""
  time
  """Block"""
  block
  """Version"""
  tx_hash
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Depth"""
  depth
}

"""Escrow in Ripple blockchain"""
type RippleEscrow {
  """Account"""
  account: Address
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, condition: StringSelector, cancelAfter: BigIntIdSelector, finishAfter: BigIntIdSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, amount: FloatSelector): Float
  any(of: RippleEscrowMeasurable!): String
  """Block"""
  block: BigInt
  """Cancel after"""
  cancelAfter: BigInt
  """Condition"""
  condition: String
  count(uniq: RippleEscrowUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, condition: StringSelector, cancelAfter: BigIntIdSelector, finishAfter: BigIntIdSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, amount: FloatSelector): Int
  countBigInt(uniq: RippleEscrowUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, destination: StringSelector, currencySymbol: CurrencySelector, condition: StringSelector, cancelAfter: BigIntIdSelector, finishAfter: BigIntIdSelector, sourceTag: BigIntIdSelector, destinationTag: BigIntIdSelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, amount: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Destination"""
  destination: Address
  """Destination tag"""
  destinationTag: BigInt
  expression(get: String!): DecimalNumber
  """Finish after"""
  finishAfter: BigInt
  """Flags"""
  flags: BigInt
  maximum(of: RippleEscrowMeasurable!, get: RippleEscrowMeasurable): String
  minimum(of: RippleEscrowMeasurable!, get: RippleEscrowMeasurable): String
  """Operation"""
  operation: String
  """Prev ledger sequence"""
  prevLedgerSequence: BigInt
  """Prev txn"""
  prevTxnId: String
  """Source tag"""
  sourceTag: BigInt
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
}

input RippleEscrowFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  destination: StringSelector
  currencySymbol: CurrencySelector
  condition: StringSelector
  cancelAfter: BigIntIdSelector
  finishAfter: BigIntIdSelector
  sourceTag: BigIntIdSelector
  destinationTag: BigIntIdSelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  amount: FloatSelector
}

enum RippleEscrowMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Transaction type"""
  transactionType
  """Operation"""
  operation
  """Account"""
  account
  """Destination"""
  destination
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Amount"""
  amount
  """Condition"""
  condition
  """Cancel after"""
  cancelAfter
  """Finish after"""
  finishAfter
  """Source tag"""
  sourceTag
  """Destination tag"""
  destinationTag
  """Prev txn"""
  prevTxnId
  """Prev ledger sequence"""
  prevLedgerSequence
  """Flags"""
  flags
}

enum RippleEscrowUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq transaction types count"""
  transactionTypes
  """Uniq operations count"""
  operations
  """Uniq accounts count"""
  accounts
  """Uniq destinations count"""
  destinations
  """Uniq currency names count"""
  currencyNames
  """Uniq currency symbols count"""
  currencySymbols
  """Uniq conditions count"""
  conditions
  """Uniq cancel afters count"""
  cancelAfters
  """Uniq finish afters count"""
  finishAfters
  """Uniq source tags count"""
  sourceTags
  """Uniq destination tags count"""
  destinationTags
  """Uniq prev txn ids count"""
  prevTxnIds
  """Uniq prev ledger sequences count"""
  prevLedgerSequences
  """Uniq flags count"""
  flags
}

enum RippleNetwork {
  """Ripple XRP Ledger"""
  ripple
}

"""NFTokenOffer in Ripple blockchain"""
type RippleNFTokenOffer {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Float
  any(of: RippleOfferMeasurable!): String
  """Block"""
  block: BigInt
  """Book directory"""
  bookDirectory: String
  """Book node"""
  bookNode: String
  count(uniq: RippleOfferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Int
  countBigInt(uniq: RippleOfferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): BigInt
  """Taker pays currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Destination Account"""
  destinationAccount: Address
  """Expiration"""
  expiration: BigInt
  expression(get: String!): DecimalNumber
  """Flags"""
  flags: BigInt
  """From Account"""
  fromAccount: Address
  maximum(of: RippleOfferMeasurable!, get: RippleOfferMeasurable): String
  minimum(of: RippleOfferMeasurable!, get: RippleOfferMeasurable): String
  nftokenAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Float
  """NFToken Buy Offer"""
  nftokenBuyOffer: String
  """Taker gets currency"""
  nftokenCurrency: Currency
  """NFToken Sell Offer"""
  nftokenSellOffer: String
  """Operation"""
  operation: String
  """Prev ledger sequence"""
  prevLedgerSequence: BigInt
  """Prev txn"""
  prevTxnId: String
  """Sequence"""
  sequence: BigInt
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
}

input RippleNftokenOfferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  fromAccount: AddressSelector
  destinationAccount: AddressSelector
  nftokenCurrencySymbol: CurrencySelector
  currencySymbol: CurrencySelector
  bookDirectory: StringSelector
  bookNode: StringSelector
  expiration: BigIntIdSelector
  sequence: BigIntIdSelector
  prevTxnId: BigIntIdSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  nftokenAmount: FloatSelector
  mount: FloatSelector
}

"""Offer in Ripple blockchain"""
type RippleOffer {
  """Account"""
  account: Address
  any(of: RippleOfferMeasurable!): String
  """Block"""
  block: BigInt
  """Book directory"""
  bookDirectory: String
  """Book node"""
  bookNode: String
  count(uniq: RippleOfferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Int
  countBigInt(uniq: RippleOfferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  """Expiration"""
  expiration: BigInt
  expression(get: String!): DecimalNumber
  """Flags"""
  flags: BigInt
  maximum(of: RippleOfferMeasurable!, get: RippleOfferMeasurable): String
  minimum(of: RippleOfferMeasurable!, get: RippleOfferMeasurable): String
  """Operation"""
  operation: String
  preTakerGetsAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Float
  preTakerPaysAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Float
  """Prev ledger sequence"""
  prevLedgerSequence: BigInt
  """Prev txn"""
  prevTxnId: String
  """Sequence"""
  sequence: BigInt
  takerGetsAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Float
  """Taker gets currency"""
  takerGetsCurrency: Currency
  takerPaysAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, account: AddressSelector, takerGetsCurrencySymbol: CurrencySelector, takerPaysCurrencySymbol: CurrencySelector, bookDirectory: StringSelector, bookNode: StringSelector, expiration: BigIntIdSelector, sequence: BigIntIdSelector, prevTxnId: BigIntIdSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, takerGetsAmount: FloatSelector, takerPaysAmount: FloatSelector, preTakerGetsAmount: FloatSelector, preTakerPaysAmount: FloatSelector): Float
  """Taker pays currency"""
  takerPaysCurrency: Currency
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
}

input RippleOfferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  account: AddressSelector
  takerGetsCurrencySymbol: CurrencySelector
  takerPaysCurrencySymbol: CurrencySelector
  bookDirectory: StringSelector
  bookNode: StringSelector
  expiration: BigIntIdSelector
  sequence: BigIntIdSelector
  prevTxnId: BigIntIdSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  takerGetsAmount: FloatSelector
  takerPaysAmount: FloatSelector
  preTakerGetsAmount: FloatSelector
  preTakerPaysAmount: FloatSelector
}

enum RippleOfferMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Transaction type"""
  transactionType
  """Operation"""
  operation
  """Account"""
  account
  """Taker gets currency name"""
  takerGetsCurrencyName
  """Taker gets currency symbol"""
  takerGetsCurrencySymbol
  """Taker pays currency name"""
  takerPaysCurrencyName
  """Taker pays currency symbol"""
  takerPaysCurrencySymbol
  """Taker gets amount"""
  takerGetsAmount
  """Taker pays amount"""
  takerPaysAmount
  """Pre taker gets amount"""
  preTakerGetsAmount
  """Pre taker pays amount"""
  preTakerPaysAmount
  """Book directory"""
  bookDirectory
  """Book node"""
  bookNode
  """Expiration"""
  expiration
  """Sequence"""
  sequence
  """Prev txn"""
  prevTxnId
  """Prev ledger sequence"""
  prevLedgerSequence
  """Flags"""
  flags
}

enum RippleOfferUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq transaction types count"""
  transactionTypes
  """Uniq operations count"""
  operations
  """Uniq accounts count"""
  accounts
  """Uniq taker gets currency names count"""
  takerGetsCurrencyNames
  """Uniq taker gets currency symbols count"""
  takerGetsCurrencySymbols
  """Uniq taker pays currency names count"""
  takerPaysCurrencyNames
  """Uniq taker pays currency symbols count"""
  takerPaysCurrencySymbols
  """Uniq book directories count"""
  bookDirectories
  """Uniq book nodes count"""
  bookNodes
  """Uniq expirations count"""
  expirations
  """Uniq sequences count"""
  sequences
  """Uniq prev txn ids count"""
  prevTxnIds
  """Uniq prev ledger sequences count"""
  prevLedgerSequences
  """Uniq flags count"""
  flags
}

"""Payment in Ripple blockchain"""
type RipplePayment {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, sender: AddressSelector, receiver: AddressSelector, amountCurrency: CurrencySelector, amountIssuer: AddressSelector, deliveredCurrency: CurrencySelector, deliveredIssuer: AddressSelector, sendMaxCurrency: CurrencySelector, sendMaxIssuer: AddressSelector, deliverMinCurrency: CurrencySelector, deliverMinIssuer: AddressSelector, tag: BigIntIdSelector, invoice: StringSelector, flags: BigIntIdSelector, partial: BooleanSelector, amount: FloatSelector, deliveredAmount: FloatSelector, sendMaxAmount: FloatSelector, deliverMinAmount: FloatSelector): Float
  """Amount currency"""
  amountCurrency: Currency
  """Amount issuer"""
  amountIssuer: Address
  any(of: RipplePaymentMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: RipplePaymentUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, sender: AddressSelector, receiver: AddressSelector, amountCurrency: CurrencySelector, amountIssuer: AddressSelector, deliveredCurrency: CurrencySelector, deliveredIssuer: AddressSelector, sendMaxCurrency: CurrencySelector, sendMaxIssuer: AddressSelector, deliverMinCurrency: CurrencySelector, deliverMinIssuer: AddressSelector, tag: BigIntIdSelector, invoice: StringSelector, flags: BigIntIdSelector, partial: BooleanSelector, amount: FloatSelector, deliveredAmount: FloatSelector, sendMaxAmount: FloatSelector, deliverMinAmount: FloatSelector): Int
  countBigInt(uniq: RipplePaymentUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, sender: AddressSelector, receiver: AddressSelector, amountCurrency: CurrencySelector, amountIssuer: AddressSelector, deliveredCurrency: CurrencySelector, deliveredIssuer: AddressSelector, sendMaxCurrency: CurrencySelector, sendMaxIssuer: AddressSelector, deliverMinCurrency: CurrencySelector, deliverMinIssuer: AddressSelector, tag: BigIntIdSelector, invoice: StringSelector, flags: BigIntIdSelector, partial: BooleanSelector, amount: FloatSelector, deliveredAmount: FloatSelector, sendMaxAmount: FloatSelector, deliverMinAmount: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  deliverMinAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, sender: AddressSelector, receiver: AddressSelector, amountCurrency: CurrencySelector, amountIssuer: AddressSelector, deliveredCurrency: CurrencySelector, deliveredIssuer: AddressSelector, sendMaxCurrency: CurrencySelector, sendMaxIssuer: AddressSelector, deliverMinCurrency: CurrencySelector, deliverMinIssuer: AddressSelector, tag: BigIntIdSelector, invoice: StringSelector, flags: BigIntIdSelector, partial: BooleanSelector, amount: FloatSelector, deliveredAmount: FloatSelector, sendMaxAmount: FloatSelector, deliverMinAmount: FloatSelector): Float
  """Deliver min currency"""
  deliverMinCurrency: Currency
  """Deliver min issuer"""
  deliverMinIssuer: Address
  deliveredAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, sender: AddressSelector, receiver: AddressSelector, amountCurrency: CurrencySelector, amountIssuer: AddressSelector, deliveredCurrency: CurrencySelector, deliveredIssuer: AddressSelector, sendMaxCurrency: CurrencySelector, sendMaxIssuer: AddressSelector, deliverMinCurrency: CurrencySelector, deliverMinIssuer: AddressSelector, tag: BigIntIdSelector, invoice: StringSelector, flags: BigIntIdSelector, partial: BooleanSelector, amount: FloatSelector, deliveredAmount: FloatSelector, sendMaxAmount: FloatSelector, deliverMinAmount: FloatSelector): Float
  """Delivered currency"""
  deliveredCurrency: Currency
  """Delivered issuer"""
  deliveredIssuer: Address
  expression(get: String!): DecimalNumber
  """Flags"""
  flags: BigInt
  """Invoice"""
  invoice: String
  maximum(of: RipplePaymentMeasurable!, get: RipplePaymentMeasurable): String
  minimum(of: RipplePaymentMeasurable!, get: RipplePaymentMeasurable): String
  """Partial"""
  partial: Boolean
  """Receiver"""
  receiver: Address
  sendMaxAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, sender: AddressSelector, receiver: AddressSelector, amountCurrency: CurrencySelector, amountIssuer: AddressSelector, deliveredCurrency: CurrencySelector, deliveredIssuer: AddressSelector, sendMaxCurrency: CurrencySelector, sendMaxIssuer: AddressSelector, deliverMinCurrency: CurrencySelector, deliverMinIssuer: AddressSelector, tag: BigIntIdSelector, invoice: StringSelector, flags: BigIntIdSelector, partial: BooleanSelector, amount: FloatSelector, deliveredAmount: FloatSelector, sendMaxAmount: FloatSelector, deliverMinAmount: FloatSelector): Float
  """Send max currency"""
  sendMaxCurrency: Currency
  """Send max issuer"""
  sendMaxIssuer: Address
  """Sender"""
  sender: Address
  """Tag"""
  tag: BigInt
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionHashIndexDimension
}

input RipplePaymentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  sender: AddressSelector
  receiver: AddressSelector
  amountCurrency: CurrencySelector
  amountIssuer: AddressSelector
  deliveredCurrency: CurrencySelector
  deliveredIssuer: AddressSelector
  sendMaxCurrency: CurrencySelector
  sendMaxIssuer: AddressSelector
  deliverMinCurrency: CurrencySelector
  deliverMinIssuer: AddressSelector
  tag: BigIntIdSelector
  invoice: StringSelector
  flags: BigIntIdSelector
  partial: BooleanSelector
  amount: FloatSelector
  deliveredAmount: FloatSelector
  sendMaxAmount: FloatSelector
  deliverMinAmount: FloatSelector
}

enum RipplePaymentMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Amount currency name"""
  amountCurrencyName
  """Amount currency symbol"""
  amountCurrencySymbol
  """Amount issuer"""
  amountIssuer
  """Amount"""
  amount
  """Delivered currency name"""
  deliveredCurrencyName
  """Delivered currency symbol"""
  deliveredCurrencySymbol
  """Delivered issuer"""
  deliveredIssuer
  """Delivered amount"""
  deliveredAmount
  """Send max currency name"""
  sendMaxCurrencyName
  """Send max currency symbol"""
  sendMaxCurrencySymbol
  """Send max issuer"""
  sendMaxIssuer
  """Send max amount"""
  sendMaxAmount
  """Deliver min currency name"""
  deliverMinCurrencyName
  """Deliver min currency symbol"""
  deliverMinCurrencySymbol
  """Deliver min issuer"""
  deliverMinIssuer
  """Deliver min amount"""
  deliverMinAmount
  """Tag"""
  tag
  """Invoice"""
  invoice
  """Flags"""
  flags
  """Partial"""
  partial
}

enum RipplePaymentUniq {
  """Uniq dates count"""
  dates
  """Uniq time count"""
  time
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq senders count"""
  senders
  """Uniq receivers count"""
  receivers
  """Uniq amount currency names count"""
  amountCurrencyNames
  """Uniq amount currency symbols count"""
  amountCurrencySymbols
  """Uniq amount issuers count"""
  amountIssuers
  """Uniq delivered currency names count"""
  deliveredCurrencyNames
  """Uniq delivered currency symbols count"""
  deliveredCurrencySymbols
  """Uniq delivered issuers count"""
  deliveredIssuers
  """Uniq send max currency names count"""
  sendMaxCurrencyNames
  """Uniq send max currency symbols count"""
  sendMaxCurrencySymbols
  """Uniq send max issuers count"""
  sendMaxIssuers
  """Uniq deliver min currency names count"""
  deliverMinCurrencyNames
  """Uniq deliver min currency symbols count"""
  deliverMinCurrencySymbols
  """Uniq deliver min issuers count"""
  deliverMinIssuers
  """Uniq tags count"""
  tags
  """Uniq invoices count"""
  invoices
  """Uniq flags count"""
  flags
}

"""Ripple state in Ripple blockchain"""
type RippleRippleState {
  any(of: RippleRippleStateMeasurable!): String
  balance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, lowAccount: AddressSelector, highAccount: AddressSelector, currencySymbol: CurrencySelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): Float
  """Block"""
  block: BigInt
  count(uniq: RippleRippleStateUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, lowAccount: AddressSelector, highAccount: AddressSelector, currencySymbol: CurrencySelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): Int
  countBigInt(uniq: RippleRippleStateUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, lowAccount: AddressSelector, highAccount: AddressSelector, currencySymbol: CurrencySelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Flags"""
  flags: BigInt
  """High account"""
  highAccount: Address
  """Low account"""
  lowAccount: Address
  maximum(of: RippleRippleStateMeasurable!, get: RippleRippleStateMeasurable): String
  minimum(of: RippleRippleStateMeasurable!, get: RippleRippleStateMeasurable): String
  """Operation"""
  operation: String
  prevBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, operation: StringSelector, lowAccount: AddressSelector, highAccount: AddressSelector, currencySymbol: CurrencySelector, prevTxnId: StringSelector, prevLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, balance: FloatSelector, prevBalance: FloatSelector): Float
  """Prev ledger sequence"""
  prevLedgerSequence: BigInt
  """Prev txn"""
  prevTxnId: String
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
}

input RippleRippleStateFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  operation: StringSelector
  lowAccount: AddressSelector
  highAccount: AddressSelector
  currencySymbol: CurrencySelector
  prevTxnId: StringSelector
  prevLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  balance: FloatSelector
  prevBalance: FloatSelector
}

enum RippleRippleStateMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Transaction type"""
  transactionType
  """Operation"""
  operation
  """Low account"""
  lowAccount
  """High account"""
  highAccount
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Balance"""
  balance
  """Pre balance"""
  prevBalance
  """Prev txn"""
  prevTxnId
  """Prev ledger sequence"""
  prevLedgerSequence
  """Flags"""
  flags
}

enum RippleRippleStateUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq transaction types count"""
  transactionTypes
  """Uniq operations count"""
  operations
  """Uniq low accounts count"""
  lowAccounts
  """Uniq high accounts count"""
  highAccounts
  """Uniq currency names count"""
  currencyNames
  """Uniq currency symbols count"""
  currencySymbols
  """Uniq prev txn ids count"""
  prevTxnIds
  """Uniq prev ledger sequences count"""
  prevLedgerSequences
  """Uniq flags count"""
  flags
}

"""Token Balance"""
type RippleTokenBalances {
  """The unique Address of the counterparty to this trust line."""
  account: String
  """Balance"""
  balance: Float
  """Currency"""
  currency: String
}

"""Transaction in Ripple blockchain"""
type RippleTransaction {
  """Account txn id"""
  accountTxnId: String
  any(of: RippleTransactionMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: RippleTransactionUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, type: StringSelector, memos: StringSelector, sourceTag: BigIntIdSelector, accountTxnId: AddressSelector, sequence: BigIntIdSelector, lastLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, result: StringSelector, success: BooleanSelector, fee: FloatSelector): Int
  countBigInt(uniq: RippleTransactionUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, type: StringSelector, memos: StringSelector, sourceTag: BigIntIdSelector, accountTxnId: AddressSelector, sequence: BigIntIdSelector, lastLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, result: StringSelector, success: BooleanSelector, fee: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, type: StringSelector, memos: StringSelector, sourceTag: BigIntIdSelector, accountTxnId: AddressSelector, sequence: BigIntIdSelector, lastLedgerSequence: BigIntIdSelector, flags: BigIntIdSelector, result: StringSelector, success: BooleanSelector, fee: FloatSelector): DecimalNumberAsDiv
  """Flags"""
  flags: BigInt
  """Hash"""
  hash: String
  """Index"""
  index: Int
  """Last ledger sequence"""
  lastLedgerSequence: BigInt
  maximum(of: RippleTransactionMeasurable!, get: RippleTransactionMeasurable): String
  """Memos"""
  memos: String
  minimum(of: RippleTransactionMeasurable!, get: RippleTransactionMeasurable): String
  """Result"""
  result: String
  """Sender"""
  sender: Address
  """Sequence"""
  sequence: BigInt
  """Source tag"""
  sourceTag: BigInt
  """Success"""
  success: Boolean
  """Timestamp"""
  timestamp: DateTime
  """Tx signers"""
  txSigners: String
  """Type"""
  type: String
}

"""Ripple transaction"""
type RippleTransactionDimension {
  """Hash hex representation"""
  hash: String!
  """Transaction index in block"""
  index: Int!
  """Transaction sender"""
  sender: String
  """Transaction type"""
  type: String
}

input RippleTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  index: IntegerSelector
  hash: HashSelector
  sender: AddressSelector
  type: StringSelector
  memos: StringSelector
  sourceTag: BigIntIdSelector
  accountTxnId: AddressSelector
  sequence: BigIntIdSelector
  lastLedgerSequence: BigIntIdSelector
  flags: BigIntIdSelector
  result: StringSelector
  success: BooleanSelector
  fee: FloatSelector
}

"""Ripple transaction with hash and index"""
type RippleTransactionHashIndexDimension {
  """Hash hex representation"""
  hash: String!
  """Transaction index in block"""
  index: Int!
}

enum RippleTransactionMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Index"""
  index
  """Hash"""
  hash
  """Sender"""
  sender
  """Type"""
  type
  """Fee"""
  fee
  """Memos"""
  memos
  """Source tag"""
  sourceTag
  """Account txn id"""
  accountTxnId
  """Sequence"""
  sequence
  """Last ledger sequence"""
  lastLedgerSequence
  """Flags"""
  flags
  """Result"""
  result
  """Success"""
  success
}

enum RippleTransactionUniq {
  """Uniq dates count"""
  dates
  """Uniq blocks count"""
  blocks
  """Uniq indices count"""
  indices
  """Uniq hashes count"""
  hashes
  """Uniq senders count"""
  senders
  """Uniq types count"""
  types
  """Uniq source tags count"""
  sourceTags
  """Uniq account txn id bins count"""
  accountTxnIds
  """Uniq sequences count"""
  sequences
  """Uniq last ledger sequences count"""
  lastLedgerSequences
  """Uniq flags count"""
  flags
  """Uniq results count"""
  results
}

"""Transfer in Ripple blockchain"""
type RippleTransfer {
  amountFrom(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, sender: AddressSelector, receiver: AddressSelector, currencyFromSymbol: CurrencySelector, currencyToSymbol: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): Float
  amountTo(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, sender: AddressSelector, receiver: AddressSelector, currencyFromSymbol: CurrencySelector, currencyToSymbol: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): Float
  any(of: RippleTransferMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: RippleTransferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, sender: AddressSelector, receiver: AddressSelector, currencyFromSymbol: CurrencySelector, currencyToSymbol: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): Int
  countBigInt(uniq: RippleTransferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, transactionType: StringSelector, sender: AddressSelector, receiver: AddressSelector, currencyFromSymbol: CurrencySelector, currencyToSymbol: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): BigInt
  """Currency from"""
  currencyFrom: Currency
  """Currency to"""
  currencyTo: Currency
  """Calendar date"""
  date: Date
  """Direction"""
  direction: String
  expression(get: String!): DecimalNumber
  maximum(of: RippleTransferMeasurable!, get: RippleTransferMeasurable): String
  minimum(of: RippleTransferMeasurable!, get: RippleTransferMeasurable): String
  """Receiver"""
  receiver: Address
  """Sender"""
  sender: Address
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: RippleTransactionDimension
}

input RippleTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  transactionType: StringSelector
  sender: AddressSelector
  receiver: AddressSelector
  currencyFromSymbol: CurrencySelector
  currencyToSymbol: CurrencySelector
  direction: StringSelector
  amountFrom: FloatSelector
  amountTo: FloatSelector
}

enum RippleTransferMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Transaction type"""
  transactionType
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency from name"""
  currencyFromName
  """Currency to name"""
  currencyToName
  """Currency from symbol"""
  currencyFromSymbol
  """Currency to symbol"""
  currencyToSymbol
  """Amount from"""
  amountFrom
  """Amount to"""
  amountTo
  """Direction"""
  direction
}

enum RippleTransferUniq {
  """Uniq times count"""
  times
  """Uniq dates count"""
  dates
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq transaction types count"""
  transactionTypes
  """Uniq senders count"""
  senders
  """Uniq receivers count"""
  receivers
  """Uniq currencies from name count"""
  currencyFromNames
  """Uniq currencies to name count"""
  currencyToNames
  """Uniq currencies from symbol count"""
  currencyFromSymbols
  """Uniq currencies to symbol count"""
  currencyToSymbols
  """Uniq directions count"""
  directions
}

"""Smart contract crypto currency ( token, coin, currency )"""
type ScCurrency {
  """Decimals"""
  decimals: Int!
  """Currency name"""
  name: String
  """Currency symbol"""
  symbol: String!
  """Token Type"""
  tokenType: String
}

enum ScriptTypeSelectorSelector {
  """Unknown Transaction"""
  unknown_transaction
  """Peer-to-peer"""
  peer_to_peer_transaction
}

input SeedOptions {
  """Invalidating cache seed"""
  seed: Int
}

"""Solana Sender"""
type Sender {
  address: String!
  mintAccount: String!
  type: String!
}

"""Smart contract method or event"""
union Signature = Event | Method

enum SignatureTypeSelector {
  """Smart contract method"""
  Function
  """Smart contract event"""
  Event
}

"""Blockchain smart contract"""
type SmartContract {
  """String address representation"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Smart Contract Type"""
  contractType: SmartContractType!
  """Smart Contract Protocol Type"""
  protocol: String
}

enum SmartContractArgumentsUniq {
  """Unique signatures count"""
  signatures
  """Unique values"""
  values
  """Calls or events"""
  calls
  """Unique transactions count"""
  txs
  """Unique transaction senders"""
  senders
  """Unique callers count"""
  callers
  """Unique smart contracts count"""
  smart_contracts
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
}

enum SmartContractCallsUniq {
  """Calls"""
  calls
  """Unique transactions count"""
  txs
  """Unique transaction senders"""
  senders
  """Unique callers count"""
  callers
  """Unique smart contracts count"""
  smart_contracts
  """Unique smart contract methods count"""
  smart_contract_methods
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
}

enum SmartContractEventsUniq {
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique transactions count"""
  txs
  """Unique callers count"""
  tx_to
  """Unique transaction senders"""
  tx_from
  """Unique smart contracts count"""
  smart_contracts
  """Unique smart contract methods count"""
  smart_contract_methods
  """Shard ID"""
  shard_id
  """To Shard ID"""
  to_shard_id
}

"""Blockchain smart contract"""
type SmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

type SmartContractReadonlyAttribute {
  """Value as address if applicable"""
  address: EthereumAddressInfo
  """Method name"""
  name: String!
  """Method return type"""
  type: String!
  """Method return value"""
  value: String!
}

enum SmartContractType {
  """Not A Smart contract"""
  None
  """General Purpose Smart contract"""
  Generic
  """Smart contract for token derivatives"""
  MarginPositionToken
  """Multi signature wallet"""
  Multisig
  """Token"""
  Token
  """Token Sale"""
  TokenSale
  """Decentralized exchange"""
  DEX
  """Transaction Execution Approval Language"""
  TEAL
}

"""Selector of smart contract type"""
input SmartContractTypeSelector {
  """Smart Contract type is"""
  is: SmartContractType
  """Smart Contract type not"""
  not: SmartContractType
  """Smart Contract type in the list"""
  in: [SmartContractType!]
  """Smart Contract type not in the list"""
  notIn: [SmartContractType!]
}

"""Solana Chain"""
type Solana {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [SolanaAddressInfoWithBalance!]!
  """BlockRewards of Smart Contract Calls and Events"""
  blockRewards(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector, postBalance: AmountSelector, account: StringSelector, rewardType: RewardTypeSelector, any: [SolanaBlockRewardFilter!], options: QueryOptions): [SolanaBlockReward!]
  """Solana Blocks"""
  blocks(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, parentSlot: IntegerSelector, transactionCount: IntegerSelector, rewards: AmountSelector, any: [SolanaBlockFilter!], options: QueryOptions): [SolanaBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: CurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [SolanaCoinpath!]
  """
  Each instruction specifies a single program, a subset of the transaction`s accounts
          that should be passed to the program.
  """
  instructionAccounts(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: StringSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, parsed: IntegerSelector, parsedActionName: StringSelector, parsedType: StringSelector, external: IntegerSelector, callPath: StringSelector, fee: IntegerSelector, account: StringSelector, accountType: StringSelector, accountOwner: StringSelector, accountIndex: IntegerSelector, any: [SolanaInstructionAccountFilter!], options: QueryOptions): [SolanaInstructionAccount!]
  """
  Each instruction specifies a single program, a subset of the transaction`s accounts
          that should be passed to the program.
  """
  instructions(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: StringSelector, feePayer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: IntegerSelector, callPath: StringSelector, fee: IntegerSelector, any: [SolanaInstructionFilter!], options: QueryOptions): [SolanaInstruction!]
  """Solana Transaction"""
  transactions(date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, parentSlot: BlockSelector, instructionsCount: IntegerSelector, innerInstructionsCount: IntegerSelector, accountsCount: IntegerSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, fee: IntegerSelector, signer: HashSelector, transactionFee: AmountSelector, any: [SolanaTransactionFilter!], options: QueryOptions): [SolanaTransaction!]
  """Currency transfers from/to addresses in crypto currencies"""
  transfers(date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, signer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderMintAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverMintAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, amount: [AmountSelector!], tokenAccount: [StringSelector!], currency: [SolanaCurrencySelector!], any: [SolanaTransferFilter!], options: QueryOptions): [SolanaTransfer!]
}

"""Solana Account"""
type SolanaAccount {
  index: Int!
  name: String!
  owner: String!
  type: String!
}

"""Blockchain address"""
type SolanaAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Current address balance"""
  balance(in: BaseCurrencyEnum): Float
  """Smart Contract if exists on the address"""
  smartContract: SmartContractInfo
}

"""Block in Solana  blockchain"""
type SolanaBlock {
  any(of: SolanaBlockMeasureable!): String
  """Hash of the the block"""
  blockHash(blockHash: HashSelector): String
  count(uniq: SolanaBlockUniq): Int
  countBigInt(uniq: SolanaBlockUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Number of block in the blockchains"""
  height(height: BlockSelector): BigInt
  maximum(of: SolanaBlockMeasureable!, get: SolanaBlockMeasureable): String
  minimum(of: SolanaBlockMeasureable!, get: SolanaBlockMeasureable): String
  """The slot index of this block`s parent"""
  parentSlot(parentSlot: IntegerSelector): BigInt
  """The block hash of this block`s parent"""
  previousBlockHash(previousBlockHash: HashSelector): String
  rewards(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, parentSlot: IntegerSelector, transactionCount: IntegerSelector, rewards: AmountSelector): Float
  """The time this transaction was created"""
  time: DateTime
  """Count of transactions in this block"""
  transactionCount(transactionCount: IntegerSelector): Int
}

input SolanaBlockFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  parentSlot: IntegerSelector
  transactionCount: IntegerSelector
  rewards: AmountSelector
}

"""Solana Block Info"""
type SolanaBlockInfo {
  """Hash hex representation"""
  hash: String!
  """Block number (height) in blockchain"""
  height: Int!
  parentSlot: BigInt
  previousBlockHash: String
  """Block timestamp"""
  timestamp: DateTime
}

enum SolanaBlockMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Number of reward lamports credited or debited by the account"""
  rewards
  """The slot index of this block`s parent"""
  parent_slot
  """Count of transactions in this block"""
  transaction_count
}

"""BlockReward in Solana  blockchain"""
type SolanaBlockReward {
  """Account"""
  account(account: HashSelector): String
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector, postBalance: AmountSelector, account: StringSelector, rewardType: RewardTypeSelector): Float
  any(of: SolanaBlockRewardMeasureable!): String
  """Block where  transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector, previousBlockHash: HashSelector, parentSlot: StringSelector): SolanaBlockInfo
  count(uniq: SolanaBlockRewardUniq): Int
  countBigInt(uniq: SolanaBlockRewardUniq): BigInt
  """Currency of transfer"""
  currency: Currency
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: SolanaBlockRewardMeasureable!, get: SolanaBlockRewardMeasureable): String
  minimum(of: SolanaBlockRewardMeasureable!, get: SolanaBlockRewardMeasureable): String
  postBalance(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, reward: AmountSelector, parentSlot: IntegerSelector, postBalance: AmountSelector, account: StringSelector, rewardType: RewardTypeSelector): Float
  """Type of reward"""
  rewardType(rewardType: RewardTypeSelector): String
  """The time this transaction was created"""
  time: DateTime
}

input SolanaBlockRewardFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  reward: AmountSelector
  parentSlot: IntegerSelector
  postBalance: AmountSelector
  account: StringSelector
  rewardType: RewardTypeSelector
}

enum SolanaBlockRewardMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Number of reward lamports credited or debited by the account"""
  amount
  """The slot index of this block`s parent"""
  parent_slot
  """Account balances after the transaction was processed"""
  post_balance
  """Account"""
  account
}

enum SolanaBlockRewardUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique hash of the the block"""
  block_hash
  """Unique accounts"""
  account
  """Unique currencies"""
  currencies
}

enum SolanaBlockUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  height
}

"""Solana Coinpath"""
type SolanaCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: SolanaCoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: SolanaCoinpathMeasureable!, get: SolanaCoinpathMeasureable): String
  minimum(of: SolanaCoinpathMeasureable!, get: SolanaCoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Transaction of transfer happened"""
  signature: SolanaSignatureValueDimension
}

enum SolanaCoinpathMeasureable {
  """Time"""
  time
  """Block"""
  block
  """Signature"""
  signature
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Depth"""
  depth
}

"""Crypto currency ( token, coin, currency )"""
type SolanaCryptoCurrency {
  """Token Smart Contract Address"""
  address: String
  """Decimals"""
  decimals: Int!
  """Currency name"""
  name: String
  """Currency symbol"""
  symbol: String!
  """Token ID"""
  tokenId: String
  """Token Type"""
  tokenType: String
}

"""Currency is defined by a mint address. Solana coin defined as 'SOL'. You can use filter bby symbol, bbut it only works if there is just one token with that symbol"""
input SolanaCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

"""Instruction in Solana  blockchain"""
type SolanaInstruction {
  """Accounts count"""
  accountsCount: Int
  """Action"""
  action(parsedActionName: StringSelector, parsedType: StringSelector): Action
  any(of: SolanaInstructionMeasureable!): String
  """Block where  transaction is included"""
  block(height: BlockSelector, blockHash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  """Call Path"""
  callPath(callPath: StringSelector): String
  count(uniq: SolanaInstructionUniq): Int
  countBigInt(uniq: SolanaInstructionUniq): BigInt
  """Instruction Data"""
  data(dataBase58: StringSelector, dataHex: StringSelector): Data
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """External"""
  external(external: BooleanSelector): Boolean
  """External Action"""
  externalAction(externalParsedActionName: StringSelector, externalParsedType: StringSelector): Action
  """External Program"""
  externalProgram(externalProgramId: StringSelector, externalProgramName: StringSelector, externalParsedProgramName: StringSelector): Program
  log: Log
  maximum(of: SolanaInstructionMeasureable!, get: SolanaInstructionMeasureable): String
  minimum(of: SolanaInstructionMeasureable!, get: SolanaInstructionMeasureable): String
  """Program"""
  program(programId: StringSelector, programName: StringSelector, parsedProgramName: StringSelector): Program
  """Transaction where instruction is included"""
  transaction(signature: HashSelector): SolanaTransactionInfo
}

"""InstructionAccount in Solana  blockchain"""
type SolanaInstructionAccount {
  """Information about account"""
  account(accountName: StringSelector, accountOwner: StringSelector, accountType: StringSelector, accountIndex: IntegerSelector): SolanaAccount
  any(of: SolanaInstructionAccountMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, blockHash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  count(uniq: SolanaInstructionAccountUniq): Int
  countBigInt(uniq: SolanaInstructionAccountUniq): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Instruction"""
  instruction: Instruction
  maximum(of: SolanaInstructionAccountMeasureable!, get: SolanaInstructionAccountMeasureable): String
  minimum(of: SolanaInstructionAccountMeasureable!, get: SolanaInstructionAccountMeasureable): String
  """Transaction"""
  transaction(transactionIndex: IntegerSelector, signature: HashSelector): SolanaTransactionInfo
}

input SolanaInstructionAccountFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: StringSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  parsed: IntegerSelector
  parsedActionName: StringSelector
  parsedType: StringSelector
  external: IntegerSelector
  callPath: StringSelector
  fee: IntegerSelector
  account: StringSelector
  accountType: StringSelector
  accountOwner: StringSelector
  accountIndex: IntegerSelector
}

enum SolanaInstructionAccountMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Transaction Hash"""
  signature
}

enum SolanaInstructionAccountUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Number of block in the blockchains"""
  height
  """Transaction Hash"""
  signature
  """Account name"""
  account_name
}

input SolanaInstructionFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: StringSelector
  feePayer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  parsed: IntegerSelector
  externalParsed: IntegerSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  externalParsedType: StringSelector
  external: IntegerSelector
  callPath: StringSelector
  fee: IntegerSelector
}

enum SolanaInstructionMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Transaction Hash"""
  signature
  """Transaction Fee"""
  fee
}

enum SolanaInstructionUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Number of block in the blockchains"""
  height
  """Transaction Hash"""
  signature
}

enum SolanaNetwork {
  """Solana Mainnat"""
  solana
}

enum SolanaRewardType {
  """fee type"""
  Fee
  """rent type"""
  Rent
  """voing type"""
  Voting
  """staking type"""
  Staking
}

"""Blockchain transaction with value"""
type SolanaSignatureValueDimension {
  """Transaction hash"""
  hash: String!
  """Transaction value"""
  value: Float!
}

"""Transaction in Solana  blockchain"""
type SolanaTransaction {
  """Count of inner instructions"""
  accountsCount(accountsCount: IntegerSelector): Int
  any(of: SolanaTransactionMeasureable!): String
  """Block where  transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  count(uniq: SolanaTransactionUniq): Int
  countBigInt(uniq: SolanaTransactionUniq): BigInt
  """The date this transaction was created"""
  date: Date
  """Error"""
  error(error: StringSelector): String
  expression(get: String!): DecimalNumber
  """Fee Payer"""
  feePayer(feePayer: HashSelector): String
  """Count of inner instructions"""
  innerInstructionsCount(innerInstructionsCount: IntegerSelector): Int
  """Count of instructions"""
  instructionsCount(instructionsCount: IntegerSelector): Int
  maximum(of: SolanaTransactionMeasureable!, get: SolanaTransactionMeasureable): String
  minimum(of: SolanaTransactionMeasureable!, get: SolanaTransactionMeasureable): String
  """Recent blockhash prevents duplication and to give transactions lifetimes"""
  recentBlockHash(recentBlockHash: HashSelector): String
  """Transaction Hash"""
  signature(signature: HashSelector): String
  """Accounts` public keys"""
  signer(signer: HashSelector): String
  """Successed or failed"""
  success(success: BooleanSelector): Boolean
  transactionFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, parentSlot: BlockSelector, instructionsCount: IntegerSelector, innerInstructionsCount: IntegerSelector, accountsCount: IntegerSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, success: BooleanSelector, fee: IntegerSelector, signer: HashSelector, transactionFee: AmountSelector): Float
  """Transaction Index"""
  transactionIndex(transactionIndex: IntegerSelector): Int
}

input SolanaTransactionFilter {
  date: DateSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  parentSlot: BlockSelector
  instructionsCount: IntegerSelector
  innerInstructionsCount: IntegerSelector
  accountsCount: IntegerSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  success: BooleanSelector
  fee: IntegerSelector
  signer: HashSelector
  transactionFee: AmountSelector
}

"""Solana Transaction Info"""
type SolanaTransactionInfo {
  feePayer: String
  signature: String
  success: Boolean
  transactionIndex: BigInt
}

"""Solana Transaction Info Extended"""
type SolanaTransactionInfoExt {
  accountsCount: Int
  error: String
  fee: Float
  feePayer: String
  innerInstructionsCount: Int
  instructionsCount: Int
  recentBlockHash: String
  signature: String
  signer: String
  success: Boolean
  transactionIndex: BigInt
}

enum SolanaTransactionMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """The slot index of this block`s parent"""
  parent_slot
  """Transaction Hash"""
  signature
  """Transaction Fee"""
  fee
  """Transaction Fee"""
  transaction_fee
}

enum SolanaTransactionUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Number of block in the blockchains"""
  height
  """Transaction Hash"""
  signature
  """Accounts` public key"""
  signer
}

"""Currency transfers from/to addresses in crypto currencies"""
type SolanaTransfer {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, signer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderMintAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverMintAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, amount: [AmountSelector!], tokenAccount: [StringSelector!], currency: [SolanaCurrencySelector!]): Float
  any(of: SolanaTransferMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, hash: HashSelector, time: DateTimeSelector): SolanaBlockInfo
  count(uniq: SolanaTransferUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, signer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderMintAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverMintAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, amount: [AmountSelector!], tokenAccount: [StringSelector!], currency: [SolanaCurrencySelector!]): Int
  countBigInt(uniq: SolanaTransferUniq, date: DateSelector, time: DateTimeSelector, blockHash: HashSelector, height: BlockSelector, previousBlockHash: HashSelector, recentBlockHash: HashSelector, transactionIndex: IntegerSelector, signature: HashSelector, feePayer: HashSelector, signer: HashSelector, success: BooleanSelector, programId: StringSelector, parsedProgramName: StringSelector, externalProgramId: StringSelector, externalParsedProgramName: StringSelector, parsed: IntegerSelector, externalParsed: IntegerSelector, parsedActionName: StringSelector, externalParsedActionName: StringSelector, parsedType: StringSelector, externalParsedType: StringSelector, external: StringSelector, callPath: StringSelector, senderAddress: StringSelector, senderMintAddress: StringSelector, senderType: StringSelector, receiverAddress: StringSelector, receiverMintAddress: StringSelector, receiverType: StringSelector, transferType: SolanaTransferTypeSelector, amount: [AmountSelector!], tokenAccount: [StringSelector!], currency: [SolanaCurrencySelector!]): BigInt
  """Currency of transfer"""
  currency: SolanaCryptoCurrency
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  """Instruction where transfer is included"""
  instruction: InstructionWithExternals
  maximum(of: SolanaTransferMeasureable!, get: SolanaTransferMeasureable): String
  minimum(of: SolanaTransferMeasureable!, get: SolanaTransferMeasureable): String
  """Receiver"""
  receiver: Receiver
  """Sender"""
  sender: Sender
  """Transaction where transfer is included"""
  transaction(signature: HashSelector): SolanaTransactionInfoExt
  """Transfer Type"""
  transferType(transferType: SolanaTransferTypeSelector): String
}

input SolanaTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  blockHash: HashSelector
  height: BlockSelector
  previousBlockHash: HashSelector
  recentBlockHash: HashSelector
  transactionIndex: IntegerSelector
  signature: HashSelector
  feePayer: HashSelector
  signer: HashSelector
  success: BooleanSelector
  programId: StringSelector
  parsedProgramName: StringSelector
  externalProgramId: StringSelector
  externalParsedProgramName: StringSelector
  parsed: IntegerSelector
  externalParsed: IntegerSelector
  parsedActionName: StringSelector
  externalParsedActionName: StringSelector
  parsedType: StringSelector
  externalParsedType: StringSelector
  external: StringSelector
  callPath: StringSelector
  senderAddress: StringSelector
  senderMintAddress: StringSelector
  senderType: StringSelector
  receiverAddress: StringSelector
  receiverMintAddress: StringSelector
  receiverType: StringSelector
  transferType: SolanaTransferTypeSelector
  amount: [AmountSelector!]
  tokenAccount: [StringSelector!]
  currency: [SolanaCurrencySelector!]
}

enum SolanaTransferMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Hash of the the block"""
  block_hash
  """Number of block in the blockhains"""
  height
  """The block hash of this block`s parent"""
  previous_block_hash
  """Transaction Hash"""
  signature
  """Transaction Fee"""
  fee_payer
  """Transfer Type"""
  transfer_type
  """Amount Transfer"""
  amount
  """Currency Symbol"""
  currency_symbol
  """Currency Name"""
  currency_name
  """Token Type"""
  token_type
  """Token ID"""
  token_id
}

enum SolanaTransferType {
  """Transfer"""
  transfer
  """Self"""
  self
  """Mint"""
  mint
  """Create Account"""
  create_account
  """Close Account"""
  close_account
  """Rent Exemption"""
  rent_exemption
  """Stake"""
  stake
  """Stake Withdraw"""
  stake_withdraw
  """Trade Unknown"""
  trade_unknown
  """Burn"""
  burn
  """Vote"""
  vote
  """Nonce Withdraw"""
  nonce_withdraw
}

"""Select by transfer type"""
input SolanaTransferTypeSelector {
  """Type is"""
  is: SolanaTransferType
  """Type not"""
  not: SolanaTransferType
  """Type in the list"""
  in: [SolanaTransferType!]
  """Type not in the list"""
  notIn: [SolanaTransferType!]
}

enum SolanaTransferUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Number of block in the blockchains"""
  height
  """Transaction Hash"""
  signature
  """Fee Payer"""
  fee_payer
  """Signer"""
  signer
  """Transfer From"""
  sender_address
  """Transfer To"""
  receiver_address
  """Transfer From Mint Address"""
  sender_mint_address
  """Transfer To Mint Address"""
  receiver_mint_address
  """Currencies"""
  currencies
  """Token Account Address"""
  token_account
}

enum StakingTransactionsTypeEnum {
  """"""
  CreateValidator
  """"""
  EditValidator
  """"""
  CollectRewards
  """"""
  Undelegate
  """"""
  Delegate
}

"""Indicates what type of operation the transaction is supposed to do."""
input StakingTransactionsTypeSelector {
  """Type is"""
  is: StakingTransactionsTypeEnum
  """Type not"""
  not: StakingTransactionsTypeEnum
  """Type in the list"""
  in: [StakingTransactionsTypeEnum!]
  """Type not in the list"""
  notIn: [StakingTransactionsTypeEnum!]
}

"""Stellar Chain"""
type Stellar {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [StellarAddressInfo!]!
  """Blockchain Address Statistics"""
  addressStats(address: AddressSelector!, options: QueryOptions): [StellarAddressStats!]
  """Stellar Balance Effects"""
  balanceEffects(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, amount: FloatSelector, any: [StellarBalanceEffectFilter!], options: QueryOptions): [StellarBalanceEffect!]
  """Stellar Ledgers"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, maxTxSetSize: IntegerSelector, protocolVersion: IntegerSelector, totalCoins: FloatSelector, feePool: FloatSelector, baseFee: FloatSelector, baseReserve: FloatSelector, any: [StellarBlockFilter!], options: QueryOptions): [StellarBlock!]
  """Stellar Claimable Balance Effects"""
  claimableBalanceEffects(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, sponsor: AddressSelector, claimant: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, balanceId: StringSelector, amount: FloatSelector, any: [StellarClaimableBalanceEffectFilter!], options: QueryOptions): [StellarClaimableBalanceEffect!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currencyFrom: CurrencySelector, currencyTo: CurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [StellarCoinpath!]
  """Stellar Effect Arguments"""
  effectArguments(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, argname: StringSelector, argvalue: StringSelector, any: [StellarEffectArgumentFilter!], options: QueryOptions): [StellarEffectArgument!]
  """Stellar Effects"""
  effects(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, details: StringSelector, address: AddressSelector, any: [StellarEffectFilter!], options: QueryOptions): [StellarEffect!]
  """Stellar Liquidity Pool Effects"""
  liquidityPoolEffects(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, currencyName: CurrencySelector, issuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, amount: FloatSelector, shares: FloatSelector, any: [StellarLiquidityPoolEffectFilter!], options: QueryOptions): [StellarLiquidityPoolEffect!]
  """Stellar Liquidity Pool Trade Effects"""
  liquidityPoolTradeEffects(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, buyAmount: FloatSelector, sellAmount: FloatSelector, any: [StellarLiquidityPoolTradeEffectFilter!], options: QueryOptions): [StellarLiquidityPoolTradeEffect!]
  """Stellar Operations"""
  operations(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, index: IntegerSelector, sourceAccount: AddressSelector, details: StringSelector, success: BooleanSelector, any: [StellarOperationFilter!], options: QueryOptions): [StellarOperation!]
  """Stellar Payments"""
  payments(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector, any: [StellarPaymentFilter!], options: QueryOptions): [StellarPayment!]
  """Stellar Trade Effects"""
  tradeEffects(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, seller: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, offerId: IntegerSelector, buyAmount: FloatSelector, sellAmount: FloatSelector, any: [StellarTradeEffectFilter!], options: QueryOptions): [StellarTradeEffect!]
  """Stellar Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, block: BlockSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, memos: StringSelector, memoType: StringSelector, timeBounds: StringSelector, sequence: IntegerSelector, success: BooleanSelector, fee: FloatSelector, maxFee: FloatSelector, any: [StellarTransactionFilter!], options: QueryOptions): [StellarTransaction!]
  """Stellar Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector, any: [StellarTransferFilter!], options: QueryOptions): [StellarTransfer!]
}

"""Address detailed information for Stellar network"""
type StellarAddressInfo {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """XLM balance"""
  balance(in: BaseCurrencyEnum): Float
  """Token Balances"""
  tokenBalances: [StellarTokenBalances!]
}

"""
Counts and aggregates for the address, transfer count,
                  amount, number of distinct currencies,
                  times of the first and the last transactions
"""
type StellarAddressStat {
  """Address"""
  address: Address
  """Balance"""
  balance: BigInt
  """Days with received"""
  daysWithReceived: BigInt
  """Days with sent"""
  daysWithSent: BigInt
  """Days with transactions"""
  daysWithTransactions: BigInt
  """Days with transfers"""
  daysWithTransfers: BigInt
  """First transfer at"""
  firstTransferAt: DateTime
  """First tx at"""
  firstTxAt: DateTime
  """Last transfer at"""
  lastTransferAt: DateTime
  """Last tx at"""
  lastTxAt: DateTime
  """Receive Amount"""
  receiveAmount: BigInt
  """Receive from Count"""
  receiveFromCount: BigInt
  """Receive from currencies"""
  receiveFromCurrencies: BigInt
  """Receive tx Count"""
  receiveTxCount: BigInt
  """Send Amount"""
  sendAmount: BigInt
  """Send to count"""
  sendToCount: BigInt
  """Send to currencies"""
  sendToCurrencies: BigInt
  """Send tx count"""
  sendTxCount: BigInt
}

"""AddressStat"""
type StellarAddressStats {
  """Address With Statistics"""
  address: StellarAddressStat
}

"""Balance effect in Stellar blockchain"""
type StellarBalanceEffect {
  """Address"""
  address: Address
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, amount: FloatSelector): DecimalNumberAsDiv
  any(of: StellarBalanceEffectMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: StellarBalanceEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, amount: FloatSelector): Int
  countBigInt(uniq: StellarBalanceEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, amount: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Effect index"""
  effectIndex: Int
  expression(get: String!): DecimalNumber
  """Issuer"""
  issuer: Address
  maximum(of: StellarBalanceEffectMeasurable!, get: StellarBalanceEffectMeasurable): String
  minimum(of: StellarBalanceEffectMeasurable!, get: StellarBalanceEffectMeasurable): String
  """Operation"""
  operation: OperationIndexedWithAccount
  """Order"""
  order: Int
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarBalanceEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  currencyName: CurrencySelector
  issuer: AddressSelector
  amount: FloatSelector
}

enum StellarBalanceEffectMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Operation source account"""
  opSourceAccount
  """Effect index"""
  effectIndex
  """Order"""
  order
  """Address"""
  address
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Issuer"""
  issuer
  """Amount"""
  amount
}

enum StellarBalanceEffectUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq operation indices count"""
  opIndices
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq effect indices count"""
  effectIndices
  """Uniq orders count"""
  orders
  """Uniq addresses count"""
  addresses
  """Uniq currencies name count"""
  currenciesName
  """Uniq currencies symbol count"""
  currenciesSymbol
  """Uniq issuers count"""
  issuers
}

"""Block in Stellar blockchain"""
type StellarBlock {
  any(of: StellarBlockMeasurable!): String
  baseFee(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, maxTxSetSize: IntegerSelector, protocolVersion: IntegerSelector, totalCoins: FloatSelector, feePool: FloatSelector, baseFee: FloatSelector, baseReserve: FloatSelector): DecimalNumberAsDiv
  baseReserve(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, maxTxSetSize: IntegerSelector, protocolVersion: IntegerSelector, totalCoins: FloatSelector, feePool: FloatSelector, baseFee: FloatSelector, baseReserve: FloatSelector): DecimalNumberAsDiv
  count(uniq: StellarBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, maxTxSetSize: IntegerSelector, protocolVersion: IntegerSelector, totalCoins: FloatSelector, feePool: FloatSelector, baseFee: FloatSelector, baseReserve: FloatSelector): Int
  countBigInt(uniq: StellarBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, maxTxSetSize: IntegerSelector, protocolVersion: IntegerSelector, totalCoins: FloatSelector, feePool: FloatSelector, baseFee: FloatSelector, baseReserve: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  feePool(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, maxTxSetSize: IntegerSelector, protocolVersion: IntegerSelector, totalCoins: FloatSelector, feePool: FloatSelector, baseFee: FloatSelector, baseReserve: FloatSelector): DecimalNumberAsDiv
  """Block hash"""
  hash: String!
  """Ledger number (block|height) in blockchain"""
  height: Int!
  """Max transaction set size"""
  maxTxSetSize: Int!
  maximum(of: StellarBlockMeasurable!, get: StellarBlockMeasurable): String
  minimum(of: StellarBlockMeasurable!, get: StellarBlockMeasurable): String
  """Protocol version"""
  protocolVersion: Int!
  """Block timestamp"""
  timestamp: DateTime
  totalCoins(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, maxTxSetSize: IntegerSelector, protocolVersion: IntegerSelector, totalCoins: FloatSelector, feePool: FloatSelector, baseFee: FloatSelector, baseReserve: FloatSelector): DecimalNumberAsDiv
}

input StellarBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  maxTxSetSize: IntegerSelector
  protocolVersion: IntegerSelector
  totalCoins: FloatSelector
  feePool: FloatSelector
  baseFee: FloatSelector
  baseReserve: FloatSelector
}

enum StellarBlockMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  hash
  """Total coins"""
  totalCoins
  """Fee pool"""
  feePool
  """Base fee"""
  baseFee
  """Base reserve"""
  baseReserve
  """Max tx set size"""
  maxTxSetSize
  """Protocol version"""
  protocolVersion
}

enum StellarBlockUniq {
  """Uniq date count"""
  dates
  """Uniq blocks count"""
  blocks
  """Uniq hashes count"""
  hashes
  """Uniq max tx set sizes count"""
  maxTxSetSizes
  """Uniq protocol versions"""
  protocolVersions
}

"""Claimable balance effect in Stellar blockchain"""
type StellarClaimableBalanceEffect {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, sponsor: AddressSelector, claimant: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, balanceId: StringSelector, amount: FloatSelector): DecimalNumberAsDiv
  any(of: StellarClaimableBalanceEffectMeasurable!): String
  """Balance"""
  balanceId: String
  """Block"""
  block: BigInt
  """Claimant"""
  claimant: Address
  count(uniq: StellarClaimableBalanceEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, sponsor: AddressSelector, claimant: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, balanceId: StringSelector, amount: FloatSelector): Int
  countBigInt(uniq: StellarClaimableBalanceEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, sponsor: AddressSelector, claimant: AddressSelector, currencyName: CurrencySelector, issuer: AddressSelector, balanceId: StringSelector, amount: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Effect"""
  effect: String
  """Effect index"""
  effectIndex: Int
  expression(get: String!): DecimalNumber
  """Issuer"""
  issuer: Address
  maximum(of: StellarClaimableBalanceEffectMeasurable!, get: StellarClaimableBalanceEffectMeasurable): String
  minimum(of: StellarClaimableBalanceEffectMeasurable!, get: StellarClaimableBalanceEffectMeasurable): String
  """Operation"""
  operation: OperationIndexedWithAccount
  """Order"""
  order: Int
  """Sponsor"""
  sponsor: Address
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarClaimableBalanceEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  sponsor: AddressSelector
  claimant: AddressSelector
  currencyName: CurrencySelector
  issuer: AddressSelector
  balanceId: StringSelector
  amount: FloatSelector
}

enum StellarClaimableBalanceEffectMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Operation source account"""
  opSourceAccount
  """Effect"""
  effect
  """Effect index"""
  effectIndex
  """Order"""
  order
  """Sponsor"""
  sponsor
  """Claimant"""
  claimant
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Issuer"""
  issuer
  """Amount"""
  amount
}

enum StellarClaimableBalanceEffectUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq operaion indices count"""
  opIndices
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq effects count"""
  effects
  """Uniq effect indices count"""
  effectIndices
  """Uniq orders count"""
  orders
  """Uniq sponsors count"""
  sponsors
  """Uniq claimants count"""
  claimants
  """Uniq currencies name count"""
  currenciesName
  """Uniq currencies symbol count"""
  currenciesSymbol
  """Uniq issuers count"""
  issuers
}

"""Stellar Coinpath"""
type StellarCoinpath {
  """Summary of transfered value from"""
  amountFrom(in: BaseCurrencyEnum): Float
  """Summary of transfered value to"""
  amountTo(in: BaseCurrencyEnum): Float
  any(of: StellarCoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency From of transfer"""
  currencyFrom: Currency
  """Currency To of transfer"""
  currencyTo: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: StellarCoinpathMeasureable!, get: StellarCoinpathMeasureable): String
  minimum(of: StellarCoinpathMeasureable!, get: StellarCoinpathMeasureable): String
  """Operation"""
  operation: String
  """Receiver address"""
  receiver: StellarCoinpathAddress
  """Sender address"""
  sender: StellarCoinpathAddress
  """Transaction of transfer happened"""
  transaction: StellarTransactionCoinpathDimension
}

"""Address detailed information for Stellar network"""
type StellarCoinpathAddress {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """First Tx At"""
  firstTransferAt: DateTime
  """Last Tx At"""
  lastTransferAt: DateTime
  receiversCount: Int
  sendersCount: Int
}

enum StellarCoinpathMeasureable {
  """Time"""
  time
  """Block"""
  block
  """Version"""
  tx_hash
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Depth"""
  depth
}

"""Effect in Stellar blockchain"""
type StellarEffect {
  """Address"""
  address: Address
  any(of: StellarEffectMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: StellarEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, details: StringSelector, address: AddressSelector): Int
  countBigInt(uniq: StellarEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, details: StringSelector, address: AddressSelector): BigInt
  """Calendar date"""
  date: Date
  """Details"""
  details: String
  """Effect"""
  effect: String
  expression(get: String!): DecimalNumber
  """Effect index"""
  index: Int
  maximum(of: StellarEffectMeasurable!, get: StellarEffectMeasurable): String
  minimum(of: StellarEffectMeasurable!, get: StellarEffectMeasurable): String
  """Operation"""
  operation: OperationIndexedWithAccount
  """Order"""
  order: Int
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

"""Effect argument in Stellar blockchain"""
type StellarEffectArgument {
  """Address"""
  address: Address
  any(of: StellarEffectArgumentMeasurable!): String
  """Argname"""
  argname: String
  """Argvalue"""
  argvalue: String
  """Block"""
  block: BigInt
  count(uniq: StellarEffectArgumentUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, argname: StringSelector, argvalue: StringSelector): Int
  countBigInt(uniq: StellarEffectArgumentUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, argname: StringSelector, argvalue: StringSelector): BigInt
  """Calendar date"""
  date: Date
  """Effect"""
  effect: String
  """Effect index"""
  effectIndex: Int
  expression(get: String!): DecimalNumber
  maximum(of: StellarEffectArgumentMeasurable!, get: StellarEffectArgumentMeasurable): String
  minimum(of: StellarEffectArgumentMeasurable!, get: StellarEffectArgumentMeasurable): String
  """Operation"""
  operation: OperationIndexedWithAccount
  """Order"""
  order: Int
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarEffectArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  argname: StringSelector
  argvalue: StringSelector
}

enum StellarEffectArgumentMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Operation source account"""
  opSourceAccount
  """Effect"""
  effect
  """Effect index"""
  effectIndex
  """Order"""
  order
  """Address"""
  address
  """Argname"""
  argname
  """Argvalue"""
  argvalue
}

enum StellarEffectArgumentUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq operation indices count"""
  opIndices
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq effects count"""
  effects
  """Uniq effect indices count"""
  effectIndices
  """Uniq orders count"""
  orders
  """Uniq addresses count"""
  addresses
  """Uniq argnames count"""
  argnames
  """Uniq argvalues count"""
  argvalues
}

input StellarEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  details: StringSelector
  address: AddressSelector
}

enum StellarEffectMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Operation source account"""
  opSourceAccount
  """Effect"""
  effect
  """Effect index"""
  effectIndex
  """Order"""
  order
  """Details"""
  details
  """Address"""
  address
}

enum StellarEffectUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq operation indices count"""
  opIndices
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq effects count"""
  effects
  """Uniq effect indices count"""
  effectIndices
  """Uniq orders count"""
  orders
  """Uniq details count"""
  details
  """Uniq addresses count"""
  addresses
}

"""Liquidity pool effect in Stellar blockchain"""
type StellarLiquidityPoolEffect {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, currencyName: CurrencySelector, issuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, amount: FloatSelector, shares: FloatSelector): DecimalNumberAsDiv
  any(of: StellarLiquidityPoolEffectMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: StellarLiquidityPoolEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, currencyName: CurrencySelector, issuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, amount: FloatSelector, shares: FloatSelector): Int
  countBigInt(uniq: StellarLiquidityPoolEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, currencyName: CurrencySelector, issuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, amount: FloatSelector, shares: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Effect"""
  effect: String
  """Effect index"""
  effectIndex: Int
  expression(get: String!): DecimalNumber
  """Issuer"""
  issuer: Address
  """Liquidity pool details"""
  liquidityPoolDetails: String
  """Liquidity pool id bin"""
  liquidityPoolId: String
  maximum(of: StellarLiquidityPoolEffectMeasurable!, get: StellarLiquidityPoolEffectMeasurable): String
  minimum(of: StellarLiquidityPoolEffectMeasurable!, get: StellarLiquidityPoolEffectMeasurable): String
  """Operation"""
  operation: OperationIndexedWithAccount
  """Order"""
  order: Int
  shares(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effect: StringSelector, effectIndex: IntegerSelector, order: IntegerSelector, currencyName: CurrencySelector, issuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, amount: FloatSelector, shares: FloatSelector): DecimalNumber
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarLiquidityPoolEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effect: StringSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  currencyName: CurrencySelector
  issuer: AddressSelector
  liquidityPoolId: StringSelector
  liquidityPoolDetails: StringSelector
  amount: FloatSelector
  shares: FloatSelector
}

enum StellarLiquidityPoolEffectMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Operation source account"""
  opSourceAccount
  """Effect"""
  effect
  """Effect index"""
  effectIndex
  """Order"""
  order
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Amount"""
  amount
  """Issuer"""
  issuer
  """Shares"""
  shares
  """Liquidity pool id"""
  liquidityPoolId
  """Liquidity pool details"""
  liquidityPoolDetails
}

enum StellarLiquidityPoolEffectUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq operation indices count"""
  opIndices
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq effects count"""
  effects
  """Uniq effect indices count"""
  effectIndices
  """Uniq orders count"""
  orders
  """Uniq currencies name count"""
  currenciesName
  """Uniq currencies symbol count"""
  currenciesSymbol
  """Uniq issuers count"""
  issuers
  """Uniq liquidity pool ids count"""
  liquidityPoolIds
  """Uniq liquidity pool details count"""
  liquidityPoolDetails
}

"""Liquidity pool trade effect in Stellar blockchain"""
type StellarLiquidityPoolTradeEffect {
  """Address"""
  address: Address
  any(of: StellarLiquidityPoolTradeEffectMeasurable!): String
  """Block"""
  block: BigInt
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): DecimalNumberAsDiv
  """Buy currency"""
  buyCurrency: Currency
  """Buy issuer"""
  buyIssuer: Address
  count(uniq: StellarLiquidityPoolTradeEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): Int
  countBigInt(uniq: StellarLiquidityPoolTradeEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  """Effect index"""
  effectIndex: Int
  expression(get: String!): DecimalNumber
  """Liquidity pool details"""
  liquidityPoolDetails: String
  """Liquidity pool"""
  liquidityPoolId: String
  maximum(of: StellarLiquidityPoolTradeEffectMeasurable!, get: StellarLiquidityPoolTradeEffectMeasurable): String
  minimum(of: StellarLiquidityPoolTradeEffectMeasurable!, get: StellarLiquidityPoolTradeEffectMeasurable): String
  """Operation"""
  operation: OperationIndexedWithAccount
  """Order"""
  order: Int
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, liquidityPoolId: StringSelector, liquidityPoolDetails: StringSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): DecimalNumberAsDiv
  """Sell currency"""
  sellCurrency: Currency
  """Sell issuer"""
  sellIssuer: Address
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarLiquidityPoolTradeEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  buyCurrencyName: CurrencySelector
  buyIssuer: AddressSelector
  sellCurrencyName: CurrencySelector
  sellIssuer: AddressSelector
  liquidityPoolId: StringSelector
  liquidityPoolDetails: StringSelector
  buyAmount: FloatSelector
  sellAmount: FloatSelector
}

enum StellarLiquidityPoolTradeEffectMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Opertation source account"""
  opSourceAccount
  """Effect index"""
  effectIndex
  """Order"""
  order
  """Address"""
  address
  """Buy currency name"""
  buyCurrencyName
  """Buy currency symbol"""
  buyCurrencySymbol
  """Buy amount"""
  buyAmount
  """Buy issuer"""
  buyIssuer
  """Sell currency name"""
  sellCurrencyName
  """Sell currency symbol"""
  sellCurrencySymbol
  """Sell amount"""
  sellAmount
  """Sell issuer"""
  sellIssuer
  """Liquidity pool"""
  liquidityPoolId
  """Liquidity pool details"""
  liquidityPoolDetails
}

enum StellarLiquidityPoolTradeEffectUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq operation indices count"""
  opIndices
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq effect indices count"""
  effectIndices
  """Uniq orders count"""
  orders
  """Uniq addresses count"""
  addresses
  """Uniq buy currency names count"""
  buyCurrencyNames
  """Uniq buy currency symbols count"""
  buyCurrencySymbols
  """Uniq buy issuers count"""
  buyIssuers
  """Uniq sell currency names count"""
  sellCurrencyNames
  """Uniq sell currency symbols count"""
  sellCurrencySymbols
  """Uniq sell issuers count"""
  sellIssuers
  """Uniq liquidity pool ids count"""
  liquidityPoolIds
  """Uniq liquidity pool details count"""
  liquidityPoolDetails
}

enum StellarNetwork {
  """The Stellar Ledger"""
  stellar
}

"""Operation in Stellar blockchain"""
type StellarOperation {
  any(of: StellarOperationMeasurable!): String
  """Block"""
  block: BigInt
  count(uniq: StellarOperationUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, index: IntegerSelector, sourceAccount: AddressSelector, details: StringSelector, success: BooleanSelector): Int
  countBigInt(uniq: StellarOperationUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, index: IntegerSelector, sourceAccount: AddressSelector, details: StringSelector, success: BooleanSelector): BigInt
  """Calendar date"""
  date: Date
  """Details"""
  details: String
  expression(get: String!): DecimalNumber
  """Operation index"""
  index: Int
  maximum(of: StellarOperationMeasurable!, get: StellarOperationMeasurable): String
  minimum(of: StellarOperationMeasurable!, get: StellarOperationMeasurable): String
  """Operation"""
  operation: String
  """Operation source account"""
  sourceAccount: Address
  """Success"""
  success: Boolean
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarOperationFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  index: IntegerSelector
  sourceAccount: AddressSelector
  details: StringSelector
  success: BooleanSelector
}

enum StellarOperationMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  index
  """Operation source account"""
  sourceAccount
  """Details"""
  details
  """Success"""
  success
}

enum StellarOperationUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq op source accounts count"""
  sourceAccounts
  """Uniq details count"""
  details
}

"""Payment in Stellar blockchain"""
type StellarPayment {
  amountFrom(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): DecimalNumberAsDiv
  amountTo(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): DecimalNumberAsDiv
  any(of: StellarPaymentMeasurable!): String
  """The sequence number of the ledger"""
  block: BigInt
  count(uniq: StellarPaymentUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): Int
  countBigInt(uniq: StellarPaymentUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): BigInt
  creditedToValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): DecimalNumberAsDiv
  """Sender's currency"""
  currencyFrom: Currency
  """Receiver's currency"""
  currencyTo: Currency
  """Calendar date"""
  date: Date
  debitedFromValue(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): DecimalNumberAsDiv
  expression(get: String!): DecimalNumber
  """Source issuer"""
  issuerFrom: Address
  """Issuer"""
  issuerTo: Address
  maxValueFrom(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): DecimalNumberAsDiv
  maximum(of: StellarPaymentMeasurable!, get: StellarPaymentMeasurable): String
  minValueTo(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, issuerFrom: AddressSelector, issuerTo: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, path: StringSelector, success: BooleanSelector, amountFrom: FloatSelector, amountTo: FloatSelector, minValueTo: FloatSelector, maxValueFrom: FloatSelector, debitedFromValue: FloatSelector, creditedToValue: FloatSelector): DecimalNumberAsDiv
  minimum(of: StellarPaymentMeasurable!, get: StellarPaymentMeasurable): String
  """Operation"""
  operation: OperationIndexedWithAccount
  """Path"""
  path: String
  """Payment receiver"""
  receiver: Address
  """Payment sender"""
  sender: Address
  """Success"""
  success: Boolean
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarPaymentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  receiver: AddressSelector
  sender: AddressSelector
  currencyFromName: CurrencySelector
  currencyToName: CurrencySelector
  issuerFrom: AddressSelector
  issuerTo: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  path: StringSelector
  success: BooleanSelector
  amountFrom: FloatSelector
  amountTo: FloatSelector
  minValueTo: FloatSelector
  maxValueFrom: FloatSelector
  debitedFromValue: FloatSelector
  creditedToValue: FloatSelector
}

enum StellarPaymentMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency from name"""
  currencyFromName
  """Currency to name"""
  currencyToName
  """Currency from symbol"""
  currencyFromSymbol
  """Currency to symbol"""
  currencyToSymbol
  """Issuer from"""
  issuerFrom
  """Issuer to"""
  issuerTo
  """Operation"""
  operation
  """Op index"""
  opIndex
  """Operation source account"""
  opSourceAccount
  """Path"""
  path
  """Success"""
  success
  """Amount from"""
  amountFrom
  """Amount to"""
  amountTo
  """Max value from"""
  maxValueFrom
  """Min value to"""
  minValueTo
  """Debited from value"""
  debitedFromValue
  """Credited to value"""
  creditedToValue
}

enum StellarPaymentUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq senders count"""
  senders
  """Uniq receivers count"""
  receivers
  """Uniq currencies from name count"""
  currenciesFromName
  """Uniq currencies to name count"""
  currenciesToName
  """Uniq currencies from symbol count"""
  currenciesFromSymbol
  """Uniq currencies to symbol count"""
  currenciesToSymbol
  """Uniq issuers from count"""
  issuersFrom
  """Uniq issuers to count"""
  issuersTo
  """Uniq operations count"""
  operations
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq paths count"""
  paths
}

"""Token Balance"""
type StellarTokenBalances {
  """Asset code"""
  assetCode: String
  """Asset issuer"""
  assetIssuer: String
  """Asset type"""
  assetType: String
  """Balance"""
  balance: Float
}

"""Trade effect in Stellar blockchain"""
type StellarTradeEffect {
  """Address"""
  address: Address
  any(of: StellarTradeEffectMeasurable!): String
  """Block"""
  block: BigInt
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, seller: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, offerId: IntegerSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): DecimalNumberAsDiv
  """Buy currency"""
  buyCurrency: Currency
  """Buy issuer"""
  buyIssuer: Address
  count(uniq: StellarTradeEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, seller: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, offerId: IntegerSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): Int
  countBigInt(uniq: StellarTradeEffectUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, seller: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, offerId: IntegerSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  """Effect index"""
  effectIndex: Int
  expression(get: String!): DecimalNumber
  maximum(of: StellarTradeEffectMeasurable!, get: StellarTradeEffectMeasurable): String
  minimum(of: StellarTradeEffectMeasurable!, get: StellarTradeEffectMeasurable): String
  """Offer"""
  offerId: BigInt
  """Operation"""
  operation: OperationIndexedWithAccount
  """Order"""
  order: Int
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionIndex: IntegerSelector, transactionHash: HashSelector, transactionSender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, opSourceAccount: AddressSelector, effectIndex: IntegerSelector, order: IntegerSelector, address: AddressSelector, seller: AddressSelector, buyCurrencyName: CurrencySelector, buyIssuer: AddressSelector, sellCurrencyName: CurrencySelector, sellIssuer: AddressSelector, offerId: IntegerSelector, buyAmount: FloatSelector, sellAmount: FloatSelector): DecimalNumberAsDiv
  """Sell currency"""
  sellCurrency: Currency
  """Sell issuer"""
  sellIssuer: Address
  """Seller"""
  seller: Address
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarTradeEffectFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionIndex: IntegerSelector
  transactionHash: HashSelector
  transactionSender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  opSourceAccount: AddressSelector
  effectIndex: IntegerSelector
  order: IntegerSelector
  address: AddressSelector
  seller: AddressSelector
  buyCurrencyName: CurrencySelector
  buyIssuer: AddressSelector
  sellCurrencyName: CurrencySelector
  sellIssuer: AddressSelector
  offerId: IntegerSelector
  buyAmount: FloatSelector
  sellAmount: FloatSelector
}

enum StellarTradeEffectMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction index"""
  transactionIndex
  """Transaction hash"""
  transactionHash
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Operation source account"""
  opSourceAccount
  """Effect index"""
  effectIndex
  """Order"""
  order
  """Address"""
  address
  """Seller"""
  seller
  """Buy currency name"""
  buyCurrencyName
  """Buy currency symbol"""
  buyCurrencySymbol
  """Buy amount"""
  buyAmount
  """Buy issuer"""
  buyIssuer
  """Sell currency name"""
  sellCurrencyName
  """Sell currency symbol"""
  sellCurrencySymbol
  """Sell amount"""
  sellAmount
  """Sell issuer"""
  sellIssuer
  """Offer"""
  offerId
}

enum StellarTradeEffectUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq transaction indices count"""
  transactionIndices
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction senders count"""
  transactionSenders
  """Uniq operations count"""
  operations
  """Uniq operation indices count"""
  opIndices
  """Uniq operation source accounts count"""
  opSourceAccounts
  """Uniq effect indices count"""
  effectIndices
  """Uniq orders count"""
  orders
  """Uniq addresses count"""
  addresses
  """Uniq sellers count"""
  sellers
  """Uniq buy currency names count"""
  buyCurrencyNames
  """Uniq buy currency symbols count"""
  buyCurrencySymbols
  """Uniq buy issuers count"""
  buyIssuers
  """Uniq sell currency names count"""
  sellCurrencyNames
  """Uniq sell currency symbols count"""
  sellCurrencySymbols
  """Uniq sell issuers count"""
  sellIssuers
  """Uniq offer ids count"""
  offerIds
}

"""Transaction in Stellar blockchain"""
type StellarTransaction {
  any(of: StellarTransactionMeasurable!): String
  """The sequence number of the ledger that this transaction was included in"""
  block: BigInt
  count(uniq: StellarTransactionUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, memos: StringSelector, memoType: StringSelector, timeBounds: StringSelector, sequence: IntegerSelector, success: BooleanSelector, fee: FloatSelector, maxFee: FloatSelector): Int
  countBigInt(uniq: StellarTransactionUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, memos: StringSelector, memoType: StringSelector, timeBounds: StringSelector, sequence: IntegerSelector, success: BooleanSelector, fee: FloatSelector, maxFee: FloatSelector): BigInt
  """The date this transaction was created"""
  date: Date
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, memos: StringSelector, memoType: StringSelector, timeBounds: StringSelector, sequence: IntegerSelector, success: BooleanSelector, fee: FloatSelector, maxFee: FloatSelector): DecimalNumberAsDiv
  """Fee payer"""
  feeAccount: Address
  """Hash of this transaction"""
  hash: String
  """Index of this transaction"""
  index: Int
  maxFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, index: IntegerSelector, hash: HashSelector, sender: AddressSelector, memos: StringSelector, memoType: StringSelector, timeBounds: StringSelector, sequence: IntegerSelector, success: BooleanSelector, fee: FloatSelector, maxFee: FloatSelector): DecimalNumberAsDiv
  maximum(of: StellarTransactionMeasurable!, get: StellarTransactionMeasurable): String
  """Memo type"""
  memoType: String
  """Memos"""
  memos: String
  minimum(of: StellarTransactionMeasurable!, get: StellarTransactionMeasurable): String
  """Amout of operations"""
  operationCount: Int
  """Sender of this transaction"""
  sender: Address
  """Sequence"""
  sequence: BigInt
  """Success"""
  success: Boolean
  """Time bounds"""
  timeBounds: String
  """The time this transaction was created"""
  timestamp: DateTime
}

"""Blockchain transaction Info"""
type StellarTransactionCoinpathDimension {
  """Hash hex representation"""
  hash: String!
  """Transaction Index"""
  index: Int!
  """Time"""
  time: DateTime
  """Transaction Value From"""
  valueFrom: Float
  """Transaction Value To"""
  valueTo: Float
}

"""Blockchain transaction"""
type StellarTransactionDimension {
  """Hash hex representation"""
  hash: String!
  """Transaction index in block"""
  index: Int!
  """Transaction sender"""
  sender: String
}

input StellarTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  index: IntegerSelector
  hash: HashSelector
  sender: AddressSelector
  memos: StringSelector
  memoType: StringSelector
  timeBounds: StringSelector
  sequence: IntegerSelector
  success: BooleanSelector
  fee: FloatSelector
  maxFee: FloatSelector
}

enum StellarTransactionMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Ledger"""
  block
  """Transaction Index"""
  index
  """Transaction Hash"""
  hash
  """Transaction sender"""
  sender
  """fee"""
  fee
  """Max fee"""
  maxFee
  """Memos"""
  memos
  """Memo type"""
  memoType
  """Time bounds"""
  timeBounds
  """Sequence"""
  sequence
  """Success"""
  success
}

enum StellarTransactionUniq {
  """Uniq date count"""
  dates
  """Uniq blocks count"""
  blocks
  """Uniq transaction hashes count"""
  hashes
  """Uniq transaction senders"""
  senders
  """Uniq memo types count"""
  memoTypes
  """Uniq sequences count"""
  sequences
}

"""Transfer in Stellar blockchain"""
type StellarTransfer {
  amountFrom(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): Float
  amountTo(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): Float
  any(of: StellarTransferMeasurable!): String
  """The sequence number of the ledger that this transaction was included in"""
  block: BigInt
  count(uniq: StellarTransferUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): Int
  countBigInt(uniq: StellarTransferUniq, date: DateSelector, time: DateTimeSelector, block: BlockSelector, transactionHash: HashSelector, transactionIndex: IntegerSelector, transactionSender: AddressSelector, receiver: AddressSelector, sender: AddressSelector, operation: StringSelector, opIndex: IntegerSelector, currencyFromName: CurrencySelector, currencyToName: CurrencySelector, direction: StringSelector, amountFrom: FloatSelector, amountTo: FloatSelector): BigInt
  """Currency from of transfer"""
  currencyFrom: Currency
  """Currency to of transfer"""
  currencyTo: Currency
  """The date this transaction was created"""
  date: Date
  """Direction"""
  direction: String
  expression(get: String!): DecimalNumber
  maximum(of: StellarTransferMeasurable!, get: StellarTransferMeasurable): String
  minimum(of: StellarTransferMeasurable!, get: StellarTransferMeasurable): String
  """Operation"""
  operation: OperationIndexed
  """The account this transaction is been sent to"""
  receiver: Address
  """Sender"""
  sender: Address
  """The time this transaction was created"""
  timestamp: DateTime
  """Transaction"""
  transaction: StellarTransactionDimension
}

input StellarTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BlockSelector
  transactionHash: HashSelector
  transactionIndex: IntegerSelector
  transactionSender: AddressSelector
  receiver: AddressSelector
  sender: AddressSelector
  operation: StringSelector
  opIndex: IntegerSelector
  currencyFromName: CurrencySelector
  currencyToName: CurrencySelector
  direction: StringSelector
  amountFrom: FloatSelector
  amountTo: FloatSelector
}

enum StellarTransferMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Ledger"""
  block
  """Transaction Hash"""
  transactionHash
  """Transaction Index"""
  transactionIndex
  """Transaction sender"""
  transactionSender
  """Operation"""
  operation
  """Operation index"""
  opIndex
  """Transfer Receiver"""
  receiver
  """Transfer Sender"""
  sender
  """Currency from name"""
  currencyFromName
  """Currency to name"""
  currencyToName
  """Currency from symbol"""
  currencyFromSymbol
  """Currency to symbol"""
  currencyToSymbol
  """Amount from"""
  amountFrom
  """Amount to"""
  amountTo
  """Direction"""
  direction
}

enum StellarTransferUniq {
  """Uniq times count"""
  times
  """Uniq dates count"""
  dates
  """Uniq transaction hashes"""
  transactionHashes
  """Uniq transaction indices"""
  transactionIndices
  """Uniq transaction senders"""
  transactionSenders
  """Uniq operations"""
  operations
  """Uniq operation indices"""
  opIndices
  """Uniq transfer receivers"""
  receivers
  """Uniq transfer senders"""
  senders
  """Uniq currency from names"""
  currenciesFromName
  """Uniq currency to names"""
  currenciesToName
  """Uniq currency from symbols"""
  currenciesFromSymbol
  """Uniq currency to symbols"""
  currenciesToSymbol
  """Uniq directions"""
  directions
}

"""Select by ID"""
input StringIdSelector {
  """ID is"""
  is: String
  """ID not"""
  not: String
  """ID in the list"""
  in: [String!]
  """ID not in the list"""
  notIn: [String!]
}

"""Select by string"""
input StringSelector {
  """String is"""
  is: String
  """String not"""
  not: String
  """String in the list"""
  in: [String!]
  """String not in the list"""
  notIn: [String!]
}

"""Search result subject"""
union Subject = Address | Currency | MessageHash | SmartContract | TransactionHash

"""Blockchain Unified GraphQL Subscription API"""
type Subscription {
  """Ethereum Mainnet / Classic Chain Datasets"""
  ethereum(network: EthereumNetwork): Ethereum
}

"""Tezos Chain"""
type Tezos {
  """Basic information about address"""
  address(address: [AddressSelectorIn!]!): [TezosAddressInfoWithBalance!]!
  """Tezos Arguments"""
  arguments(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, success: BooleanSelector, argname: StringSelector, argvalue: StringSelector, amount: FloatSelector, any: [TezosArgumentFilter!], options: QueryOptions): [TezosArgument!]
  """Tezos Balance Updates"""
  balanceUpdates(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, source: AddressSelector, freezer: BooleanSelector, category: StringSelector, address: AddressSelector, cycle: BigIntIdSelector, attribute: StringSelector, change: FloatSelector, any: [TezosBalanceUpdateFilter!], options: QueryOptions): [TezosBalanceUpdate!]
  """Tezos Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, baker: StringSelector, any: [TezosBlockFilter!], options: QueryOptions): [TezosBlock!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [TezosCoinpath!]
  """Tezos Operations"""
  operations(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, source: StringSelector, success: BooleanSelector, contents: StringSelector, any: [TezosOperationFilter!], options: QueryOptions): [TezosOperation!]
  """Tezos Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector, any: [TezosTransactionFilter!], options: QueryOptions): [TezosTransaction!]
  """Tezos Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, destinationContract: BooleanSelector, direction: StringSelector, amount: FloatSelector, any: [TezosTransferFilter!], options: QueryOptions): [TezosTransfer!]
}

"""Address detailed information for Tezos network"""
type TezosAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Wallet balance"""
  balance: [TezosBalance!]
}

"""Argument in Tezos blockchain"""
type TezosArgument {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, success: BooleanSelector, argname: StringSelector, argvalue: StringSelector, amount: FloatSelector): DecimalNumberAsDiv
  any(of: TezosArgumentMeasurable!): String
  """Argname"""
  argname: String
  """Argvalue"""
  argvalue: String
  """Block"""
  block: TezosBlockWithHashDimension
  count(uniq: TezosArgumentUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, success: BooleanSelector, argname: StringSelector, argvalue: StringSelector, amount: FloatSelector): Int
  countBigInt(uniq: TezosArgumentUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, success: BooleanSelector, argname: StringSelector, argvalue: StringSelector, amount: FloatSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Internal"""
  internal: Boolean
  maximum(of: TezosArgumentMeasurable!, get: TezosArgumentMeasurable): String
  minimum(of: TezosArgumentMeasurable!, get: TezosArgumentMeasurable): String
  """Op path"""
  opPath: String
  """Proto"""
  proto: BigInt
  """Protocol"""
  protocol: String
  """Receiver"""
  receiver: Address
  """Sender"""
  sender: Address
  """Status"""
  status: String
  """Success"""
  success: Boolean
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: TezosTransactionWithSourceDimension
}

input TezosArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  sender: AddressSelector
  receiver: AddressSelector
  status: StringSelector
  success: BooleanSelector
  argname: StringSelector
  argvalue: StringSelector
  amount: FloatSelector
}

enum TezosArgumentMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  blockHash
  """Proto"""
  proto
  """Protocol"""
  protocol
  """Transaction hash"""
  transactionHash
  """Transaction source"""
  transactionSource
  """Op path"""
  opPath
  """Internal"""
  internal
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Status"""
  status
  """Success"""
  success
  """Argname"""
  argname
  """Argvalue"""
  argvalue
  """Amount"""
  amount
}

enum TezosArgumentUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq block hashes count"""
  blockHashes
  """Uniq protos count"""
  protos
  """Uniq protocols count"""
  protocols
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction sources count"""
  transactionSources
  """Uniq op paths count"""
  opPaths
  """Uniq senders count"""
  senders
  """Uniq receivers count"""
  receivers
  """Uniq statuses count"""
  statuses
  """Uniq argnames count"""
  argnames
  """Uniq argvalues count"""
  argvalues
}

"""XTZ Balance"""
type TezosBalance {
  """Spendable Balance"""
  available(in: BaseCurrencyEnum): Float
  """Delegated Balance"""
  delegated(in: BaseCurrencyEnum): Float
  """Frozen Deposit"""
  frozenDeposit(in: BaseCurrencyEnum): Float
  """Staking Balance"""
  staking(in: BaseCurrencyEnum): Float
  """Total Balance"""
  total(in: BaseCurrencyEnum): Float
}

"""Balance update in Tezos blockchain"""
type TezosBalanceUpdate {
  """Address"""
  address: Address
  any(of: TezosBalanceUpdateMeasurable!): String
  """Attribute"""
  attribute: String
  """Block"""
  block: TezosBlockWithHashDimension
  """Category"""
  category: String
  change(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, source: AddressSelector, freezer: BooleanSelector, category: StringSelector, address: AddressSelector, cycle: BigIntIdSelector, attribute: StringSelector, change: FloatSelector): DecimalNumberAsDiv
  count(uniq: TezosBalanceUpdateUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, source: AddressSelector, freezer: BooleanSelector, category: StringSelector, address: AddressSelector, cycle: BigIntIdSelector, attribute: StringSelector, change: FloatSelector): Int
  countBigInt(uniq: TezosBalanceUpdateUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, source: AddressSelector, freezer: BooleanSelector, category: StringSelector, address: AddressSelector, cycle: BigIntIdSelector, attribute: StringSelector, change: FloatSelector): BigInt
  """Cycle"""
  cycle: BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Freezer"""
  freezer: Boolean
  """Internal"""
  internal: Boolean
  """Kind"""
  kind: String
  maximum(of: TezosBalanceUpdateMeasurable!, get: TezosBalanceUpdateMeasurable): String
  minimum(of: TezosBalanceUpdateMeasurable!, get: TezosBalanceUpdateMeasurable): String
  """Op path"""
  opPath: String
  """Proto"""
  proto: BigInt
  """Protocol"""
  protocol: String
  """Source"""
  source: Address
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: TezosTransactionWithSourceDimension
}

input TezosBalanceUpdateFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  kind: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  source: AddressSelector
  freezer: BooleanSelector
  category: StringSelector
  address: AddressSelector
  cycle: BigIntIdSelector
  attribute: StringSelector
  change: FloatSelector
}

enum TezosBalanceUpdateMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  blockHash
  """Proto"""
  proto
  """Protocol"""
  protocol
  """Kind"""
  kind
  """Transaction hash"""
  transactionHash
  """Transaction source"""
  transactionSource
  """Op path"""
  opPath
  """Internal"""
  internal
  """Source"""
  source
  """Freezer"""
  freezer
  """Category"""
  category
  """Address"""
  address
  """Cycle"""
  cycle
  """Attribute"""
  attribute
  """Change"""
  change
}

enum TezosBalanceUpdateUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq block hashes count"""
  blockHashes
  """Uniq protos count"""
  protos
  """Uniq protocols count"""
  protocols
  """Uniq kinds count"""
  kinds
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction sources count"""
  transactionSources
  """Uniq op paths count"""
  opPaths
  """Uniq sources count"""
  sources
  """Uniq categories count"""
  categories
  """Uniq addresses count"""
  addresses
  """Uniq cycles count"""
  cycles
  """Uniq attributes count"""
  attributes
}

"""Block in Tezos blockchain"""
type TezosBlock {
  any(of: TezosBlockMeasurable!): String
  """Baker"""
  baker: Address
  count(uniq: TezosBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, baker: StringSelector): Int
  countBigInt(uniq: TezosBlockUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, hash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, baker: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Hash"""
  hash: String
  """Header"""
  header: String
  """Block number (height) in blockchain"""
  height: BigInt
  maximum(of: TezosBlockMeasurable!, get: TezosBlockMeasurable): String
  """Metadata"""
  metadata: String
  minimum(of: TezosBlockMeasurable!, get: TezosBlockMeasurable): String
  """Proto"""
  proto: BigInt
  """Protocol"""
  protocol: String
  """Timestamp"""
  timestamp: DateTime
}

input TezosBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  hash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  baker: StringSelector
}

enum TezosBlockMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Height"""
  height
  """Hash"""
  hash
  """Proto"""
  proto
  """Protocol"""
  protocol
  """Baker"""
  baker
  """Metadata"""
  metadata
  """Header"""
  header
}

enum TezosBlockUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq heights count"""
  heights
  """Uniq hashes count"""
  hashes
  """Uniq protos count"""
  protos
  """Uniq protocols count"""
  protocols
  """Uniq bakers count"""
  bakers
  """Uniq metadatas count"""
  metadatas
  """Uniq headers count"""
  headers
}

"""Tezos block with hash"""
type TezosBlockWithHashDimension {
  """Block hash"""
  hash: String!
  """Block"""
  height: BigInt!
}

"""Coinpath"""
type TezosCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: Address
  """Sender address"""
  sender: Address
  """Transaction of transfer happened"""
  transaction: TransactionHashValue
}

enum TezosNetwork {
  """Tezos"""
  tezos
}

"""Operation in Tezos blockchain"""
type TezosOperation {
  any(of: TezosOperationMeasurable!): String
  """Block"""
  block: TezosBlockWithHashDimension
  """Contents"""
  contents: String
  count(uniq: TezosOperationUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, source: StringSelector, success: BooleanSelector, contents: StringSelector): Int
  countBigInt(uniq: TezosOperationUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, source: StringSelector, success: BooleanSelector, contents: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Internal"""
  internal: Boolean
  """Kind"""
  kind: String
  maximum(of: TezosOperationMeasurable!, get: TezosOperationMeasurable): String
  minimum(of: TezosOperationMeasurable!, get: TezosOperationMeasurable): String
  """Op path"""
  opPath: String
  """Proto"""
  proto: BigInt
  """Protocol"""
  protocol: String
  """Source"""
  source: String
  """Success"""
  success: Boolean
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: TezosTransactionWithSourceDimension
}

input TezosOperationFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  kind: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  source: StringSelector
  success: BooleanSelector
  contents: StringSelector
}

enum TezosOperationMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  blockHash
  """Proto"""
  proto
  """Protocol"""
  protocol
  """Kind"""
  kind
  """Transaction hash"""
  transactionHash
  """Transaction source"""
  transactionSource
  """Op path"""
  opPath
  """Internal"""
  internal
  """Source"""
  source
  """Success"""
  success
  """Contents"""
  contents
}

enum TezosOperationUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq block hashes count"""
  blockHashes
  """Uniq protos count"""
  protos
  """Uniq protocols count"""
  protocols
  """Uniq kinds count"""
  kinds
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction sources count"""
  transactionSources
  """Uniq op paths count"""
  opPaths
  """Uniq sources count"""
  sources
  """Uniq contents count"""
  contents
}

"""Transaction in Tezos blockchain"""
type TezosTransaction {
  """Allocated destination contract"""
  allocatedDestinationContract: Boolean
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): DecimalNumberAsDiv
  any(of: TezosTransactionMeasurable!): String
  """Block"""
  block: TezosBlockWithHashDimension
  burnAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): DecimalNumberAsDiv
  consumedGas(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): BigInt
  count(uniq: TezosTransactionUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): Int
  countBigInt(uniq: TezosTransactionUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): BigInt
  """Calendar date"""
  date: Date
  """Destination contract"""
  destinationContract: Boolean
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): DecimalNumberAsDiv
  gasLimit(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): BigInt
  """Transaction hash"""
  hash: String
  """Internal"""
  internal: Boolean
  maximum(of: TezosTransactionMeasurable!, get: TezosTransactionMeasurable): String
  minimum(of: TezosTransactionMeasurable!, get: TezosTransactionMeasurable): String
  """Op path"""
  opPath: String
  paidStorageAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): DecimalNumberAsDiv
  paidStorageSizeDiff(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): BigInt
  """Proto"""
  proto: BigInt
  """Protocol"""
  protocol: String
  """Receiver"""
  receiver: Address
  """Sender"""
  sender: Address
  """Transaction source"""
  source: Address
  """Status"""
  status: String
  storageSize(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, hash: HashSelector, source: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, status: StringSelector, allocatedDestinationContract: BooleanSelector, destinationContract: BooleanSelector, success: BooleanSelector, amount: FloatSelector, fee: FloatSelector, paidStorageSizeDiff: BigIntIdSelector, burnAmount: FloatSelector, paidStorageAmount: FloatSelector, gasLimit: BigIntIdSelector, consumedGas: BigIntIdSelector, storageSize: BigIntIdSelector): BigInt
  """Success"""
  success: Boolean
  """Timestamp"""
  timestamp: DateTime
}

input TezosTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  hash: HashSelector
  source: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  sender: AddressSelector
  receiver: AddressSelector
  status: StringSelector
  allocatedDestinationContract: BooleanSelector
  destinationContract: BooleanSelector
  success: BooleanSelector
  amount: FloatSelector
  fee: FloatSelector
  paidStorageSizeDiff: BigIntIdSelector
  burnAmount: FloatSelector
  paidStorageAmount: FloatSelector
  gasLimit: BigIntIdSelector
  consumedGas: BigIntIdSelector
  storageSize: BigIntIdSelector
}

enum TezosTransactionMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  blockHash
  """Proto"""
  proto
  """Protocol"""
  protocol
  """Transaction hash"""
  hash
  """Transaction source"""
  source
  """Op path"""
  opPath
  """Internal"""
  internal
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Status"""
  status
  """Allocated destination contract"""
  allocatedDestinationContract
  """Destination contract"""
  destinationContract
  """Success"""
  success
  """Amount"""
  amount
  """Fee"""
  fee
  """Paid storage size diff"""
  paid_storage_size_diff
  """Burn amount"""
  burnAmount
  """Paid storage amount"""
  paidStorageAmount
  """Gas limit"""
  gasLimit
  """Consumed gas"""
  consumedGas
  """Storage size"""
  storageSize
}

enum TezosTransactionUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq block hashes count"""
  blockHashes
  """Uniq protos count"""
  protos
  """Uniq protocols count"""
  protocols
  """Uniq transaction hashes count"""
  hashes
  """Uniq transaction sources count"""
  sources
  """Uniq op paths count"""
  opPaths
  """Uniq senders count"""
  senders
  """Uniq receivers count"""
  receivers
  """Uniq statuses count"""
  statuses
}

"""Tezos transaction with source"""
type TezosTransactionWithSourceDimension {
  """Hash hex representation"""
  hash: String!
  """Transaction source"""
  source: String
}

"""Transfer in Tezos blockchain"""
type TezosTransfer {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, destinationContract: BooleanSelector, direction: StringSelector, amount: FloatSelector): DecimalNumberAsDiv
  any(of: TezosTransferMeasurable!): String
  """Block"""
  block: TezosBlockWithHashDimension
  count(uniq: TezosTransferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, destinationContract: BooleanSelector, direction: StringSelector, amount: FloatSelector): Int
  countBigInt(uniq: TezosTransferUniq, date: DateSelector, time: DateTimeSelector, block: BigIntIdSelector, blockHash: HashSelector, proto: BigIntIdSelector, protocol: StringSelector, kind: StringSelector, transactionHash: HashSelector, transactionSource: StringSelector, opPath: StringSelector, internal: BooleanSelector, sender: AddressSelector, receiver: AddressSelector, destinationContract: BooleanSelector, direction: StringSelector, amount: FloatSelector): BigInt
  """Currency"""
  currency: Currency
  """Calendar date"""
  date: Date
  """Destination contract"""
  destinationContract: Boolean
  """Direction"""
  direction: String
  expression(get: String!): DecimalNumber
  """Internal"""
  internal: Boolean
  """Kind"""
  kind: String
  maximum(of: TezosTransferMeasurable!, get: TezosTransferMeasurable): String
  minimum(of: TezosTransferMeasurable!, get: TezosTransferMeasurable): String
  """Op path"""
  opPath: String
  """Proto"""
  proto: BigInt
  """Protocol"""
  protocol: String
  """Receiver"""
  receiver: Address
  """Sender"""
  sender: Address
  """Timestamp"""
  timestamp: DateTime
  """Transaction"""
  transaction: TezosTransactionWithSourceDimension
}

input TezosTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  block: BigIntIdSelector
  blockHash: HashSelector
  proto: BigIntIdSelector
  protocol: StringSelector
  kind: StringSelector
  transactionHash: HashSelector
  transactionSource: StringSelector
  opPath: StringSelector
  internal: BooleanSelector
  sender: AddressSelector
  receiver: AddressSelector
  destinationContract: BooleanSelector
  direction: StringSelector
  amount: FloatSelector
}

enum TezosTransferMeasurable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  blockHash
  """Proto"""
  proto
  """Protocol"""
  protocol
  """Kind"""
  kind
  """Transaction hash"""
  transactionHash
  """Transaction source"""
  transactionSource
  """Op path"""
  opPath
  """Internal"""
  internal
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Amount"""
  amount
  """Currency name"""
  currencyName
  """Currency symbol"""
  currencySymbol
  """Destination contract"""
  destinationContract
  """Direction"""
  direction
}

enum TezosTransferUniq {
  """Uniq dates count"""
  dates
  """Uniq times count"""
  times
  """Uniq blocks count"""
  blocks
  """Uniq block hashes count"""
  blockHashes
  """Uniq protos count"""
  protos
  """Uniq protocols count"""
  protocols
  """Uniq kinds count"""
  kinds
  """Uniq transaction hashes count"""
  transactionHashes
  """Uniq transaction sources count"""
  transactionSources
  """Uniq op paths count"""
  opPaths
  """Uniq senders count"""
  senders
  """Uniq receivers count"""
  receivers
  """Uniq currency names count"""
  currencyNames
  """Uniq currency symbols count"""
  currencySymbols
  """Uniq destination contracts count"""
  destinationContracts
  """Uniq directions count"""
  directions
}

"""Time Interval"""
type TimeInterval {
  day(count: Int, format: String): String!
  hour(count: Int, format: String): String!
  minute(count: Int, format: String): String!
  month(count: Int, format: String): String!
  second(count: Int, format: String): String!
  year(count: Int, format: String): String!
}

"""Timestamp"""
type Timestamp {
  """Nanoseconds"""
  nanoseconds: BigInt!
  time: ISO8601Date!
}

"""Select trade by ID"""
input TradeIdSelector {
  """Trade ID is"""
  is: String
  """Trade ID not"""
  not: String
  """Trade ID in the list"""
  in: [String!]
  """Trade ID not in the list"""
  notIn: [String!]
}

enum TradeSide {
  """Buy side"""
  BUY
  """Sell side"""
  SELL
}

"""Information about transaction"""
type TransactionElrond {
  """Shard number of sender"""
  data: String
  """Shard number of sender"""
  dataOperation: String
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Shard number of sender"""
  function: String
  """Transaction hash"""
  hash: String
  """Transaction index"""
  index: Int
  """Transaction nonce"""
  nonce: Int
  """Hash of the receiver"""
  receiver: Address
  """Shard number of receiver"""
  receiverShard: BigInt
  """Hash of the sender"""
  sender: Address
  """Shard number of sender"""
  senderShard: BigInt
  """Shard number of sender"""
  signature: String
  """Shard number of sender"""
  status: String
}

"""Blockchain transaction"""
type TransactionHash {
  """Hash hex representation"""
  hash: String!
}

"""Blockchain transaction"""
type TransactionHashIndex {
  """Block of the Output Transaction for this input"""
  block: Int
  """Hash hex representation"""
  hash: String!
  """Transaction index in block, 0-based"""
  index: String!
}

"""Blockchain transaction with value"""
type TransactionHashValue {
  """Hash hex representation"""
  hash: String!
  """Transaction value"""
  value: Float!
}

"""Blockchain transaction with value and time"""
type TransactionHashValueTime {
  """Hash hex representation"""
  hash: String!
  """Transaction time"""
  time: DateTime!
  """Transaction value"""
  value: Float!
}

"""Transaction result"""
type TransactionResult {
  """Result ID"""
  id: Int!
  """Result name"""
  name: String!
}

"""Identification of transaction source as client application"""
type TransactionSource {
  """ID numeric"""
  code: Int!
  """Name"""
  name: String!
}

enum TransfersUniq {
  """Transfers"""
  transfers
  """Unique transactions count"""
  txs
  """Unique senders count"""
  senders
  """Unique receivers count"""
  receivers
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Unique currencies"""
  currencies
}

"""Select by type of transfer"""
input TransferTypeSelector {
  """Transfer Type is"""
  is: FilecoinTransferType
  """Transfer Type not"""
  not: FilecoinTransferType
  """Transfer Type in the list"""
  in: [FilecoinTransferType!]
  """Transfer Type not in the list"""
  notIn: [FilecoinTransferType!]
}

"""Tron Chain"""
type Tron {
  """Basic information about address ( or smart contract )"""
  address(address: [AddressSelectorIn!]!): [TronAddressInfoWithBalance!]!
  """Blockchain Arguments"""
  arguments(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txIndex: IntegerSelector, txHash: HashSelector, owner: AddressSelector, receiver: AddressSelector, reference: AddressSelector, value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: ArgumentTypeSelector, signatureType: SignatureTypeSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector, any: [TronArgumentFilter!], options: QueryOptions): [TronArguments!]
  """Blockchain Blocks"""
  blocks(date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!], any: [TronBlockFilter!], options: QueryOptions): [TronBlocks!]
  """Money flow using Coinpath technology"""
  coinpath(sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, initialAddress: AddressSelector, initialDate: DateSelector, initialTime: DateTimeSelector, date: DateSelector, time: DateTimeSelector, depth: IntegerLimitedSelector, options: CoinpathOptions): [TronCoinpath!]
  """Blockchain Embedded Contracts"""
  contracts(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean, any: [TronContractFilter!], options: QueryOptions): [TronSmartContracts!]
  """Trades on Ethereum DEX Smart Contracts"""
  dexTrades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!], any: [TronDexTradeFilter!], options: QueryOptions): [TronDexTrades!]
  """Smart Contract Calls"""
  smartContractCalls(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean, any: [TronSmartContractCallFilter!], options: QueryOptions): [TronSmartContractCalls!]
  """Smart Contract Events"""
  smartContractEvents(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector, any: [TronSmartContractEventFilter!], options: QueryOptions): [TronSmartContractEvents!]
  """Blockchain Embedded Contracts"""
  trades(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean, any: [TronTradeFilter!], options: QueryOptions): [TronTrades!]
  """Blockchain Transactions"""
  transactions(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector, any: [TronTransactionFilter!], options: QueryOptions): [TronTransactions!]
  """Currency Transfers"""
  transfers(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!], any: [TronTransferFilter!], options: QueryOptions): [TronTransfers!]
}

"""Address detailed information for Tron network"""
type TronAddressInfo {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Smart Contract if exists on the address"""
  smartContract: TronSmartContractInfo
}

"""Blockchain address"""
type TronAddressInfoWithBalance {
  """Address"""
  address: String
  """Annotations ( tags ), if exists"""
  annotation: String
  """Current address balance"""
  balance(in: BaseCurrencyEnum): Float
  """Balances by currencies for the address"""
  balances(date: DateSelector, time: DateTimeSelector, currency: TronCurrencySelector, height: BlockSelectorRange): [TronBalance!]
  """Rewards that a witness or a user has not yet withdrawn"""
  claimableRewards(in: BaseCurrencyEnum): Float
  """Smart Contract if exists on the address"""
  smartContract: TronSmartContractInfo
}

input TronArgumentFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txIndex: IntegerSelector
  txHash: HashSelector
  owner: AddressSelector
  receiver: AddressSelector
  reference: AddressSelector
  value: [ArgumentValueSelector!]
  argument: [ArgumentSelector!]
  argumentType: ArgumentTypeSelector
  signatureType: SignatureTypeSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  smartContractEvent: EventSelector
  external: Boolean
  callDepth: StringSelector
}

"""Arguments of Smart Contract Calls and Events"""
type TronArguments {
  any(of: TronArgumentsMeasureable!, as: TronArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txIndex: IntegerSelector, txHash: HashSelector, owner: AddressSelector, receiver: AddressSelector, reference: AddressSelector, value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: ArgumentTypeSelector, signatureType: SignatureTypeSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  """Method or event argument"""
  argument(argument: [ArgumentSelector!], argumentType: String): ArgumentName
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Counts and other metrics"""
  count(uniq: TronArgumentUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txIndex: IntegerSelector, txHash: HashSelector, owner: AddressSelector, receiver: AddressSelector, reference: AddressSelector, value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: ArgumentTypeSelector, signatureType: SignatureTypeSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: TronArgumentUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txIndex: IntegerSelector, txHash: HashSelector, owner: AddressSelector, receiver: AddressSelector, reference: AddressSelector, value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: ArgumentTypeSelector, signatureType: SignatureTypeSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """External call executed explicitly by tx sender. Internal calls executed by smart contracts."""
  external: Boolean
  """Sequential index of value in array ( multi-dimensional)"""
  index: String!
  maximum(of: TronArgumentsMeasureable!, get: TronArgumentsMeasureable, as: TronArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txIndex: IntegerSelector, txHash: HashSelector, owner: AddressSelector, receiver: AddressSelector, reference: AddressSelector, value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: ArgumentTypeSelector, signatureType: SignatureTypeSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  minimum(of: TronArgumentsMeasureable!, get: TronArgumentsMeasureable, as: TronArgumentsConvertable, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txIndex: IntegerSelector, txHash: HashSelector, owner: AddressSelector, receiver: AddressSelector, reference: AddressSelector, value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: ArgumentTypeSelector, signatureType: SignatureTypeSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): String
  number(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txIndex: IntegerSelector, txHash: HashSelector, owner: AddressSelector, receiver: AddressSelector, reference: AddressSelector, value: [ArgumentValueSelector!], argument: [ArgumentSelector!], argumentType: ArgumentTypeSelector, signatureType: SignatureTypeSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, smartContractEvent: EventSelector, external: Boolean, callDepth: StringSelector): Float
  """Owner address"""
  owner: TronAddressInfo
  """Transaction receiver"""
  receiver: TronAddressInfo
  """Address value of method or event argument"""
  reference: TronAddressInfo
  """Smart contract being called"""
  smartContract: TronSmartContract
  """Contract method or event"""
  smartContractSignature(smartContractMethod: MethodSelector, smartContractEvent: EventSelector, signatureType: SignatureTypeSelector): Signature
  """Transaction Hash"""
  txHash: String
  """Transaction Index"""
  txIndex: Int
  """The Value of method or event argument"""
  value(value: [ArgumentValueSelector!]): ArgumentValue
}

enum TronArgumentsConvertable {
  """Token symbol"""
  token_symbol
  """Token name"""
  token_name
}

enum TronArgumentsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction Index"""
  tx_index
  """Owner"""
  owner
  """Receiver"""
  receiver
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature"""
  signature_type
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
  """Argument"""
  argument
  """Argument type"""
  argument_type
  """Argument value"""
  argument_value
  """Argument index"""
  argument_index
}

enum TronArgumentUniq {
  """Unique time"""
  times
  """Unique date count"""
  dates
  """Unique Number of block in the blockchains"""
  block_height
  """Calls"""
  calls
  """Unique Transaction Hash"""
  signature
  """Unique Values"""
  values
  """Unique Transactions"""
  txs
  """Unique Owners"""
  owners
  """Unique Receivers"""
  receivers
  """Unique number of arguments"""
  smart_contracts
}

"""Balance in a currency"""
type TronBalance {
  """Currency of transfer"""
  currency: Currency
  """History of balance changes by currencies for the address"""
  history: [TronBalanceChange!]
  value(in: BaseCurrencyEnum): Float
}

"""Change of balance in a currency"""
type TronBalanceChange {
  """Block number (height) in blockchain"""
  block: Int!
  """Block timestamp"""
  timestamp: ISO8601DateTime
  """Transfer amount ( positive inbound, negative outbound)"""
  transferAmount: Float
  value: Float
}

input TronBlockFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  blockHash: HashSelector
  witness: AddressSelector
  version: IntegerSelector
  parentBlockHash: [HashSelector!]
}

"""Blocks in Tron blockchain"""
type TronBlocks {
  any(of: TronBlocksMeasureable!): String
  count(uniq: TronBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!]): Int
  countBigInt(uniq: TronBlocksUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, blockHash: HashSelector, witness: AddressSelector, version: IntegerSelector, parentBlockHash: [HashSelector!]): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  """Block hash"""
  hash(blockHash: [HashSelector!]): String!
  """Block number (height) in blockchain"""
  height(height: BlockSelector): Int!
  maximum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String
  minimum(of: TronBlocksMeasureable!, get: TronBlocksMeasureable): String
  """Parent block hash"""
  parentBlockHash(parentBlockHash: [HashSelector!]): String!
  """Block timestamp"""
  timestamp(time: DateTimeSelector): DateTime
  """TX Trie Root Hash"""
  txTrieRoot: String!
  """Block version"""
  version(version: IntegerSelector): Int
  """Block witness"""
  witness(witness: AddressSelector): Address
  """Witness signature"""
  witnessSignature: String!
}

enum TronBlocksMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Block hash"""
  block_hash
  """Block Witness address"""
  witness
  """Block Version"""
  version
}

enum TronBlocksUniq {
  """Unique witness count"""
  witnesses
  """Unique date count"""
  dates
}

enum TronCallsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Action From"""
  tx_from
  """Action To"""
  tx_to
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature Hash"""
  signature_hash
  """Call depth"""
  call_depth
}

"""Coinpath"""
type TronCoinpath {
  """Summary of transfered value"""
  amount(in: BaseCurrencyEnum): Float
  any(of: CoinpathMeasureable!): String
  """Block where transaction is included"""
  block: Block
  """Count of transfers"""
  count: Int
  """Count of transfers"""
  countBigInt: BigInt
  """Currency of transfer"""
  currency: Currency
  """1-based hop depth of the graph"""
  depth: Int
  maximum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  minimum(of: CoinpathMeasureable!, get: CoinpathMeasureable): String
  """Receiver address"""
  receiver: TronCoinpathAddress
  """Sender address"""
  sender: TronCoinpathAddress
  """Transaction of transfer happened"""
  transaction: TransactionHashValueTime
}

"""Address detailed information for Ethereum network"""
type TronCoinpathAddress {
  """Address"""
  address: String
  """"""
  amountIn: DecimalNumber
  """"""
  amountOut: DecimalNumber
  """Annotations ( tags ), if exists"""
  annotation: String
  """"""
  balance: DecimalNumber
  """Smart Contract if exists on the address"""
  firstTxAt: DateTime
  """Smart Contract if exists on the address"""
  lastTxAt: DateTime
  """"""
  receiversCount: Int
  """"""
  sendersCount: Int
  """Smart Contract if exists on the address"""
  smartContract: TronSmartContractInfo
  """Address type"""
  type: String
}

input TronContractFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txOwner: AddressSelector
  contractType: TronContractTypeSelector
  currency: TronCurrencySelector
  success: Boolean
}

enum TronContractsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Transaction owner"""
  tx_owner
  """Contract"""
  contract_type
}

"""Select contract type(s)"""
input TronContractTypeSelector {
  """Contract type is"""
  is: String
  """Contract type not"""
  not: String
  """Contract type in the list"""
  in: [String!]
  """Contract type not in the list"""
  notIn: [String!]
}

"""
Currency selector in Tron blockchain.
Token identified by address of contract for TRC20 tokens and token name (or numeric token ID )  for TRC10
"""
input TronCurrencySelector {
  """Currency is"""
  is: String
  """Currency not"""
  not: String
  """Currency in the list"""
  in: [String!]
  """Currency not in the list"""
  notIn: [String!]
}

"""Tron DEX attributes"""
type TronDex {
  """Address for DEX exchange identification"""
  address: Address!
  """Full name ( name for known, Protocol for unknown )"""
  fullName: String!
  """Full name ( name for known, Protocol / address for unknown )"""
  fullNameWithId: String!
  """Name for known exchanges"""
  name: String
}

input TronDexTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  protocol: [StringSelector!]
  smartContractAddress: [AddressSelector!]
  exchangeAddress: [AddressSelector!]
  exchangeName: [StringSelector!]
  sellCurrency: [TronCurrencySelector!]
  buyCurrency: [TronCurrencySelector!]
  baseCurrency: [TronCurrencySelector!]
  quoteCurrency: [TronCurrencySelector!]
  maker: [AddressSelector!]
  taker: [AddressSelector!]
  makerOrTaker: [AddressSelector!]
  tradeIndex: [StringSelector!]
  buyAmount: [AmountSelector!]
  sellAmount: [AmountSelector!]
  price: [AmountSelector!]
  priceAsymmetry: [FloatSelector!]
  tradeAmountUsd: [FloatSelector!]
}

"""Trades on DEX smart contracts"""
type TronDexTrades {
  """Trader (maker or taker)"""
  address(makerOrTaker: [AddressSelector!]): TronAddressInfo
  any(of: TronDexTradesMeasureable!): String
  baseAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Base currency"""
  baseCurrency(baseCurrency: [TronCurrencySelector!]): Currency
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): BlockExtended
  buyAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Maker buys this currency"""
  buyCurrency(buyCurrency: [TronCurrencySelector!]): Currency
  count(uniq: TronDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  countBigInt(uniq: TronDexTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt
  """Calendar date"""
  date: Date
  energyFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  """Identification of admin / manager / factory of smart contract, executing trades"""
  exchange(exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!]): TronDex
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  internalTransactionsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  internalTransactionsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt
  logsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Int
  logsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): BigInt
  """Trade 'maker' side"""
  maker(maker: [AddressSelector!]): TronAddressInfo
  maximum(of: TronDexTradesMeasureable!, get: TronDexTradesMeasureable): String
  minimum(of: TronDexTradesMeasureable!, get: TronDexTradesMeasureable): String
  netFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  price(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  """Protocol name of the smart contract"""
  protocol(protocol: [StringSelector!]): String
  quoteAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Quote currency"""
  quoteCurrency(quoteCurrency: [TronCurrencySelector!]): Currency
  quotePrice(calculate: PriceAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, protocol: [StringSelector!], smartContractAddress: [AddressSelector!], exchangeAddress: [AddressSelector!], exchangeName: [StringSelector!], sellCurrency: [TronCurrencySelector!], buyCurrency: [TronCurrencySelector!], baseCurrency: [TronCurrencySelector!], quoteCurrency: [TronCurrencySelector!], maker: [AddressSelector!], taker: [AddressSelector!], makerOrTaker: [AddressSelector!], tradeIndex: [StringSelector!], buyAmount: [AmountSelector!], sellAmount: [AmountSelector!], price: [AmountSelector!], priceAsymmetry: [FloatSelector!], tradeAmountUsd: [FloatSelector!]): Float
  sellAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum): Float
  """Maker sells this currency"""
  sellCurrency(sellCurrency: [TronCurrencySelector!]): Currency
  """Side of trade ( SELL / BUY )"""
  side: TradeSide
  """Smart contract being called"""
  smartContract(smartContractAddress: [AddressSelector!]): TronSmartContract
  """Trade 'taker' side"""
  taker(taker: [AddressSelector!]): TronAddressInfo
  """Time interval"""
  timeInterval: TimeInterval
  tradeAmount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum!): Float
  """Index of trade in transaction, used to separate trades in transaction"""
  tradeIndex(tradeIndex: [StringSelector!]): String
  """Transaction of DexTrade"""
  transaction(txHash: [HashSelector!]): TronTransactionInfoExtended
}

enum TronDexTradesMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Buy Amount"""
  buy_amount
  """Sell Amount"""
  sell_amount
  """Price"""
  price
  """Quote Price"""
  quote_price
  """Maker"""
  maker
  """Taker"""
  taker
  """Buy Currency symbol"""
  buy_currency_symbol
  """Buy Token address"""
  buy_currency_address
  """Sell Currency symbol"""
  sell_currency_symbol
  """Sell Token address"""
  sell_currency_address
}

enum TronDexTradesUniq {
  """Unique makers count"""
  makers
  """Unique makers count"""
  takers
  """Unique makers & takers count"""
  address
  """Buy currencies count"""
  buy_currency
  """Sell currencies count"""
  sell_currency
  """Base currencies count"""
  base_currency
  """Quote currencies count"""
  quote_currency
  """Unique blocks"""
  blocks
  """Unique transactions count"""
  txs
  """Unique date count"""
  dates
  """Unique smart contract count"""
  smart_contracts
  """Unique protocols count"""
  protocols
}

enum TronEventsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Action From"""
  tx_from
  """Action To"""
  tx_to
  """Smart Contract"""
  smart_contract
  """Smart Contract Method Name"""
  signature_name
  """Smart Contract Method Signature"""
  signature
  """Smart Contract Method Signature Hash"""
  signature_hash
}

enum TronNetwork {
  """TRON mainnet"""
  tron
}

"""Tron smart contract"""
type TronSmartContract {
  """Smart Contract Address"""
  address: Address!
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

input TronSmartContractCallFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractMethod: MethodSelector
  external: Boolean
  success: Boolean
}

"""Smart Contract Calls"""
type TronSmartContractCalls {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  any(of: TronCallsMeasureable!): String
  """Call arguments"""
  arguments: [ArgumentNameValue!]
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Depth of the call. Empty string for external call, then counted as 0...N, and the next layer is added through '-'. For example 0-3-9."""
  callDepth: String
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): BigInt
  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  expression(get: String!): DecimalNumber
  """External call executed explicitly by caller. Internal calls executed by smart contracts."""
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  maximum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  minimum(of: TronCallsMeasureable!, get: TronCallsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractMethod: MethodSelector, external: Boolean, success: Boolean): Float
  """Smart contract being called"""
  smartContract(smartContractAddress: AddressSelector): TronSmartContract
  """Contract method invoked"""
  smartContractMethod(smartContractMethod: MethodSelector): Method
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Action from address"""
  txFrom(txFrom: AddressSelector): Address
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

input TronSmartContractEventFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  smartContractAddress: AddressSelector
  smartContractEvent: EventSelector
}

"""Smart Contract Events"""
type TronSmartContractEvents {
  any(of: TronEventsMeasureable!): String
  """Call arguments"""
  arguments: [ArgumentNameValue!]
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, smartContractAddress: AddressSelector, smartContractEvent: EventSelector): BigInt
  """Calendar date"""
  date: Date
  expression(get: String!): DecimalNumber
  maximum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String
  minimum(of: TronEventsMeasureable!, get: TronEventsMeasureable): String
  """Smart contract being Evented"""
  smartContract(smartContractAddress: AddressSelector): TronSmartContract
  """Contract method invoked"""
  smartContractEvent(smartContractEvent: EventSelector): Event
  """Action from address"""
  txFrom(txFrom: AddressSelector): Address
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

"""Blockchain smart contract"""
type TronSmartContractInfo {
  """Smart Contract Type"""
  contractType: SmartContractType
  """Token implemented in this smart contract"""
  currency: ScCurrency
  """Smart Contract Protocol Type"""
  protocolType: String
}

"""Contracts"""
type TronSmartContracts {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  any(of: TronContractsMeasureable!): String
  """Block in the blockchain"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Contract type"""
  contractType(contractType: TronContractTypeSelector): String
  """Counts and other metrics"""
  count(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Int
  """Counts and other metrics"""
  countBigInt(uniq: SmartContractCallsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): BigInt
  """Currency of transfer"""
  currency(currency: TronCurrencySelector): Currency
  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  maximum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  minimum(of: TronContractsMeasureable!, get: TronContractsMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txOwner: AddressSelector, contractType: TronContractTypeSelector, currency: TronCurrencySelector, success: Boolean): Float
  """True if call succeeded, false if error happened. Note, that by default only successfull calls are returned in API."""
  success(success: [Boolean!]): Boolean
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Transactio owner from address"""
  txOwner(txOwner: AddressSelector): Address
}

input TronTradeFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  buyer: AddressSelector
  seller: AddressSelector
  buyCurrency: TronCurrencySelector
  sellCurrency: TronCurrencySelector
  contractType: TronContractTypeSelector
  amountSell: [AmountSelector!]
  amountBuy: [AmountSelector!]
  exchangeId: IntIdSelector
  success: Boolean
}

"""Currency Trades from/to addresses in crypto currencies"""
type TronTrades {
  amountBuy(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  amountSell(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  any(of: TronTradesMeasureable!): String
  """Block where Trade transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Buy Currency of Trade"""
  buyCurrency(buyCurrency: TronCurrencySelector): Currency
  """Trade buyer"""
  buyer(buyer: AddressSelector): Address
  """Contract type"""
  contractType(contractType: TronContractTypeSelector): String
  count(uniq: TronTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Int
  countBigInt(uniq: TronTradesUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): BigInt
  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  """exchange_id"""
  exchangeId(exchangeId: IntIdSelector): Int
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  maximum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  minimum(of: TronTradesMeasureable!, get: TronTradesMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, buyer: AddressSelector, seller: AddressSelector, buyCurrency: TronCurrencySelector, sellCurrency: TronCurrencySelector, contractType: TronContractTypeSelector, amountSell: [AmountSelector!], amountBuy: [AmountSelector!], exchangeId: IntIdSelector, success: Boolean): Float
  """Sell Currency of Trade"""
  sellCurrency(sellCurrency: TronCurrencySelector): Currency
  """Trade seller"""
  seller(seller: AddressSelector): Address
  """Transfer succeeded"""
  success(success: Boolean): Boolean
  """Transaction hash where Trade happened"""
  txHash(txHash: HashSelector): String
}

enum TronTradesMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount Sell"""
  amount_sell
  """Amount Sell"""
  amount_buy
  """Buyer"""
  buyer
  """Seller"""
  seller
  """Buy Currency symbol"""
  buy_currency_symbol
  """Buy Currency name"""
  buy_currency_name
  """Buy Token address"""
  buy_currency_address
  """Buy Token address"""
  buy_token_id
  """Buy Token type"""
  buy_token_type
  """Buy Currency symbol"""
  sell_currency_symbol
  """Buy Currency name"""
  sell_currency_name
  """Buy Token address"""
  sell_currency_address
  """Buy Token address"""
  sell_token_id
  """Buy Token type"""
  sell_token_type
  """Exchange ID"""
  exchange_id
  """Contract Type"""
  contract_type
}

enum TronTradesUniq {
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
  """Sellers count"""
  sellers
  """Buyers count"""
  buyers
  """Buy currencies"""
  buy_currencies
  """Sell currencies"""
  sell_currencies
  """Exchange IDs"""
  exchanges
}

input TronTransactionFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txIndex: TxIndexSelector
  success: Boolean
  refBlockHash: [HashSelector!]
  contractAddress: AddressSelector
}

"""Blockchain Transaction Extended info"""
type TronTransactionInfoExtended {
  """Contract Address"""
  contractAddress: Address
  """Expiration"""
  expiration: Int!
  """Fee Limit"""
  feeLimit: Int!
  """Hash hex representation"""
  hash: String!
  """Transaction index in block, 0 based"""
  index: Int
  """Ref block Hash hex representation"""
  refBlockHash: String!
  """Result message"""
  result: String
  """Signatures"""
  signatures: String!
  """Success"""
  success: Boolean
}

"""Transactions in Tron blockchain"""
type TronTransactions {
  any(of: TronTransactionsMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Contract Address"""
  contractAddress(contractAddress: AddressSelector): Address
  count(uniq: TronTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  countBigInt(uniq: TronTransactionsUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): BigInt
  """Calendar date"""
  date: Date
  energyFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  """Expiration"""
  expiration: Int!
  expression(get: String!): DecimalNumber
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  """Fee Limit"""
  feeLimit: Int!
  """Hash hex representation"""
  hash(txHash: [HashSelector!]): String!
  """Transaction index in block, 0 based"""
  index(txIndex: [TxIndexSelector!]): Int
  internalTransactionsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  internalTransactionsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): BigInt
  logsCount(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Int
  logsCountBigInt(date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): BigInt
  maximum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  minimum(of: TronTransactionsMeasureable!, get: TronTransactionsMeasureable): String
  netFee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txIndex: TxIndexSelector, success: Boolean, refBlockHash: [HashSelector!], contractAddress: AddressSelector): Float
  """Ref block Hash hex representation"""
  refBlockHash(refBlockHash: [HashSelector!]): String!
  """Result message"""
  result: String
  """Signatures"""
  signatures: String!
  """Success"""
  success(success: Boolean): Boolean
}

enum TronTransactionsMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Fee"""
  fee
  """Fee Limit"""
  fee_limit
  """Energy Fee"""
  energy_fee
  """Net usage"""
  net_usage
  """Internal transactions count"""
  internal_transactions_count
}

enum TronTransactionsUniq {
  """Unique blocks"""
  blocks
  """Unique date count"""
  dates
}

input TronTransferFilter {
  date: DateSelector
  time: DateTimeSelector
  height: BlockSelector
  txHash: HashSelector
  txFrom: AddressSelector
  txTo: AddressSelector
  sender: AddressSelector
  receiver: AddressSelector
  currency: TronCurrencySelector
  contractType: TronContractTypeSelector
  entityId: EntitySelector
  external: Boolean
  success: Boolean
  amount: [AmountSelector!]
}

"""Currency transfers from/to addresses in crypto currencies"""
type TronTransfers {
  amount(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  any(of: TronTransfersMeasureable!): String
  """Block where transfer transaction is included"""
  block(height: BlockSelector, time: DateTimeSelector): Block
  """Contract type"""
  contractType(contractType: TronContractTypeSelector): String
  count(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Int
  countBigInt(uniq: TransfersUniq, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): BigInt
  """Currency of transfer"""
  currency(currency: TronCurrencySelector): Currency
  """Calendar date"""
  date: Date
  energyUsageTotal(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  """Entity identifier ( for ERC-721 NFT tokens )"""
  entityId(entityId: EntitySelector): String
  expression(get: String!): DecimalNumber
  """External transfer executed explicitly by tx sender. Internal transfers executed by smart contracts."""
  external(external: Boolean): Boolean
  fee(calculate: AmountAggregateFunction, in: BaseCurrencyEnum, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  maximum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  minimum(of: TronTransfersMeasureable!, get: TronTransfersMeasureable): String
  netUsage(calculate: AmountAggregateFunction, date: DateSelector, time: DateTimeSelector, height: BlockSelector, txHash: HashSelector, txFrom: AddressSelector, txTo: AddressSelector, sender: AddressSelector, receiver: AddressSelector, currency: TronCurrencySelector, contractType: TronContractTypeSelector, entityId: EntitySelector, external: Boolean, success: Boolean, amount: [AmountSelector!]): Float
  """Transfer receiver"""
  receiver(receiver: AddressSelector): Address
  """Transfer sender"""
  sender(sender: AddressSelector): Address
  """Transfer succeeded"""
  success(success: Boolean): Boolean
  """Action from address"""
  txFrom(txFrom: AddressSelector): Address
  """Transaction hash where transfer happened"""
  txHash(txHash: HashSelector): String
  """Action to address"""
  txTo(txTo: AddressSelector): Address
}

enum TronTransfersMeasureable {
  """Date"""
  date
  """Time"""
  time
  """Block"""
  block
  """Transaction hash"""
  tx_hash
  """Amount"""
  amount
  """Sender"""
  sender
  """Receiver"""
  receiver
  """Currency symbol"""
  currency_symbol
  """Token address"""
  currency_address
  """Token ID"""
  token_id
  """Token type"""
  token_type
}

"""Selector of index of transaction in block"""
input TxIndexSelector {
  """Tx index is"""
  is: Int
  """Tx index not"""
  not: Int
  """Tx index in the list"""
  in: [Int!]
  """Tx index not in the list"""
  notIn: [Int!]
}

"""Select transactions by subtype"""
input TxSubtypeSelector {
  """Transaction SubType is"""
  is: AlgorandTxSubType
  """Transaction SubType not"""
  not: AlgorandTxSubType
  """Transaction SubType in the list"""
  in: [AlgorandTxSubType!]
  """Transaction SubType not in the list"""
  notIn: [AlgorandTxSubType!]
}

"""Select transactions by type"""
input TxTypeSelector {
  """Transaction Type is"""
  is: AlgorandTxType
  """Transaction Type not"""
  not: AlgorandTxType
  """Transaction Type in the list"""
  in: [AlgorandTxType!]
  """Transaction Type not in the list"""
  notIn: [AlgorandTxType!]
}

"""Utilities"""
type Utilities {
  """Active period"""
  activePeriod(apiKey: String!, options: SeedOptions): ActivePeriod
  """Query metrics"""
  metrics(queryId: String!, options: SeedOptions): Metrics
}

"""UtilitiesDate"""
type UtilitiesDate {
  """String date representation with default format as YYYY-MM-DD"""
  date: String!
  """Day of month (1-31)"""
  dayOfMonth: Int!
  """Day of week  (Monday is 1, and Sunday is 7)"""
  dayOfWeek: Int!
  """Month number (1-12)"""
  month: Int!
  """Year number"""
  year: Int!
}
